# 第 1 章：最小内核

## 本章概述

> "千里之行，始于足下。"

本章将带你实现一个能够在 QEMU 上运行的最小内核，并通过 UART 串口输出第一条消息。这是 ErrorOS 的起点，也是理解裸机编程的关键一步。

---

## 学习目标

完成本章学习后，你将能够：

- ✅ 理解 `#![no_std]` 和 `#![no_main]` 的含义
- ✅ 编写裸机启动代码（`_start` 入口点）
- ✅ 实现 UART 串口驱动
- ✅ 封装 `print!` 和 `println!` 宏
- ✅ 在 QEMU 上看到第一个内核输出

---

## 内容导览

### 1.1 去除标准库依赖
学习如何脱离 Rust 标准库，进入"裸机"世界。我们将禁用 `std`，并实现 panic handler。

**关键概念：**
- `#![no_std]` 属性
- `#![no_main]` 属性
- Panic handler

### 1.2 实现最小内核程序
编写汇编启动代码，初始化栈指针，清零 BSS 段，跳转到 Rust `main` 函数。

**关键概念：**
- `_start` 入口点
- 栈指针（Stack Pointer）
- BSS 段清零
- 链接器脚本

### 1.3 UART 串口驱动实现
实现 UART 16550 串口驱动，通过内存映射 I/O（MMIO）实现字符输出。

**关键概念：**
- UART 16550 规范
- MMIO（Memory-Mapped I/O）
- 寄存器读写
- Volatile 访问

### 1.4 实现输出宏
封装 `print!` 和 `println!` 宏，使输出像 Rust 标准库一样方便。

**关键概念：**
- Rust 宏系统
- `core::fmt::Write` trait
- 静态变量与锁

### 1.5 第一个内核输出
运行内核，看到 "Hello, ErrorOS!" 输出。这是你操作系统开发的第一个里程碑！

**关键概念：**
- QEMU 运行参数
- 内核加载地址
- 调试输出

---

## 为什么重要？

最小内核是操作系统的"Hello World"，它让你：

1. **理解裸机编程**：没有操作系统的帮助，如何让程序运行？
2. **掌握启动流程**：从上电到执行第一行 Rust 代码，发生了什么？
3. **建立调试基础**：`println!` 是最强大的调试工具

---

## 技术亮点

- 🔧 **内联汇编**：Rust 与汇编的无缝结合
- 🔒 **并发安全**：使用 `Mutex` 保护 UART 设备
- 📝 **优雅输出**：支持格式化字符串的 `println!`

---

## 预计时间

⏱️ **约 2-3 小时**

---

## 开始学习

让我们开始编写第一行裸机代码！

👉 [1.1 去除标准库依赖](../实验指导书汇总/1.1%20去除标准库依赖.md)
