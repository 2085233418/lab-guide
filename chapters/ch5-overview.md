# 第 5 章：系统调用

## 本章概述

> "连接用户与内核的桥梁。"

系统调用是用户程序请求内核服务的唯一途径。本章将学习系统调用的原理，实现从用户态到内核态的切换，编写完整的系统调用框架。

---

## 学习目标

完成本章学习后，你将能够：

-  理解系统调用的本质和作用
-  掌握 `ecall` 指令的工作原理
-  实现系统调用的保存/恢复上下文
-  编写系统调用分发器
-  实现具体的系统调用（如 `sys_write`）
-  理解寄存器约定（calling convention）

---

## 内容导览

### 5.1 什么是系统调用
从"为什么需要系统调用"出发，理解用户态与内核态的隔离。

**关键概念：**
- 用户态 vs 内核态
- 系统调用的三大作用
- 系统调用表

### 5.2 系统调用的工作原理
深入学习 `ecall` 指令的工作流程，理解特权级切换的细节。

**关键概念：**
- `ecall` 指令
- `stvec` 寄存器
- `sepc` 保存返回地址
- `sret` 指令

### 5.3 实现系统调用的核心组件
编写系统调用的基础设施：上下文结构体、入口处理函数、分发器。

**关键概念：**
- `TrapContext` 结构体
- 系统调用号
- 参数传递（a0-a7）
- 返回值（a0）

### 5.4 实现具体的系统调用
实现常用的系统调用：`sys_write`、`sys_read`、`sys_exit` 等。

**关键概念：**
- 文件描述符
- 用户空间指针检查
- 错误码

---

## 为什么重要？

系统调用是操作系统的"API"：

1. **安全性**：保护内核不被用户程序破坏
2. **抽象性**：为用户提供统一的接口
3. **灵活性**：内核可以动态调整策略

---

## 技术亮点

-  **特权级切换**：从用户态到内核态的优雅舞蹈
-  **寄存器约定**：理解 RISC-V 调用约定
-  **安全检查**：验证用户空间指针

---

## 预计时间

 **约 2-3 小时**

---

## 开始学习

让我们连接用户与内核！

 [5.1 什么是系统调用](../实验指导书汇总/5.1%20什么是系统调用.md)
