# 7.2.2 目录操作实现

## 本节目标

- 实现目录项添加（add_entry）
- 实现目录项查找（lookup）
- 实现目录项删除（remove_entry）
- 实现目录列表（list_entries）
- 实现Inode trait

---

## 前置要求

- 已完成 7.2.1 节的 RamInode 设计和文件读写

---

## 步骤1：实现add_entry - 添加目录项

### 1.1 为什么需要add_entry？

**设计意图**：目录的核心功能是存储"文件名 → Inode"的映射关系。当用户创建新文件或子目录时，必须将其添加到父目录的映射表中，否则文件就无法被找到。

**典型场景**：
- **创建文件**：`touch /home/user/file.txt` → 需要在`/home/user`目录中添加`file.txt`条目
- **创建子目录**：`mkdir /home/user/docs` → 需要在`/home/user`目录中添加`docs`条目
- **硬链接**：`ln file1.txt file2.txt` → 需要添加第二个指向同一Inode的条目

**为什么不能直接插入BTreeMap？**

必须进行两项关键检查：
1. **类型检查**：只有目录才能添加条目（文件没有`entries`字段）
2. **重名检查**：同一目录下不能有同名文件（Unix约定）

**错误处理**：
- `NotDirectory`：试图向普通文件添加条目
- `AlreadyExists`：目录中已存在同名文件

在 `os/src/fs/ramfs.rs` 中继续添加：

**文件路径：`os/src/fs/ramfs.rs`**

```rust
impl RamInode {
    /// 向目录添加条目
    ///
    /// # 参数
    /// * `name` - 条目名称
    /// * `inode` - Inode引用
    ///
    /// # 错误
    /// * NotDirectory - 不是目录
    /// * AlreadyExists - 条目已存在
    pub fn add_entry(
        &mut self,
        name: String,
        inode: Arc<Mutex<RamInode>>,
    ) -> Result<(), FileError> {
        if self.file_type != FileType::Directory {
            return Err(FileError::NotDirectory);
        }

        if self.entries.contains_key(&name) {
            return Err(FileError::AlreadyExists);
        }

        self.entries.insert(name, inode);
        Ok(())
    }
}
```

**设计要点说明**：

1. **为什么参数是`name: String`而不是`&str`？**
   - BTreeMap的键类型是`String`（拥有所有权）
   - 如果参数是`&str`，需要调用`name.to_string()`创建副本
   - 直接传`String`避免不必要的拷贝（调用者可以用`String::from()`）
   - 符合Rust的"调用者决定所有权"原则

2. **为什么参数是`Arc<Mutex<RamInode>>`？**
   - 目录项需要共享所有权（硬链接场景：多个目录项指向同一Inode）
   - `Arc`支持引用计数，Inode不会被过早释放
   - `Mutex`保证线程安全的并发访问

3. **为什么先检查`contains_key`再`insert`？**
   - 防止覆盖已有文件：如果直接`insert`，同名文件会被悄悄替换
   - 符合Unix语义：创建已存在的文件应该报错（除非使用`O_TRUNC`标志）
   - 调用者可以根据错误类型决定处理策略

4. **为什么返回`Result<(), FileError>`？**
   - `()`表示成功时没有返回值（添加操作本身不产生数据）
   - `FileError`表示可能的错误（`NotDirectory`或`AlreadyExists`）
   - 调用者用`?`运算符传播错误

5. **为什么需要`&mut self`？**
   - 修改`entries` BTreeMap需要可变引用
   - 确保同一时刻只有一个线程能修改目录（Mutex保证）

### 1.2 使用示例

```rust
// 创建目录
let mut dir = RamInode::new_directory(1);

// 创建文件
let file = Arc::new(Mutex::new(RamInode::new_file(2)));

// 添加到目录
dir.add_entry(String::from("test.txt"), file)?;

// 错误场景1：重复添加
dir.add_entry(String::from("test.txt"), file2)?;  // Err(AlreadyExists)

// 错误场景2：向文件添加条目
let mut file = RamInode::new_file(3);
file.add_entry(String::from("name"), inode)?;  // Err(NotDirectory)
```

---

## 步骤2：实现lookup - 查找目录项

### 2.1 为什么需要lookup？

**设计意图**：查找是文件系统最核心的操作。用户访问任何文件都需要先在目录中查找到对应的Inode。没有lookup，就无法通过文件名访问文件。

**典型场景**：
- **打开文件**：`open("/home/user/file.txt")` → 需要逐级查找 home → user → file.txt
- **切换目录**：`cd /usr/bin` → 需要查找 usr → bin
- **检查文件是否存在**：`stat file.txt` → 需要在当前目录查找

**路径解析过程**：
```
查找 "/home/user/file.txt":
1. 从根目录开始
2. lookup("home") → 找到home目录的Inode
3. 在home目录中 lookup("user") → 找到user目录的Inode
4. 在user目录中 lookup("file.txt") → 找到文件的Inode
```

**为什么返回Arc而不是&RamInode？**

调用者可能需要长期持有引用，而`&RamInode`的生命周期受限于锁的持有时间。返回`Arc`允许：
- 跨函数传递Inode引用
- 多个地方同时持有同一个Inode
- 在释放锁后继续使用Inode

**文件路径：`os/src/fs/ramfs.rs`**

```rust
impl RamInode {
    /// 在目录中查找条目
    ///
    /// # 参数
    /// * `name` - 要查找的条目名称
    ///
    /// # 返回值
    /// * Ok(inode) - 找到的条目
    /// * Err(NotFound) - 条目不存在
    pub fn lookup(&self, name: &str) -> Result<Arc<Mutex<RamInode>>, FileError> {
        if self.file_type != FileType::Directory {
            return Err(FileError::NotDirectory);
        }

        self.entries.get(name).cloned().ok_or(FileError::NotFound)
    }
}
```

**设计要点说明**：

1. **为什么参数是`&str`而不是`String`？**
   - 查找操作不需要获取所有权，只需要读取
   - `&str`避免不必要的字符串拷贝（调用者可以传`"name"`或`&string`）
   - 性能更好：BTreeMap的`get`方法接受`&str`类型的键

2. **为什么需要`cloned()`？**
   - `BTreeMap::get()`返回`Option<&Arc<Mutex<RamInode>>>`（引用）
   - 调用者需要拥有`Arc`（不是引用），才能在函数返回后继续使用
   - `cloned()`增加Arc的引用计数，返回新的Arc副本

3. **为什么用`ok_or(FileError::NotFound)`？**
   - 将`Option<T>`转换为`Result<T, E>`
   - `Some(value)` → `Ok(value)`
   - `None` → `Err(FileError::NotFound)`
   - 调用者可以用`?`运算符传播错误

4. **为什么是`&self`而不是`&mut self`？**
   - 查找操作不修改目录内容
   - 允许多线程并发查找（共享引用）
   - 符合Unix语义：多个进程可以同时读取同一个目录

5. **链式调用的优雅**：
   ```rust
   self.entries.get(name)  // Option<&Arc<Mutex<RamInode>>>
       .cloned()           // Option<Arc<Mutex<RamInode>>>
       .ok_or(NotFound)    // Result<Arc<Mutex<RamInode>>, FileError>
   ```
   这种函数式风格简洁、高效，是Rust惯用写法。

### 2.3 使用示例

```rust
// 在根目录查找 "test.txt"
let root = ramfs.root();
let inode = root.lock().lookup("test.txt")?;

// 链式查找 "/home/user/file.txt"
let home = root.lock().lookup("home")?;
let user = home.lock().lookup("user")?;
let file = user.lock().lookup("file.txt")?;
```

### 2.4 路径解析示例

```
查找路径: /home/user/file.txt

步骤1: root.lookup("home")
  -> Arc<Mutex<RamInode>> (home目录)

步骤2: home.lock().lookup("user")
  -> Arc<Mutex<RamInode>> (user目录)

步骤3: user.lock().lookup("file.txt")
  -> Arc<Mutex<RamInode>> (file.txt文件)
```

---

## 步骤3：实现remove_entry - 删除目录项

### 3.1 为什么需要remove_entry？

**设计意图**：删除文件时，必须从父目录的映射表中移除对应的条目。这是文件删除操作的第一步（解除目录关联），之后Inode会根据引用计数自动释放。

**典型场景**：
- **删除文件**：`rm file.txt` → 从当前目录移除"file.txt"条目
- **删除目录**：`rmdir emptydir` → 从父目录移除"emptydir"条目
- **移动文件**：`mv old.txt new.txt` → 先remove_entry("old.txt")，再add_entry("new.txt")

**重要设计：只删除目录项，不删除Inode**

这是Unix文件系统的核心机制：
1. `remove_entry`只是删除"文件名 → Inode"的映射
2. Arc引用计数自动减1
3. 只有当引用计数为0时，Inode才真正释放

**为什么这样设计？**
- **支持硬链接**：同一个文件可以有多个名字（多个目录项指向同一Inode）
- **防止误删除**：只要还有一个硬链接存在，文件数据就不会丢失
- **自动内存管理**：Rust的Arc自动处理引用计数，无需手动释放

**文件路径：`os/src/fs/ramfs.rs`**

```rust
impl RamInode {
    /// 从目录中删除条目
    ///
    /// # 参数
    /// * `name` - 要删除的条目名称
    ///
    /// # 注意
    /// 只删除目录项，不删除inode
    /// （当引用计数为0时，Inode会自动释放）
    pub fn remove_entry(&mut self, name: &str) -> Result<(), FileError> {
        if self.file_type != FileType::Directory {
            return Err(FileError::NotDirectory);
        }

        self.entries.remove(name).ok_or(FileError::NotFound)?;
        Ok(())
    }
}
```

**设计要点说明**：

1. **为什么用`remove`而不是`take`？**
   - `BTreeMap::remove(key)` 返回 `Option<V>`（移除并返回值）
   - 我们不需要返回值，只需要确认删除成功
   - `remove`会自动减少Arc引用计数

2. **为什么用`ok_or(FileError::NotFound)?`？**
   - `remove`返回`Option<Arc<Mutex<RamInode>>>`
   - `None`表示条目不存在 → 转换为`Err(NotFound)`
   - `Some(inode)` → 转换为`Ok(())`，丢弃inode（Arc自动减引用计数）
   - `?`运算符在出错时提前返回

3. **为什么需要`&mut self`？**
   - 删除操作会修改`entries` BTreeMap
   - 必须持有可变引用
   - Mutex确保同一时刻只有一个线程能删除

4. **Arc的自动内存管理**：
   ```rust
   // 删除前：entries["file.txt"] 持有 Arc (引用计数=2)
   let removed = self.entries.remove("file.txt");  // 返回Some(Arc)
   // 此时Arc引用计数仍然=2

   drop(removed);  // 显式或隐式drop
   // Arc引用计数: 2 -> 1

   // 如果没有其他地方持有Arc，引用计数会变为0，Inode自动释放
   ```

5. **为什么不检查目录是否为空？**
   - 当前实现允许删除非空目录（简化版）
   - 实际系统应该检查：目录为空才能删除
   - 练习题中会要求实现完整版

### 3.2 Arc引用计数机制详解

```
场景：删除文件
root/
├── file1.txt -> Inode 5 (Arc强引用计数=2)
└── file2.txt -> Inode 5 (同一个Inode)

remove_entry("file1.txt"):
  1. 从entries中移除 "file1.txt"
  2. Arc引用计数: 2 -> 1
  3. Inode 5仍然存在（file2.txt还在引用）

remove_entry("file2.txt"):
  1. 从entries中移除 "file2.txt"
  2. Arc引用计数: 1 -> 0
  3. Inode 5自动释放（无人引用）
```

### 3.3 Arc自动内存管理

**Arc的工作原理**：

```rust
let inode = Arc::new(data);  // 引用计数 = 1

let ref1 = inode.clone();    // 引用计数 = 2
let ref2 = inode.clone();    // 引用计数 = 3

drop(ref1);                  // 引用计数 = 2
drop(ref2);                  // 引用计数 = 1
drop(inode);                 // 引用计数 = 0, 自动释放内存
```

### 3.4 硬链接场景

```rust
// 创建文件
let inode = Arc::new(Mutex::new(RamInode::new_file(5)));

// 添加两个硬链接
dir.add_entry(String::from("file1.txt"), inode.clone());
dir.add_entry(String::from("file2.txt"), inode.clone());

// 删除第一个链接
dir.remove_entry("file1.txt")?;  // Inode 5还存在

// 删除第二个链接
dir.remove_entry("file2.txt")?;  // Inode 5被释放
```

---

## 步骤4：实现list_entries - 列出目录项

### 4.1 为什么需要list_entries？

**设计意图**：用户需要查看目录中有哪些文件和子目录，这是文件系统的基本功能。`list_entries`实现类似Unix的`ls`命令。

**典型场景**：
- **ls命令**：列出当前目录的所有文件
- **文件浏览器**：显示目录树
- **自动补全**：shell输入文件名时提示候选

**为什么返回Vec<String>而不是Vec<Arc<Mutex<RamInode>>>？**

调用者通常只需要文件名列表（用于显示），不需要访问Inode。返回文件名：
- 更轻量：避免增加Arc引用计数
- 更简单：调用者不需要处理Mutex和Inode
- 更安全：防止调用者意外修改目录内容

**为什么BTreeMap能保证顺序？**

BTreeMap按键排序存储，`keys()`方法返回的迭代器自动按字母顺序遍历。这让`ls`输出自动有序，无需额外排序。

**文件路径：`os/src/fs/ramfs.rs`**

```rust
impl RamInode {
    /// 列出目录中的所有条目
    ///
    /// # 返回值
    /// 条目名称的向量（按字母顺序排序）
    pub fn list_entries(&self) -> Result<Vec<String>, FileError> {
        if self.file_type != FileType::Directory {
            return Err(FileError::NotDirectory);
        }

        Ok(self.entries.keys().cloned().collect())
    }
}
```

**设计要点说明**：

1. **为什么用`keys()`而不是`iter()`？**
   - `keys()`返回键的迭代器（文件名）
   - `iter()`返回`(键, 值)`对的迭代器
   - 我们只需要文件名，不需要Inode引用

2. **为什么需要`cloned()`？**
   - `keys()`返回`&String`（引用）
   - 我们需要返回`Vec<String>`（拥有所有权）
   - `cloned()`将每个`&String`克隆为`String`

3. **为什么用`collect()`？**
   - 将迭代器收集为`Vec<String>`
   - Rust的类型推导自动确定收集的目标类型
   - 这是函数式编程的惯用写法

4. **链式调用解析**：
   ```rust
   self.entries       // BTreeMap<String, Arc<Mutex<RamInode>>>
       .keys()        // 迭代器: Iterator<Item = &String>
       .cloned()      // 迭代器: Iterator<Item = String>
       .collect()     // Vec<String>
   ```

5. **性能考虑**：
   - 时间复杂度：O(n)，需要遍历所有条目
   - 空间复杂度：O(n)，需要克隆所有文件名字符串
   - 对于小目录（< 1000个文件），性能开销可忽略

### 4.2 BTreeMap自动排序

**BTreeMap的特性**：

```rust
let mut entries = BTreeMap::new();
entries.insert("c.txt", inode_c);
entries.insert("a.txt", inode_a);
entries.insert("b.txt", inode_b);

// keys()返回的迭代器自动按字母顺序
for name in entries.keys() {
    println!("{}", name);
}

// 输出:
// a.txt
// b.txt
// c.txt
```

### 4.3 使用示例：实现ls命令

```rust
// 列出根目录内容
let root = ramfs.root();
let entries = root.lock().list_entries()?;

for name in entries {
    println!("{}", name);
}

// 输出:
// dir1
// file1.txt
// file2.txt
```

---

## 步骤5：实现Inode trait

### 5.1 为RamInode实现Inode trait

**文件路径：`os/src/fs/ramfs.rs`**

```rust
impl Inode for RamInode {
    fn ino(&self) -> usize {
        self.ino
    }

    fn file_type(&self) -> FileType {
        self.file_type
    }

    fn size(&self) -> usize {
        self.size
    }

    fn mode(&self) -> u32 {
        self.mode
    }
}
```

### 5.2 trait实现说明

**简单字段访问**：

- 只是返回内部字段的值
- 实现Inode trait后，可以通过trait方法统一访问

**用途**：

```rust
// 统一接口
fn print_inode_info(inode: &dyn Inode) {
    println!("Inode: {}", inode.ino());
    println!("Size: {}", inode.size());
    println!("Mode: {:o}", inode.mode());
}

// 可以传入任何实现了Inode的类型
let ram_inode = RamInode::new_file(1);
print_inode_info(&ram_inode);
```

---

## 知识点总结

### 目录操作核心方法

| 方法 | 作用 | 时间复杂度 |
|------|------|-----------|
| add_entry | 添加目录项 | O(log n) |
| lookup | 查找目录项 | O(log n) |
| remove_entry | 删除目录项 | O(log n) |
| list_entries | 列出所有项 | O(n) |

### BTreeMap特性

| 特性 | 说明 |
|------|------|
| 有序 | 按键排序 |
| 查找 | O(log n) |
| 插入 | O(log n) |
| 删除 | O(log n) |

### Arc引用计数

```
Arc<T>的生命周期：
  创建: Arc::new(data)         // 计数 = 1
  克隆: arc.clone()            // 计数 + 1
  Drop: drop(arc)              // 计数 - 1
  释放: 计数 = 0 时自动释放内存
```

---

## 常见问题

### Q1: 为什么lookup返回Arc<Mutex<RamInode>>而不是&RamInode？

**原因**：

- 调用者可能需要长期持有引用
- `&RamInode`的生命周期受借用检查限制
- `Arc`允许共享所有权，更灵活

**对比**：

```rust
// 返回引用（受限）
fn lookup(&self, name: &str) -> Option<&RamInode> {
    self.entries.get(name).map(|arc| &**arc.lock())
    // 编译错误：返回值的生命周期无法确定
}

// 返回Arc（正确）
fn lookup(&self, name: &str) -> Option<Arc<Mutex<RamInode>>> {
    self.entries.get(name).cloned()
    // Arc::clone增加引用计数，调用者可以安全持有
}
```

### Q2: 为什么不检查目录是否为空就允许删除？

**当前实现**：

```rust
// 简化版：不检查目录是否为空
pub fn remove_entry(&mut self, name: &str) -> Result<(), FileError> {
    self.entries.remove(name).ok_or(FileError::NotFound)?;
    Ok(())
}
```

**改进版**：

```rust
// 完整版：检查目录非空
pub fn remove(&mut self, name: &str) -> Result<(), FileError> {
    let inode = self.lookup(name)?;

    // 检查是否是非空目录
    if inode.lock().file_type() == FileType::Directory {
        let entries = inode.lock().list_entries()?;
        if !entries.is_empty() {
            return Err(FileError::NotEmpty);  // 需要添加此错误类型
        }
    }

    self.entries.remove(name).ok_or(FileError::NotFound)?;
    Ok(())
}
```

### Q3: BTreeMap比HashMap慢，为什么还用它？

**性能对比**：

```
小规模目录（<100个文件）：
  HashMap: O(1) = 1ns
  BTreeMap: O(log n) = 7ns
  差异：6ns（人类无感知）

用户体验：
  HashMap: 目录列表乱序
  BTreeMap: 目录列表有序
  差异：明显（用户可感知）
```

**结论**：用户体验 > 微小性能差异

---

## 下一步

在下一节（7.2.3）中，我们将实现RamFile文件句柄和RamFS文件系统。

---

## 练习题

1. **实现is_empty**：添加`is_empty()`方法，检查目录是否为空
2. **实现find**：添加`find(pattern)`方法，支持通配符查找
3. **实现rename**：添加`rename(old, new)`方法，重命名目录项
