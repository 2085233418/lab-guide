# 7.3.1 系统调用号定义和read/write实现

## 本节目标

- 理解系统调用机制
- 添加文件系统系统调用号
- 实现sys_read系统调用
- 实现sys_write系统调用
- 理解用户态缓冲区访问

---

## 本节修改文件

```
os/src/syscall/
├── mod.rs              # 添加系统调用号（修改）
└── syscall_impl.rs     # 实现read/write（修改）
```

---

## 重要提示

### 使用trap模块

从第6章开始，我们已经将中断处理迁移到`trap`模块。系统调用的陷阱处理也使用该模块。

```rust
// 正确：使用trap模块
use crate::trap;

// 错误：不要使用interrupts
// use crate::interrupts;  // 已废弃
```

### 输出使用英文

所有系统调用相关的输出必须使用英文，避免终端编码问题：

```rust
// 正确
serial_println!("[SYSCALL] sys_write: invalid fd={}", fd);

// 错误
serial_println!("[系统调用] sys_write: 无效的文件描述符={}", fd);
```

---

## 步骤1：回顾系统调用机制

### 1.1 为什么需要系统调用？

前面的章节有提到过，操作系统必须保护内核资源不被用户程序直接访问。系统调用提供了一个受控的接口，让用户程序可以请求内核服务，同时保持系统的安全性和稳定性。

**安全问题**：如果允许用户程序直接访问内核资源会怎样？

```rust
// 危险：用户直接访问内核数据结构
let fd_table = &mut KERNEL_FD_TABLE;  // 用户能看到所有进程的文件！
fd_table.dealloc(5);  // 用户能关闭其他进程的文件！

// 危险：用户直接访问硬件
PORT_0x3F8.write(0xFF);  // 用户能破坏串口通信！

// ✓ 安全：通过系统调用间接访问
syscall(SYS_WRITE, 1, "hello", 5);  // 内核检查权限后执行
```

**为什么需要隔离？**

1. **安全性**：防止恶意程序破坏系统或窃取数据
2. **稳定性**：防止错误程序（如野指针）导致内核崩溃
3. **资源管理**：内核统一分配资源，避免冲突

**类比理解**：系统调用就像银行柜台

| 概念 | 银行类比 | 操作系统 |
|------|---------|---------|
| 用户 | 客户 | 用户程序（U模式） |
| 内核 | 金库 | 内核代码和数据（S模式） |
| 系统调用 | 柜员 | syscall接口 |
| 参数 | 业务单据 | 寄存器a0-a7 |
| 返回值 | 业务结果 | 寄存器a0 |

- 客户不能直接进入金库（用户不能直接访问内核）
- 必须通过柜员办理业务（通过系统调用请求服务）
- 柜员验证身份和权限（内核检查参数和权限）
- 柜员代理执行操作（内核代替用户执行）

### 1.2 文件系统系统调用列表

| 系统调用号 | 名称 | 功能 | 参数 | 返回值 |
|-----------|------|------|------|--------|
| 63 | sys_read | 读取文件 | fd, buf, len | 读取字节数/-1 |
| 64 | sys_write | 写入文件 | fd, buf, len | 写入字节数/-1 |
| 56 | sys_open | 打开/创建文件 | path, flags | fd/-1 |
| 57 | sys_close | 关闭文件 | fd | 0/-1 |
| 34 | sys_mkdir | 创建目录 | path | 0/-1 |

**系统调用号来源**：兼容Linux RISC-V调用约定

**为什么是这些数字？**

```
Linux RISC-V系统调用表：
34  = mkdir
56  = openat (我们简化为open)
57  = close
63  = read
64  = write
```

---

## 步骤2：添加系统调用号

### 2.1 扩展SyscallId枚举

修改 `os/src/syscall/mod.rs`：

**文件路径：`os/src/syscall/mod.rs`**

```rust
/// 系统调用ID
///
/// 兼容Linux RISC-V系统调用号
#[repr(usize)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum SyscallId {
    // 文件系统系统调用（第7章）
    Mkdir = 34,      // 创建目录
    Open = 56,       // 打开/创建文件
    Close = 57,      // 关闭文件描述符
    Read = 63,       // 从文件读取
    Write = 64,      // 写入文件

    // 进程系统调用（第6章）
    Exit = 93,       // 退出进程
    GetPid = 172,    // 获取进程ID
    Fork = 220,      // Fork进程
    Exec = 221,      // 执行程序
    WaitPid = 260,   // 等待子进程

    Unknown = 9999,
}
```

**组织方式**：

- 按数字顺序排列（便于查找）
- 添加注释说明功能
- 标注引入章节

### 2.2 更新From实现

**文件路径：`os/src/syscall/mod.rs`**

```rust
impl From<usize> for SyscallId {
    fn from(num: usize) -> Self {
        match num {
            // 文件系统系统调用
            34 => SyscallId::Mkdir,//新增
            56 => SyscallId::Open,//新增
            57 => SyscallId::Close,//新增
            63 => SyscallId::Read,
            64 => SyscallId::Write,

            // 进程系统调用
            93 => SyscallId::Exit,
            172 => SyscallId::GetPid,
            220 => SyscallId::Fork,
            221 => SyscallId::Exec,
            260 => SyscallId::WaitPid,

            _ => SyscallId::Unknown,
        }
    }
}
```

---

## 步骤3：实现sys_read系统调用

### 3.1 为什么需要sys_read？

**设计意图**：`sys_read`是用户态程序读取文件的唯一途径。用户程序无法直接访问内核的文件系统和FD表，必须通过系统调用请求内核代理执行读取操作。

**典型场景**：
- **读取文件内容**：`read(fd, buf, 100)` → 从打开的文件读取最多100字节
- **从stdin读取输入**：`read(0, buf, 1024)` → 读取用户键盘输入
- **网络socket接收**：`read(sock_fd, buf, len)` → 接收网络数据

**为什么用户不能直接读取？**

如果允许用户直接访问文件对象，会有严重的安全问题：
```rust
// 危险：用户直接访问FD表
let fd_table = &KERNEL_FD_TABLE;
let file = fd_table.entries[5];  // 用户能访问其他进程的文件！
file.lock().read(buf)?;  // 绕过权限检查！

// ✓ 安全：通过系统调用
syscall(SYS_READ, fd, buf, len);  // 内核检查FD是否属于当前进程
```

**内核需要做什么？**
1. **验证FD有效性**：检查FD是否在当前进程的FD表中
2. **权限检查**：确认进程有读取该文件的权限
3. **地址验证**：确认用户提供的缓冲区地址合法
4. **安全拷贝**：使用内核缓冲区作为中转，避免直接访问用户内存

在 `os/src/syscall/syscall_impl.rs` 中添加：

**文件路径：`os/src/syscall/syscall_impl.rs`**

```rust
use crate::fs::{FD_TABLE, FileDescriptor};
use crate::serial_println;

/// sys_read - 从文件描述符读取数据
///
/// # 参数
/// * `fd` - 文件描述符
/// * `buf` - 用户态缓冲区地址
/// * `len` - 要读取的字节数
///
/// # 返回值
/// * 成功: 实际读取的字节数
/// * 失败: -1
pub fn sys_read(fd: FileDescriptor, buf: usize, len: usize) -> isize {
    serial_println!("[SYSCALL] sys_read: fd={}, buf=0x{:x}, len={}", fd, buf, len);

    // TODO: 验证用户态地址

    // 获取文件对象
    let file = match FD_TABLE.lock().get(fd) {
        Some(f) => f,
        None => {
            serial_println!("[SYSCALL] sys_read: invalid fd={}", fd);
            return -1;
        }
    };

    // 创建缓冲区
    let mut kernel_buf = vec![0u8; len];

    // 读取数据
    let n = match file.lock().read(&mut kernel_buf) {
        Ok(n) => n,
        Err(e) => {
            serial_println!("[SYSCALL] sys_read: read failed: {:?}", e);
            return -1;
        }
    };

    // 拷贝到用户态
    unsafe {
        let user_buf = core::slice::from_raw_parts_mut(buf as *mut u8, n);
        user_buf.copy_from_slice(&kernel_buf[..n]);
    }

    serial_println!("[SYSCALL] sys_read: success, read {} bytes", n);
    n as isize
}
```

**设计要点说明**：

1. **为什么参数是`buf: usize`而不是`&mut [u8]`？**
   - 系统调用接口传递原始指针（寄存器值），不能传递Rust引用
   - `usize`是用户空间的地址，内核需要手动转换为指针
   - 必须用`unsafe`访问用户空间地址

2. **为什么需要`FD_TABLE.lock().get(fd)`？**
   - 验证FD是否有效：防止用户传递随机数字
   - 获取File对象：`Arc<Mutex<dyn File>>`
   - 锁的作用：保证并发安全（多线程同时访问FD表）

3. **为什么要创建内核缓冲区`vec![0u8; len]`？**
   - **安全隔离**：不能让文件系统直接写入用户内存（用户地址可能无效）
   - **两步拷贝**：先读到内核缓冲区（安全），再拷贝到用户缓冲区（可控）
   - **错误处理**：如果读取失败，用户缓冲区不会被污染

4. **为什么用`file.lock().read()`？**
   - `file`是`Arc<Mutex<dyn File>>`类型
   - `lock()`获取Mutex守卫，确保独占访问
   - `read()`是File trait的方法，会更新文件的offset

5. **为什么用`unsafe`和`from_raw_parts_mut`？**
   - 用户传递的`buf`是原始地址，需要转换为可变切片
   - Rust无法验证用户地址的有效性，所以必须用`unsafe`
   - 这是内核与用户空间交互的必经之路

6. **为什么返回`n as isize`而不是`Ok(n)`？**
   - 系统调用约定：返回值通过寄存器传递，必须是整数
   - 负数表示错误（如-1），非负数表示成功（读取的字节数）
   - 兼容Unix系统调用接口

### 3.2 算法流程图解

![p2](pictures/p2.png)

### 3.3 为什么需要内核缓冲区？

**安全性问题**：

```rust
//  错误：直接操作用户态内存
let user_buf = unsafe { slice::from_raw_parts_mut(buf as *mut u8, len) };
file.read(user_buf)?;  // 危险！用户可能传递无效地址

// 问题1: 如果buf=0（空指针），内核会崩溃
// 问题2: 如果buf指向内核地址，用户能读取内核数据
// 问题3: 如果buf越界，会破坏其他进程的内存
```

**正确方式（两步拷贝）**：

```rust
// ✓ 正确：使用内核缓冲区作为中转
let mut kernel_buf = vec![0u8; len];  // 步骤1: 分配内核缓冲区
file.read(&mut kernel_buf)?;          // 步骤2: 读取到内核缓冲区（安全）

// 步骤3: 验证用户地址（TODO）
if !is_user_address(buf, len) {
    return -1;  // 拒绝无效地址
}

// 步骤4: 拷贝到用户态（可控）
unsafe {
    let user_buf = slice::from_raw_parts_mut(buf as *mut u8, n);
    user_buf.copy_from_slice(&kernel_buf[..n]);
}
```

**为什么这样更安全？**
1. 文件系统只访问内核内存，不会被用户欺骗
2. 即使读取失败，也不会污染用户内存
3. 可以在拷贝前验证用户地址的合法性

### 3.4 用户态地址访问的危险性

```rust
unsafe {
    let user_buf = core::slice::from_raw_parts_mut(buf as *mut u8, n);
    user_buf.copy_from_slice(&kernel_buf[..n]);
}
```

**为什么必须用`unsafe`？**

| 风险 | 说明 | 后果 |
|------|------|------|
| 无效地址 | 用户传递空指针或未映射地址 | 内核页错误，系统崩溃 |
| 越界访问 | buf+len超出用户空间范围 | 覆盖其他进程内存 |
| 内核地址 | 用户传递内核地址 | 泄露内核数据 |
| 只读内存 | buf指向代码段 | 写入失败，程序崩溃 |

**后续改进（地址验证）**：

```rust
/// 检查地址是否在用户空间
fn is_user_address(addr: usize, len: usize) -> bool {
    let end = addr.saturating_add(len);
    // 简化版：用户空间 0x0000_0000 - 0x3fff_ffff
    addr < 0x4000_0000 && end <= 0x4000_0000
}

// 在sys_read开头添加检查
if !is_user_address(buf, len) {
    serial_println!("[SYSCALL] sys_read: invalid user address");
    return -1;
}
```

---

## 步骤4：实现sys_write系统调用

### 4.1 为什么需要sys_write？

**设计意图**：`sys_write`是用户态程序写入文件的唯一途径。与`sys_read`对称，用户无法直接访问文件系统，必须通过系统调用请求内核代理执行写入操作。

**典型场景**：
- **写入文件内容**：`write(fd, "hello", 5)` → 将字符串写入打开的文件
- **输出到终端**：`write(1, "log\n", 4)` → 输出日志到stdout
- **网络socket发送**：`write(sock_fd, data, len)` → 发送网络数据

**为什么用户不能直接写入？**

如果允许用户直接写入文件对象，会有严重的安全和稳定性问题：
```rust
// 危险：用户直接写入文件
let file = &mut KERNEL_FILES[fd];
file.write(attacker_data)?;  // 用户能破坏系统文件！

// 问题1: 用户能覆盖系统关键文件（如/etc/passwd）
// 问题2: 用户能写入其他进程的打开文件
// 问题3: 绕过磁盘配额、权限检查等安全机制

// ✓ 安全：通过系统调用
syscall(SYS_WRITE, fd, buf, len);  // 内核检查权限和配额
```

**内核需要做什么？**
1. **验证FD有效性**：确认FD属于当前进程
2. **权限检查**：确认进程有写入权限
3. **地址验证**：确认用户缓冲区地址合法
4. **安全拷贝**：先拷贝到内核缓冲区，再写入文件（防止TOCTOU攻击）

**文件路径：`os/src/syscall/syscall_impl.rs`**

```rust
/// sys_write - 向文件描述符写入数据
///
/// # 参数
/// * `fd` - 文件描述符
/// * `buf` - 用户态缓冲区地址
/// * `len` - 要写入的字节数
///
/// # 返回值
/// * 成功: 实际写入的字节数
/// * 失败: -1
pub fn sys_write(fd: FileDescriptor, buf: usize, len: usize) -> isize {
    serial_println!("[SYSCALL] sys_write: fd={}, buf=0x{:x}, len={}", fd, buf, len);

    // TODO: 验证用户态地址

    // 获取文件对象
    let file = match FD_TABLE.lock().get(fd) {
        Some(f) => f,
        None => {
            serial_println!("[SYSCALL] sys_write: invalid fd={}", fd);
            return -1;
        }
    };

    // 从用户态拷贝数据
    let kernel_buf = unsafe {
        let user_buf = core::slice::from_raw_parts(buf as *const u8, len);
        user_buf.to_vec()
    };

    // 写入数据
    let n = match file.lock().write(&kernel_buf) {
        Ok(n) => n,
        Err(e) => {
            serial_println!("[SYSCALL] sys_write: write failed: {:?}", e);
            return -1;
        }
    };

    serial_println!("[SYSCALL] sys_write: success, wrote {} bytes", n);
    n as isize
}
```

**设计要点说明**：

1. **为什么用`from_raw_parts`而不是`from_raw_parts_mut`？**
   - 写入操作只需**读取**用户缓冲区的数据，不需要修改
   - `from_raw_parts`创建不可变切片（`&[u8]`）
   - `from_raw_parts_mut`创建可变切片（`&mut [u8]`），用于read操作
   - 最小权限原则：只读就够了，不要可变引用

2. **为什么用`to_vec()`而不是`copy_from_slice`？**
   - `to_vec()`一步完成：分配内核缓冲区 + 拷贝数据
   - 等价于：
     ```rust
     let mut kernel_buf = vec![0u8; len];
     kernel_buf.copy_from_slice(user_buf);
     ```
   - 更简洁，性能相同

3. **为什么要先拷贝到内核缓冲区？**
   - **防止TOCTOU攻击**（Time-Of-Check-Time-Of-Use）：
     ```rust
     //  危险：直接传递用户指针
     file.write(user_buf)?;
     // 用户可能在检查后、写入前修改buf内容！
     
     // ✓ 安全：先拷贝到内核（原子快照）
     let kernel_buf = user_buf.to_vec();  // 此时数据已固定
     file.write(&kernel_buf)?;  // 写入的是快照，用户无法修改
     ```
   - **隔离用户空间**：文件系统不直接访问用户内存，更安全

4. **为什么`file.lock().write()`？**
   - `file`是`Arc<Mutex<dyn File>>`
   - `lock()`获取独占访问权
   - `write()`会更新文件offset和size

5. **为什么可以直接传`&kernel_buf`？**
   - `kernel_buf`是`Vec<u8>`，实现了`Deref<Target = [u8]>`
   - `&kernel_buf`自动解引用为`&[u8]`
   - `write`方法接受`&[u8]`参数

6. **read vs write的对称设计**：
   | 操作 | sys_read | sys_write |
   |------|----------|-----------|
   | 缓冲区创建 | `vec![0; len]` | `user_buf.to_vec()` |
   | 数据流向 | 文件 → 内核 → 用户 | 用户 → 内核 → 文件 |
   | unsafe操作 | `from_raw_parts_mut` | `from_raw_parts` |
   | 权限 | 可变（写入用户内存） | 不可变（读取用户内存） |

### 4.2 read vs write对比

| 操作 | sys_read | sys_write |
|------|----------|-----------|
| 数据流向 | 内核 → 用户 | 用户 → 内核 |
| 用户缓冲区 | from_raw_parts_mut | from_raw_parts |
| 内核缓冲区 | vec![0; len] | user_buf.to_vec() |
| 拷贝方向 | kernel → user | user → kernel |

### 4.3 使用示例

**用户态代码**：

```c
// C代码
char buf[100];
int n = read(0, buf, 100);  // 从stdin读取
write(1, buf, n);           // 写入stdout
```

**内核态流程**：

```
read(0, buf, 100):
  1. 陷入内核
  2. sys_read(0, buf, 100)
  3. 从stdin读取到kernel_buf
  4. 拷贝到用户buf
  5. 返回用户态

write(1, buf, n):
  1. 陷入内核
  2. sys_write(1, buf, n)
  3. 从用户buf拷贝到kernel_buf
  4. 写入stdout
  5. 返回用户态
```

---

## 知识点总结

### 系统调用执行流程

```
用户态:
  ecall
    ↓
硬件:
  保存sepc
  切换到S模式
    ↓
内核态:
  trap_handler
    ↓
  syscall_dispatcher
    ↓
  sys_xxx
    ↓
  sret
    ↓
用户态:
  继续执行
```

### 缓冲区拷贝

| 方向 | 操作 | 函数 |
|------|------|------|
| 内核→用户 | read | copy_from_slice |
| 用户→内核 | write | to_vec |

### 安全性检查

**必需检查**：

1. FD是否有效
2. 用户地址是否合法
3. 长度是否溢出

**当前实现**：

- 已检查FD有效性
- 未检查用户地址（TODO）

---

## 常见问题

### Q1: 为什么不直接操作用户态内存？

**原因**：

- 用户可能传递无效地址
- 可能访问内核内存（安全问题）
- 需要验证地址合法性

**后续改进**：

```rust
fn is_user_address(addr: usize, len: usize) -> bool {
    let end = addr + len;
    // 用户空间：0x0000_0000 - 0x3fff_ffff
    addr < 0x4000_0000 && end < 0x4000_0000
}
```

### Q2: 为什么read/write返回值是isize而不是usize？

**原因**：

- 需要返回-1表示错误
- isize可以是负数
- 兼容Unix系统调用约定

### Q3: vec![0u8; len]会不会分配失败？

**当前实现**：

- 会panic（不推荐）

**改进方式**：

```rust
let kernel_buf = match Vec::try_reserve(len) {
    Ok(_) => vec![0u8; len],
    Err(_) => return -1,  // 内存不足
};
```

---

## 下一步

在下一节（7.3.2）中，我们将实现sys_open系统调用，学习如何处理C字符串参数。

---

## 练习题

1. **实现地址验证**：添加`is_user_address()`函数，验证用户地址合法性
2. **实现部分写入**：当write只写入部分数据时，正确处理返回值
3. **实现错误码**：返回具体的错误码（如EBADF、EINVAL）而不是-1
