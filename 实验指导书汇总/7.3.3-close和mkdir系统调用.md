# 7.3.3 close和mkdir系统调用

## 本节目标

- 实现sys_close系统调用
- 实现sys_mkdir系统调用
- 理解文件描述符释放机制
- 理解目录创建流程

---

## 前置要求

- 已完成 7.3.1 节的 read/write 实现
- 已完成 7.3.2 节的 open 实现

---

## 步骤1：实现sys_close系统调用

### 1.1 为什么需要sys_close？

**设计意图**：`sys_close`负责释放文件描述符，这是资源管理的关键环节。打开文件后，如果不关闭，会导致FD泄漏，最终耗尽FD资源。

**典型场景**：
- **正常文件操作**：`fd = open("file.txt")` → `read(fd)` → `close(fd)` → 释放资源
- **异常处理**：打开失败后必须关闭已打开的FD，避免泄漏
- **长期运行程序**：服务器程序反复打开/关闭文件，必须正确释放FD

**为什么必须关闭文件？**

如果不关闭文件，会有严重后果：
```rust
// 错误：循环打开不关闭
for i in 0..1000 {
    let fd = open("file.txt", O_RDONLY);
    read(fd, buf, 100);
    // 忘记close(fd)！
}
// 结果：1000个FD被占用，新的open会失败（FD表满）

// ✓ 正确：及时关闭
for i in 0..1000 {
    let fd = open("file.txt", O_RDONLY);
    read(fd, buf, 100);
    close(fd);  // 释放FD，可以重复使用
}
```

**close的作用**：
1. **释放FD槽位**：将FD表的对应位置设为None，可重新分配
2. **减少引用计数**：Arc引用计数减1，可能触发文件对象释放
3. **刷新缓冲区**（完整实现）：确保数据写入磁盘
4. **释放内核资源**：关闭文件锁、释放内核缓冲区等

### 1.2 [任务] 实现sys_close（任务点11-1，2分）

现在请你实现 `sys_close` 系统调用！根据上面的算法讲解，完成关闭文件描述符的实现。

**文件位置**：`os/src/syscall/syscall_impl.rs`（约第264行）

**方法签名**：
```rust
pub fn sys_close(fd: usize) -> isize
```

**实现要求**：

1. **打印日志**：使用 `serial_println!` 输出 `fd` 参数
2. **调用dealloc释放FD**：调用 `FD_TABLE.lock().dealloc(fd)` 并获取返回值
3. **根据返回值决定系统调用结果**：
   - 如果 `dealloc` 返回 `true`：打印成功日志，返回 `0`
   - 如果 `dealloc` 返回 `false`：打印失败日志，返回 `-1`

**思考题**：

1. 为什么直接调用 `dealloc` 而不先用 `is_valid` 检查？提示：考虑原子性和性能。
2. 为什么不能关闭 FD 0/1/2？如果关闭会发生什么？
3. 当 `Arc` 引用计数降为0时会发生什么？这与文件关闭有何关系？

**代码框架**（参考syscall_impl.rs中的TODO注释）：

```rust
pub fn sys_close(fd: usize) -> isize {
    serial_println!("[SYSCALL] sys_close: fd={}", fd);

    // TODO: Task 11-1 - Implement sys_close (2 points)
    //
    // Step 1: 获取FD表
    // Hint: use crate::fs::fd_table::FD_TABLE;
    //
    // Step 2: 释放FD
    // Hint: if FD_TABLE.lock().dealloc(fd) {
    //     serial_println!("[SYSCALL] sys_close: success");
    //     0
    // } else {
    //     serial_println!("[SYSCALL] sys_close: invalid fd={}", fd);
    //     -1
    // }

    todo!("Implement sys_close - 任务点11-1")
}
```

**验证方法**：

完成后测试编译：
```bash
cd os
cargo check
```

参考初版指导书查看完整实现。

---

## 步骤2：sys_close设计要点

### 2.1 设计要点说明

1. **为什么直接调用`dealloc`而不先用`is_valid`检查？**
   - **简化设计**：`dealloc`内部已经包含了有效性检查（检查FD范围和是否存在）
   - **避免重复加锁**：`is_valid`和`dealloc`都需要锁，分开调用会产生两次锁操作
   - **原子性保证**：一次调用确保检查和释放是原子操作，避免竞态条件
   - `dealloc`的实现已经保证了：
     ```rust
     pub fn dealloc(&mut self, fd: FileDescriptor) -> bool {
         if fd >= 3 && fd < self.entries.len() {  // 检查范围
             if self.entries[fd].is_some() {       // 检查是否存在
                 self.entries[fd] = None;
                 return true;
             }
         }
         false  // FD无效或不存在
     }
     ```

2. **为什么`dealloc`返回bool？**
   - `true`：成功释放FD（FD有效且存在）
   - `false`：释放失败，可能是以下原因：
     - FD < 3（试图关闭标准流stdin/stdout/stderr）
     - FD >= entries.len()（超出范围）
     - entries[fd] == None（FD已经被释放或从未分配）
   - 调用者根据返回值决定系统调用的返回值（0或-1）

3. **为什么不能关闭FD 0/1/2？**
   - FD 0/1/2是标准流（stdin/stdout/stderr），进程启动时自动分配
   - 关闭标准流会导致程序无法正常输入输出
   - `dealloc`的`fd >= 3`检查防止了这种情况

### 2.2 算法流程

```
1. 调用dealloc释放FD
   FD_TABLE.dealloc(fd)
     ├─ 检查FD范围（fd >= 3 && fd < entries.len()）
     ├─ 检查FD是否存在（entries[fd].is_some()）
     ├─ 设置entries[fd] = None
     ├─ Arc引用计数自动减1（RAII）
     └─ 返回true/false

2. 根据dealloc结果返回
   true  -> 返回 0（成功）
   false -> 返回 -1（失败）
```

### 2.3 FD释放机制

**Arc引用计数**：

```rust
// 打开文件
let file = Arc::new(Mutex::new(ramfile));
FD_TABLE.lock().alloc(file);  // Arc计数 = 1

// 关闭文件
FD_TABLE.lock().dealloc(fd);  // Arc计数 = 0
// Arc计数为0时，RamFile自动释放
```

**多次打开同一文件**：

```rust
let file = Arc::new(Mutex::new(ramfile));

// 打开两次
let fd1 = FD_TABLE.lock().alloc(file.clone());  // 计数 = 1
let fd2 = FD_TABLE.lock().alloc(file.clone());  // 计数 = 2

// 关闭fd1
FD_TABLE.lock().dealloc(fd1);  // 计数 = 1, 文件仍存在

// 关闭fd2
FD_TABLE.lock().dealloc(fd2);  // 计数 = 0, 文件被释放
```

### 2.4 保护标准流

**不能关闭标准流**：

```rust
sys_close(0);  // stdin
sys_close(1);  // stdout
sys_close(2);  // stderr
```

**dealloc的检查**：

```rust
pub fn dealloc(&mut self, fd: FileDescriptor) -> bool {
    if fd >= 3 && fd < self.entries.len() {
        // 只能关闭FD >= 3的文件
        // ...
    }
    false
}
```

---

## 步骤3：实现sys_mkdir系统调用

### 3.1 为什么需要sys_mkdir？

**设计意图**：`sys_mkdir`用于创建新目录，这是组织文件系统层次结构的基础。没有mkdir，就无法创建子目录，文件系统只能是扁平的单层结构。

**典型场景**：
- **创建项目目录**：`mkdir("project")` → 创建项目根目录
- **组织文件层次**：`mkdir("logs")` → 创建日志存储目录
- **临时目录**：`mkdir("/tmp/session_123")` → 创建临时会话目录
- **用户目录**：`mkdir("/home/username")` → 为新用户创建主目录

**为什么需要目录？**

目录是文件系统组织的核心：
```rust
// 没有目录：所有文件在根目录（混乱）
/
├── config.ini
├── app.log
├── data1.txt
├── data2.txt
├── temp1.dat
├── temp2.dat
└── ...（1000+个文件）

// ✓ 有目录：层次清晰
/
├── config/
│   └── config.ini
├── logs/
│   └── app.log
├── data/
│   ├── data1.txt
│   └── data2.txt
└── tmp/
    ├── temp1.dat
    └── temp2.dat
```



那么在通过`mkdir`命令创建目录时**内核需要做什么？**

1. **解析路径**：将C字符串转换为Rust String
2. **检查重名**：确认同名目录不存在
3. **分配Inode**：为新目录分配Inode号
4. **创建目录Inode**：初始化权限为0o755（rwxr-xr-x）
5. **添加到父目录**：在父目录的entries中添加映射

### 3.2 [任务] 实现sys_mkdir（任务点11-2，4分）

现在请你实现 `sys_mkdir` 系统调用！这个系统调用用于创建新目录。

**文件位置**：`os/src/syscall/syscall_impl.rs`（约第296行）

**方法签名**：
```rust
pub fn sys_mkdir(path: usize) -> isize
```

**实现要求**：

1. **打印日志**：使用 `serial_println!` 输出 `path` 参数（地址）
2. **读取C字符串路径**：调用 `read_c_string(path)` 获取路径字符串，如果失败返回-1
3. **打印路径字符串**：输出解析后的路径字符串
4. **获取文件系统和根目录**：
   - 使用 `FS_MANAGER.lock()` 获取管理器
   - 调用 `manager.root()` 获取根目录
5. **创建目录**：调用 `FS_MANAGER.lock().ramfs().create_directory(root, path_str)`
6. **处理结果**：
   - 成功：打印成功日志，返回 `0`
   - 失败：打印错误信息，返回 `-1`

**思考题**：

1. 为什么mkdir不返回FD？目录和文件的用途有何区别？
2. 如果创建已存在的目录会发生什么？RamFS如何处理这种情况？
3. 为什么这里只支持在根目录下创建，不支持 `/home/user/docs` 这样的多级路径？

**代码框架**（参考syscall_impl.rs中的TODO注释）：

```rust
pub fn sys_mkdir(path: usize) -> isize {
    serial_println!("[SYSCALL] sys_mkdir: path=0x{:x}", path);

    // TODO: Task 11-2 - Implement sys_mkdir (4 points)
    //
    // Step 1: 读取C字符串路径（使用Task 10-1的函数）
    // Hint: let path_str = match read_c_string(path) {
    //     Some(s) => s,
    //     None => {
    //         serial_println!("[SYSCALL] sys_mkdir: invalid path pointer");
    //         return -1;
    //     }
    // };
    //
    // Step 2: 获取文件系统和根目录
    // Hint: use crate::fs::manager::FS_MANAGER;
    // Hint: let root = FS_MANAGER.lock().root();
    //
    // Step 3: 创建目录
    // Hint: match FS_MANAGER.lock().ramfs().create_directory(root, path_str) {
    //     Ok(_) => {
    //         serial_println!("[SYSCALL] sys_mkdir: success");
    //         0
    //     }
    //     Err(e) => {
    //         serial_println!("[SYSCALL] sys_mkdir: failed: {:?}", e);
    //         -1
    //     }
    // }

    todo!("Implement sys_mkdir - 任务点11-2")
}
```

**验证方法**：

完成后测试编译：
```bash
cd os
cargo check
```

参考初版指导书查看完整实现。

---

## 步骤4：sys_mkdir设计要点

### 4.1 设计要点说明

1. **为什么mkdir不返回FD？**
   - 目录不能像文件一样read/write，不需要FD
   - 目录的作用是存储文件列表，通过lookup访问
   - Unix约定：mkdir成功返回0，失败返回-1

2. **为什么用`RAMFS.create_directory`而不是`RAMFS.create_file`？**
   - 两者创建不同类型的Inode：
     - `create_file`：`FileType::RegularFile`，权限0o644
     - `create_directory`：`FileType::Directory`，权限0o755
   - 目录需要执行权限（x）才能进入（cd）

3. **为什么返回的Inode被忽略（`Ok(_)`）？**
   - mkdir只需要创建目录，不需要后续操作
   - 用户通过路径访问目录，不需要Inode引用
   - 与open不同：open返回FD用于后续read/write

4. **为什么只支持根目录下创建？**
   - 简化实现：避免复杂的路径解析
   - 完整实现需要：
     ```rust
     // 解析路径 /home/user/docs
     let root = RAMFS.root();
     let home = RAMFS.lookup(root, "home")?;
     let user = RAMFS.lookup(home, "user")?;
     RAMFS.create_directory(user, "docs")?;
     ```

5. **为什么`match`匹配错误后只打印日志？**
   - `create_directory`可能返回多种错误：
     - `AlreadyExists`：目录已存在
     - `NotDirectory`：父节点不是目录
   - 当前简化实现统一返回-1
   - 完整实现应该返回具体错误码（EEXIST、ENOTDIR等）

### 4.2 算法流程

```
1. 读取路径字符串
   read_c_string(path) -> String

2. 获取根目录
   RAMFS.root()

3. 创建目录
   RAMFS.create_directory(root, path_str)
     ├─ 分配inode号
     ├─ 创建RamInode::new_directory
     ├─ 添加到父目录entries
     └─ 返回inode

4. 返回结果
   成功: 0
   失败: -1
```

### 4.3 使用示例

**用户态C代码**：

```c
// 创建目录
mkdir("/home");

// 创建文件
int fd = open("/home/test.txt", O_CREAT | O_RDWR);
write(fd, "Hello", 5);
close(fd);
```

**内核态流程**：

```
mkdir("/home"):
  1. sys_mkdir
  2. read_c_string -> "home"
  3. create_directory
  4. return 0

open("/home/test.txt", ...):
  1. sys_open
  2. read_c_string -> "home/test.txt"
  3. 路径解析（简化版只在根目录）
  4. create_file
  5. return fd=3
```

---

## 步骤5：错误处理

### 5.1 常见错误情况

**文件已存在**：

```rust
mkdir("/home");  // 成功
mkdir("/home");  // 失败：AlreadyExists
```

**父目录不存在**：

```rust
mkdir("/a/b/c");  // 失败：父目录/a/b不存在
```

**权限不足**：

```rust
// 当前简化实现不检查权限
// 后续可添加权限检查
```

### 5.2 错误码映射

**当前实现**：

```rust
// 简单返回-1
Err(_) => return -1;
```

**改进版本**：

```rust
pub mod errno {
    pub const ENOENT: isize = -2;    // No such file or directory
    pub const EEXIST: isize = -17;   // File exists
    pub const ENOTDIR: isize = -20;  // Not a directory
    pub const EISDIR: isize = -21;   // Is a directory
}

// 映射FileError到errno
match error {
    FileError::NotFound => errno::ENOENT,
    FileError::AlreadyExists => errno::EEXIST,
    FileError::NotDirectory => errno::ENOTDIR,
    FileError::IsDirectory => errno::EISDIR,
    _ => -1,
}
```

---

## 知识点总结

### sys_close vs sys_open

| 操作 | sys_open | sys_close |
|------|----------|-----------|
| 作用 | 分配FD | 释放FD |
| 参数 | path, flags | fd |
| 返回值 | fd / -1 | 0 / -1 |
| Arc计数 | +1 | -1 |

### 文件生命周期

```
1. open -> 分配FD，Arc计数+1
   fd = open("file.txt", O_RDWR);

2. 使用 -> Arc计数不变
   read(fd, buf, 100);
   write(fd, buf, 100);

3. close -> 释放FD，Arc计数-1
   close(fd);

4. Arc计数为0 -> 自动释放RamFile
```

### 目录 vs 文件

| 特性 | 文件 | 目录 |
|------|------|------|
| 创建 | open(O_CREAT) | mkdir |
| 打开 | open | 不能open |
| 读写 | read/write | 不能read/write |
| 列表 | - | readdir（后续实现） |

---

## 常见问题

### Q1: 关闭FD后能否再次使用？

**不能**：

```c
int fd = open("file.txt", O_RDWR);
close(fd);
write(fd, "data", 4);  // 错误！FD已释放
```

**正确做法**：

```c
int fd = open("file.txt", O_RDWR);
write(fd, "data", 4);
close(fd);  // 使用完毕后关闭
```

### Q2: 为什么mkdir不返回FD？

**原因**：

- 目录不能像文件一样read/write
- 目录操作使用专门的系统调用（readdir/opendir）
- Unix设计：mkdir只创建，不打开

**对比**：

```c
// 创建文件并打开
int fd = open("file.txt", O_CREAT | O_RDWR);

// 创建目录（不打开）
mkdir("/home");
```

### Q3: 为什么不能关闭stdin/stdout/stderr？

**原因**：

- 标准流是进程的基础I/O
- 许多程序假设这些FD始终存在
- 关闭会导致程序无法正常输出

**保护机制**：

```rust
pub fn dealloc(&mut self, fd: FileDescriptor) -> bool {
    if fd >= 3 && fd < self.entries.len() {
        // 只能关闭FD >= 3
    }
    false
}
```

---

## 完整示例

### 文件操作流程

```c
// 1. 创建目录
mkdir("/mydir");

// 2. 创建文件
int fd = open("/mydir/test.txt", O_CREAT | O_RDWR);

// 3. 写入数据
write(fd, "Hello, World!", 13);

// 4. 移动到开头
lseek(fd, 0, SEEK_SET);

// 5. 读取数据
char buf[100];
int n = read(fd, buf, 100);

// 6. 关闭文件
close(fd);
```

**对应的系统调用**：

```
mkdir("/mydir")
  -> sys_mkdir(path_ptr)
  -> create_directory
  -> return 0

open(...)
  -> sys_open(path_ptr, flags)
  -> create_file
  -> alloc FD
  -> return 3

write(...)
  -> sys_write(3, buf_ptr, 13)
  -> file.write(buf)
  -> return 13

lseek(...)
  -> sys_lseek(3, 0, SEEK_SET)  // 下一章实现
  -> file.seek(Start(0))
  -> return 0

read(...)
  -> sys_read(3, buf_ptr, 100)
  -> file.read(buf)
  -> return 13

close(...)
  -> sys_close(3)
  -> dealloc FD
  -> return 0
```

---

## 下一步

在下一节（7.3.4）中，我们将更新系统调用分发器，集成所有文件系统系统调用。

---

## 练习题

1. **实现错误码**：添加errno映射，返回具体错误码而不是-1
2. **实现递归mkdir**：支持创建多级目录（如mkdir -p）
3. **实现FD统计**：添加函数统计当前打开的文件数量
