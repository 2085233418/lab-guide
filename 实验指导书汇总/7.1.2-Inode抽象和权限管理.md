# 7.1.2 Inode抽象和权限管理

## 本节目标

- 理解Inode的概念和作用
- 定义Inode trait接口
- 实现Unix风格的文件权限系统
- 实现MemInode内存索引节点

---

## 本节新增文件

```
os/src/fs/
└── inode.rs        # Inode抽象和权限管理
```

---

## 前置要求

- 已完成 7.1.1 节的 File trait 定义
- 理解 Trait Object 的概念

---

## 步骤1：理解Inode概念—— 文件系统的 "身份证"

在实现虚拟文件系统（VFS）前，我们需要先掌握 **Inode（索引节点）** 这一核心概念，它是 Unix/Linux 文件系统的基石。

### 1.1 什么是Inode？

**Inode 是文件的 "身份证"**，它唯一标识一个文件，并**存储文件的元数据**（描述文件属性的数据），但**不包含文件名和文件内容**。

### 元数据包含哪些信息？

| 元数据类型 | 具体内容                           |
| ---------- | ---------------------------------- |
| 基本属性   | 文件大小、创建 / 修改 / 访问时间   |
| 权限信息   | 所有者、所属组、读写执行权限       |
| 存储位置   | 文件数据在磁盘上的块地址           |
| 链接信息   | 硬链接数量（nlinks）               |
| 其他属性   | 文件类型（普通文件 / 目录 / 设备） |

### 直观类比：文件的 "身份证"

- **Inode** = 身份证：存储个人元数据（生日、性别、身份证号），唯一标识一个人。
- **文件名** = 人名：可以有多个（如小名、笔名），但都指向同一个身份证。
- **文件内容** = 人的具体行为 / 经历：不在身份证上，而是实际发生的内容。

### 1.2 为什么要分离文件名和Inode？

这是Unix系统设计的精妙之处。很多同学会疑惑：既然Inode已经标识了文件，为什么还需要单独的文件名？这种分离设计带来了三个重要好处：

#### 好处 1：支持硬链接（同一文件多个名字）

硬链接是**指向同一 Inode 的多个文件名**，就像一个人可以有多个名字，但身份证号唯一。

```plaintext
初始状态：创建文件 file1.txt
$ echo "hello" > file1.txt
此时：file1.txt → Inode 100（nlinks=1）

创建硬链接 file2.txt 指向 file1.txt
$ ln file1.txt file2.txt
此时：file1.txt → Inode 100（nlinks=2）
     file2.txt → Inode 100（nlinks=2）

修改 file1.txt 的内容
$ echo "world" >> file1.txt
此时：file2.txt 的内容也会同步变化（因为指向同一个 Inode）

删除 file1.txt
$ rm file1.txt
此时：file2.txt → Inode 100（nlinks=1）
     （Inode 不会被删除，因为还有一个链接指向它）

删除 file2.txt
$ rm file2.txt
此时：Inode 100 的 nlinks=0
     （系统会回收 Inode 和对应的数据块）
```

**核心逻辑**：Inode 的生命周期由**硬链接数（nlinks）** 决定，只有当 `nlinks=0` 且没有进程打开该文件时，系统才会删除 Inode 和数据。

#### 好处 2：灵活的目录结构

目录本质上是**文件名到 Inode 号的映射表**（类似字典：`{"文件名": Inode号}`）。这种设计让目录结构非常灵活：

```
目录的内部结构（简化版）：
/home/user/
  ├─ "docs"      → Inode 50 (目录)
  ├─ "photo.jpg" → Inode 100
  └─ "backup"    → Inode 100  (硬链接，指向同一个文件)
```

- 可以在不同目录下用不同文件名指向同一个文件（硬链接）。
- 目录本身也是一个文件，有自己的 Inode（存储目录项的元数据）。

#### 好处 3：高效的文件系统操作

- **查找文件**：先通过目录找到 Inode 号，再通过 Inode 获取文件数据位置，避免全量扫描。
- **修改文件名**：只需修改目录项的映射，无需修改 Inode（类似改名字只需更新户口本，无需换身份证）。
- **移动文件**：只需修改目标目录的映射表，不需要拷贝数据。

**示例：重命名的高效性**

```bash
# 重命名大文件（1GB）几乎是瞬间完成的
$ mv large_file.bin new_name.bin

# 原因：只修改目录项的映射
目录项变化：
  "large_file.bin" → Inode 200  (删除这个映射)
  "new_name.bin"   → Inode 200  (添加这个映射)
# Inode 200 本身和文件数据都不需要改动
```

### 1.3 File vs Inode 的关系

很多同学会混淆这两个概念。用一个直观的比喻来解释：**"多人共读一本书"**

```
Inode (书本身)
  ↓
  ├─ File1（读者A打开，书签在第0页）
  ├─ File2（读者B打开，书签在第100页）
  └─ File3（读者C打开，书签在第50页）
```

**关键区别**：
- **Inode**：文件本身的元数据（书的信息：页数、作者、ISBN）
- **File**：打开文件的一个句柄（书签：记录当前读到哪一页）
- 一个文件可以被多次打开（多个书签）
- 每次打开有独立的读写位置（offset），但共享同一个Inode

**代码示例**：

```rust
// Inode：书本身
let inode = ramfs.create_file(root, "book.txt")?;

// File1：读者A打开，从头开始读
let mut file1 = File::open(inode.clone())?;
file1.read(&mut buf)?;  // 读取后 offset=N

// File2：读者B打开，也是从头开始读（独立的offset）
let mut file2 = File::open(inode.clone())?;
file2.read(&mut buf)?;  // 读取后 offset=N (与file1的offset独立)
```

### 1.4 Inode 在 VFS 中的作用

在虚拟文件系统（VFS）中，Inode 是**统一不同文件系统的关键抽象**：

```
VFS Inode接口
    ↓
    ├─ EXT4 Inode实现
    ├─ FAT32 Inode实现
    └─ RamFS Inode实现
```

- 无论底层是 EXT4、FAT32 还是 RamFS，都通过 VFS 的 Inode 接口暴露元数据。
- VFS Inode 定义了统一的方法（如获取大小、修改权限），屏蔽了不同文件系统的实现差异。
- 这样上层代码（如系统调用）不需要关心底层文件系统的具体实现。

---

## 步骤2：定义Inode trait

现在我们理解了Inode的概念，接下来定义VFS层的Inode trait接口。

### 2.1 为什么需要trait？

在Rust中，trait是定义接口的方式。我们需要trait来实现**多态**：

```
不同的文件系统有不同的Inode实现，但都遵循同一个接口：

RamInode  ┐
DiskInode ├─ 都实现 → Inode trait
NetInode  ┘
```

这样VFS层的代码可以统一处理不同类型的Inode，而不需要知道具体是哪种实现。

### 2.2 创建inode.rs并定义Inode trait

创建 `os/src/fs/inode.rs`：

**文件路径：`os/src/fs/inode.rs`**

```rust
//! Inode抽象
//!
//! Inode存储文件元数据（不包含文件名和数据）

use super::file::{FileType, FileMetadata};
use alloc::sync::Arc;
use spin::Mutex;

/// Inode trait - 文件元数据抽象
///
/// 这是VFS层的核心接口，所有文件系统的Inode都必须实现这个trait
pub trait Inode: Send + Sync {
    /// 返回Inode编号（全局唯一标识）
    fn ino(&self) -> usize;

    /// 返回文件类型（普通文件、目录、设备等）
    fn file_type(&self) -> FileType;

    /// 返回文件大小（字节数）
    fn size(&self) -> usize;

    /// 返回权限位（Unix风格的rwx权限）
    fn mode(&self) -> u32;
}
```

**设计要点逐一解释**：

1. **为什么需要 `Send + Sync`？**

   ```rust
   pub trait Inode: Send + Sync {
   ```

   - `Send`：表示可以在线程间安全传递所有权
   - `Sync`：表示可以在多线程间安全共享引用
   - 文件系统需要支持多线程访问，所以必须是线程安全的

   **实际场景**：
   ```rust
   // 线程1读取文件
   thread1: read(fd, buf1)

   // 线程2同时写入同一个文件
   thread2: write(fd, buf2)

   // 两个线程访问同一个Inode，需要Send + Sync保证安全
   ```

2. **为什么返回 `usize` 类型的Inode号？**

   ```rust
   fn ino(&self) -> usize;
   ```

   - `usize`是平台相关的无符号整数（32位系统4字节，64位系统8字节）
   - Inode号只需要是正整数，不需要负数
   - `usize`是Rust中索引和计数的标准类型，与数组索引类型匹配

3. **为什么需要 `file_type()` 方法？**

   ```rust
   fn file_type(&self) -> FileType;
   ```

   - 操作系统需要区分不同类型的文件（普通文件、目录、设备等）
   - 不同类型的文件有不同的操作限制：
     - 普通文件：可以read/write
     - 目录：只能列出内容，不能read/write
     - 设备文件：读写会触发设备驱动

   **错误示例**：
   ```rust
   let dir_inode = ramfs.lookup(root, "mydir")?;
   // 试图读取目录会报错
   file.read(&mut buf)?;  // Error: IsDirectory
   ```

4. **为什么需要 `mode()` 返回权限位？**

   ```rust
   fn mode(&self) -> u32;
   ```

   - Unix系统通过权限位控制文件访问
   - 在执行read/write前需要检查权限
   - `u32`足够存储所有权限信息（实际只用低12位）

### 2.3 定义InodeHandle类型

**文件路径：`os/src/fs/inode.rs`**

```rust
/// Inode句柄类型
///
/// Arc<Mutex<dyn Inode>> 提供了三个关键特性：
/// - Arc: 多个引用间的共享所有权（引用计数）
/// - Mutex: 线程安全的可变访问（互斥锁）
/// - dyn Inode: 动态分发，支持不同的Inode实现
pub type InodeHandle = Arc<Mutex<dyn Inode>>;
```

**为什么这么复杂？让我们一层层拆解**：

#### 第一层：`dyn Inode` - 为什么需要动态分发？

```rust
// 问题：我们需要在同一个数据结构中存储不同类型的Inode
struct FileSystem {
    // 错误！不同类型的Inode大小不同，无法这样存储
    // inodes: Vec<impl Inode>,  // 编译错误

    // 正确：使用trait object实现动态多态
    inodes: Vec<Arc<Mutex<dyn Inode>>>,  // 可以存储任何实现Inode的类型
}
```

**实际使用场景**：
```rust
// 不同类型的Inode都能存入同一个vector
let mut inodes = Vec::new();
inodes.push(Arc::new(Mutex::new(RamInode::new_file(1))));
inodes.push(Arc::new(Mutex::new(DeviceInode::new(2))));
inodes.push(Arc::new(Mutex::new(NetworkInode::new(3))));
```

#### 第二层：`Mutex<dyn Inode>` - 为什么需要互斥锁？

```rust
// 问题：多线程同时访问文件
let inode = /* 某个文件的Inode */;

// 线程1修改文件大小
thread1: inode.set_size(100);

// 线程2同时读取文件大小
thread2: let size = inode.size();

// 没有Mutex会导致数据竞争！
// Mutex保证同一时刻只有一个线程能访问Inode
```

**Mutex的工作方式**：
```rust
let inode: Arc<Mutex<dyn Inode>> = /* ... */;

// 获取锁才能访问
let mut guard = inode.lock();  // 如果其他线程持有锁，这里会阻塞等待
guard.set_size(100);           // 修改数据
drop(guard);                   // 释放锁，其他线程可以访问了
```

#### 第三层：`Arc<Mutex<dyn Inode>>` - 为什么需要引用计数？

```rust
// 问题：多个地方需要引用同一个Inode
let inode = Arc::new(Mutex::new(RamInode::new_file(1)));

// FD表引用这个Inode
fd_table[3] = Some(inode.clone());  // 引用计数: 1 -> 2

// 目录也引用这个Inode
dir.add_entry("file.txt", inode.clone());  // 引用计数: 2 -> 3

// 关闭文件描述符
fd_table[3] = None;  // 引用计数: 3 -> 2，Inode不会被释放

// 只有当所有引用都消失，Inode才会被自动释放
```

**Arc vs Box 的选择**：
```rust
// Box: 只能有一个所有者
let inode = Box::new(Mutex::new(RamInode::new_file(1)));
// 无法 clone，只能 move

// Arc: 可以有多个所有者（引用计数）
let inode = Arc::new(Mutex::new(RamInode::new_file(1)));
let inode2 = inode.clone();  // OK，引用计数+1
```

**完整的使用示例**：

```rust
// 创建Inode
let inode: Arc<Mutex<dyn Inode>> =
    Arc::new(Mutex::new(RamInode::new_file(1)));

// 多个地方共享这个Inode
let fd_entry = inode.clone();    // 引用计数 = 2
let dir_entry = inode.clone();   // 引用计数 = 3

// 访问Inode（需要加锁）
{
    let guard = inode.lock();     // 获取锁
    let size = guard.size();      // 读取数据
}  // guard自动释放锁

// 修改Inode
{
    let mut guard = inode.lock(); // 获取可变锁
    guard.set_size(100);          // 修改数据
}  // guard自动释放锁
```

---

## 步骤3：实现 Unix 文件权限

Unix权限系统是一个精妙的设计，通过9个二进制位就能控制文件的访问权限。让我们深入理解这个系统。

### 3.1 为什么需要权限系统？

**安全性需求**：
```
场景1：多用户系统
- 用户A的文件不能被用户B随意修改
- 系统文件不能被普通用户删除

场景2：防止误操作
- 重要配置文件设置为只读，防止意外修改
- 可执行文件不能被修改，防止注入恶意代码
```

### 3.2 Unix权限的9位设计

Unix权限通过**9 个二进制位**控制，分为三组（每组3位）：

```
用户(owner)  组(group)  其他(others)
  rwx         rwx         rwx
  421         421         421
```

每组的3位分别代表：
- `r` (read, 4)：读权限
- `w` (write, 2)：写权限
- `x` (execute, 1)：执行权限

### 步骤3.3: 定义Unix权限位常量（Tasks 2-1至2-3）

> **重要说明**：以下代码已在实验框架中完整实现。学生需要**跟着学习理解**这些代码，但不需要自己填写。这部分内容不计分（0分）。

**完整代码**：`os/src/fs/inode.rs` 中的 `permissions` 模块

```rust
/// Unix文件权限位（八进制表示）
///
/// Unix权限系统的核心是这9个位的组合
pub mod permissions {
    // Task 2-1: 用户（文件所有者）权限位
    pub const S_IRUSR: u32 = 0o400;  // 用户读（r） = 100_000_000 (二进制)
    pub const S_IWUSR: u32 = 0o200;  // 用户写（w） = 010_000_000
    pub const S_IXUSR: u32 = 0o100;  // 用户执行（x）= 001_000_000

    // Task 2-2: 组（文件所属组）权限位
    pub const S_IRGRP: u32 = 0o040;  // 组读
    pub const S_IWGRP: u32 = 0o020;  // 组写
    pub const S_IXGRP: u32 = 0o010;  // 组执行

    // Task 2-3: 其他用户权限位
    pub const S_IROTH: u32 = 0o004;  // 其他读
    pub const S_IWOTH: u32 = 0o002;  // 其他写
    pub const S_IXOTH: u32 = 0o001;  // 其他执行

    // 默认权限：普通文件0o644，目录0o755
    pub const S_DEFAULT_FILE: u32 = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;  // 0o644
    pub const S_DEFAULT_DIR: u32 = 0o755;  // rwxr-xr-x
}
```

**代码讲解**：

1. **权限位的三层结构**（Tasks 2-1, 2-2, 2-3）：
   ```
   用户权限    组权限      其他权限
   rwx         rwx         rwx
   421         421         421
   0o400       0o040       0o004   (读权限示例)
   0o200       0o020       0o002   (写权限示例)
   0o100       0o010       0o001   (执行权限示例)
   ```

2. **为什么使用八进制表示？**
   - 每个八进制数字正好对应3个二进制位（rwx）
   - 例如：`0o7 = 0b111 = rwx`（读+写+执行）
   - 直观易读：看到`0o644`就知道是`rw-r--r--`

3. **权限值的计算方法**：
   ```rust
   // 用户权限占最高3位（bit 8-6）
   S_IRUSR = 0o400 = 0b100_000_000  // 第8位为1
   S_IWUSR = 0o200 = 0b010_000_000  // 第7位为1
   S_IXUSR = 0o100 = 0b001_000_000  // 第6位为1

   // 组权限占中间3位（bit 5-3）
   S_IRGRP = 0o040 = 0b000_100_000  // 第5位为1
   S_IWGRP = 0o020 = 0b000_010_000  // 第4位为1
   S_IXGRP = 0o010 = 0b000_001_000  // 第3位为1

   // 其他权限占最低3位（bit 2-0）
   S_IROTH = 0o004 = 0b000_000_100  // 第2位为1
   S_IWOTH = 0o002 = 0b000_000_010  // 第1位为1
   S_IXOTH = 0o001 = 0b000_000_001  // 第0位为1
   ```

4. **默认权限的组合**：
   ```rust
   // S_DEFAULT_FILE = 0o644
   // = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH
   // = 0o400   | 0o200   | 0o040   | 0o004
   // = 110_100_100 (二进制)
   // = rw-r--r-- (权限字符串)
   ```

5. **实际应用场景**：
   ```rust
   // 创建普通文件
   let inode = MemInode::new_file(1);
   // 自动使用S_DEFAULT_FILE (0o644)

   // 创建目录
   let dir = MemInode::new_directory(2);
   // 自动使用S_DEFAULT_DIR (0o755)

   // 检查权限
   if (inode.mode() & permissions::S_IRUSR) != 0 {
       // 用户有读权限
   }
   ```

### 3.3 权限值的含义详解

#### 为什么用八进制（0o）表示？

八进制每位正好对应3个二进制位（rwx），非常直观：

```
八进制 7 = 二进制 111 = rwx (读+写+执行)
八进制 6 = 二进制 110 = rw- (读+写)
八进制 5 = 二进制 101 = r-x (读+执行)
八进制 4 = 二进制 100 = r-- (只读)
```

#### 常见权限值速查表

| 八进制 | 二进制      | 权限字符串 | 含义               | 典型用途                |
| ------ | ----------- | ---------- | ------------------ | ----------------------- |
| 0o644  | 110 100 100 | rw-r--r--  | 所有者可改，他人只读 | 普通文档、配置文件      |
| 0o755  | 111 101 101 | rwxr-xr-x  | 所有者全权，他人可读执行 | 目录、可执行程序        |
| 0o666  | 110 110 110 | rw-rw-rw-  | 所有人可读写       | 共享的临时文件          |
| 0o777  | 111 111 111 | rwxrwxrwx  | 所有人全权限       | 测试环境（不安全！）    |
| 0o600  | 110 000 000 | rw-------  | 只有所有者可访问   | 私钥文件、密码文件      |

#### 为什么默认文件是0o644？

```rust
pub const S_DEFAULT_FILE: u32 = 0o644;  // rw-r--r--
```

**安全性考虑**：
- 所有者：rw (可读可写) - 创建文件的人可以修改
- 组：r (只读) - 同组的人可以查看，但不能修改
- 其他：r (只读) - 其他人可以查看，但不能修改

**为什么不给执行权限？**
- 普通文件（文本、数据）不应该被执行
- 执行权限需要显式授予（chmod +x）
- 防止恶意代码被意外执行

#### 为什么默认目录是0o755？

```rust
pub const S_DEFAULT_DIR: u32 = 0o755;  // rwxr-xr-x
```

**目录的特殊性**：
- `x` (执行权限) 对目录的含义是"可以进入（cd）该目录"
- 如果目录没有 `x` 权限，即使有 `r` 权限也无法列出内容
- 目录需要 `x` 权限才能访问其中的文件

**为什么组和其他用户有rx？**
```bash
# 没有x权限的后果
$ chmod 644 mydir  # rw-r--r--
$ ls mydir
ls: cannot access 'mydir': Permission denied

# 正确的目录权限
$ chmod 755 mydir  # rwxr-xr-x
$ ls mydir         # OK，可以列出内容
```

### 3.4 权限位运算（按位操作）

权限检查和设置都是通过位运算实现的。

#### 检查权限（按位与 `&`）

```rust
// 假设文件权限为 mode = 0o644 = 110_100_100
let mode = 0o644;

// 检查用户是否有读权限
// 0o644 & 0o400 = 110_100_100 & 100_000_000 = 100_000_000 (非0)
if (mode & permissions::S_IRUSR) != 0 {
    println!("用户有读权限");  // 会输出
}

// 检查用户是否有执行权限
// 0o644 & 0o100 = 110_100_100 & 001_000_000 = 000_000_000 (为0)
if (mode & permissions::S_IXUSR) != 0 {
    println!("用户有执行权限");  // 不会输出
}

// 检查其他用户是否有写权限
// 0o644 & 0o002 = 110_100_100 & 000_000_010 = 000_000_000 (为0)
if (mode & permissions::S_IWOTH) != 0 {
    println!("其他用户有写权限");  // 不会输出
}
```

**为什么用按位与检查权限？**

```
权限检查的本质是判断某个特定位是否为1：

mode:        110_100_100  (0o644)
检查位:      100_000_000  (S_IRUSR = 0o400)
按位与结果:  100_000_000  (非0，说明该位为1，有权限)

mode:        110_100_100  (0o644)
检查位:      000_000_010  (S_IWOTH = 0o002)
按位与结果:  000_000_000  (为0，说明该位为0，无权限)
```

#### 设置权限（按位或 `|`）

```rust
// 组合多个权限位生成完整权限
// 需求：创建一个文件，所有者可读写，组可读，其他人可读
let mode = permissions::S_IRUSR   // 100_000_000 (用户读)
         | permissions::S_IWUSR   // 010_000_000 (用户写)
         | permissions::S_IRGRP   // 000_100_000 (组读)
         | permissions::S_IROTH;  // 000_000_100 (其他读)
// 结果: 110_100_100 = 0o644

assert_eq!(mode, 0o644);
```

**为什么用按位或设置权限？**

```
按位或会把所有为1的位保留下来：

S_IRUSR:  100_000_000
S_IWUSR:  010_000_000
S_IRGRP:  000_100_000
S_IROTH:  000_000_100
------------------------
按位或:   110_100_100  (0o644)
```

#### 实际应用示例

```rust
// 示例1：检查文件是否可读可写
fn can_read_write(mode: u32) -> bool {
    let readable = (mode & permissions::S_IRUSR) != 0;
    let writable = (mode & permissions::S_IWUSR) != 0;
    readable && writable
}

// 示例2：添加执行权限
fn add_execute_permission(mode: u32) -> u32 {
    mode | permissions::S_IXUSR  // 添加用户执行权限
}

// 示例3：移除写权限
fn remove_write_permission(mode: u32) -> u32 {
    mode & !permissions::S_IWUSR  // 清除用户写权限
    // ! 是按位取反，!0o200 = 111_011_111
    // mode & 111_011_111 会把写权限位清零
}

// 使用示例
let mode = 0o644;  // rw-r--r--
println!("可读写: {}", can_read_write(mode));  // true

let mode_with_exec = add_execute_permission(mode);
// 0o644 | 0o100 = 110_100_100 | 001_000_000 = 111_100_100 = 0o744

let read_only = remove_write_permission(mode);
// 0o644 & !0o200 = 110_100_100 & 101_111_111 = 100_100_100 = 0o444
```

---

## 步骤4：实现MemInode结构

现在我们要创建一个具体的Inode实现：`MemInode`（内存中的Inode）。

### 4.1 为什么需要MemInode？

**Inode trait vs MemInode**：
- `Inode` trait：接口定义（说明Inode应该有哪些方法）
- `MemInode`：具体实现（真正的数据结构，存储Inode的数据）

```rust
// Inode trait：接口（抽象）
trait Inode {
    fn size(&self) -> usize;  // 只定义方法签名
}

// MemInode：实现（具体）
struct MemInode {
    size: usize,  // 实际存储数据
}

impl Inode for MemInode {
    fn size(&self) -> usize {
        self.size  // 实现具体逻辑
    }
}
```

### 4.2 MemInode结构定义

**文件路径：`os/src/fs/inode.rs`**

```rust
/// 内存中的Inode结构
///
/// 这是RamFS使用的Inode实现，所有数据都存储在内存中
#[derive(Clone)]
pub struct MemInode {
    ino: usize,           // Inode编号（全局唯一标识）
    file_type: FileType,  // 文件类型（普通文件、目录、设备等）
    mode: u32,            // 权限位（Unix风格的rwx权限）
    size: usize,          // 文件大小（字节数）
    created: u64,         // 创建时间戳
    modified: u64,        // 修改时间戳
    nlinks: usize,        // 硬链接计数（有多少个名字指向这个Inode）
}
```

**字段详解**：

1. **`ino: usize` - 为什么需要Inode编号？**

   ```rust
   // Inode编号是文件的全局唯一标识
   let inode1 = MemInode { ino: 100, /* ... */ };
   let inode2 = MemInode { ino: 100, /* ... */ };  // 错误！编号不能重复

   // 用途：快速判断两个文件是否相同
   if file1.ino() == file2.ino() {
       println!("这是同一个文件");
   }
   ```

2. **`file_type: FileType` - 为什么需要区分文件类型？**

   ```rust
   // 不同类型的文件有不同的操作限制
   match inode.file_type {
       FileType::RegularFile => {
           // 普通文件可以read/write
           file.read(&mut buf)?;
       }
       FileType::Directory => {
           // 目录不能read/write，只能列出内容
           // file.read(&mut buf)?;  // 错误！
           dir.list_entries()?;      // OK
       }
       FileType::Device => {
           // 设备文件的读写会触发驱动程序
           device.read(&mut buf)?;   // 触发设备驱动
       }
   }
   ```

3. **`mode: u32` - 为什么用u32存储权限？**

   ```rust
   // 实际只使用低9位（rwx * 3组）
   // 但用u32有几个好处：
   // 1. 对齐友好（现代CPU处理32位数更高效）
   // 2. 兼容Unix系统（Unix用16位mode，我们用32位更宽裕）
   // 3. 预留扩展空间（未来可能添加更多标志位）

   // 权限位布局（低12位）：
   // [11:9] 特殊权限位（setuid/setgid/sticky，暂未使用）
   // [8:6]  用户权限（rwx）
   // [5:3]  组权限（rwx）
   // [2:0]  其他权限（rwx）
   mode: 0o644,  // = 000_110_100_100
   ```

4. **`size: usize` - 为什么用usize？**

   ```rust
   // usize是平台相关的：
   // - 32位系统：最大4GB
   // - 64位系统：最大超大（理论上18EB）

   // 与Vec<u8>的len()类型匹配
   let data: Vec<u8> = vec![1, 2, 3];
   let size: usize = data.len();  // 类型一致，避免转换
   ```

5. **`created/modified: u64` - 为什么用u64存储时间？**

   ```rust
   // Unix时间戳（秒数）从1970年开始计算
   // u32最大值：约4.2billion秒 = 2038年（2038年问题！）
   // u64最大值：约5840亿年（宇宙都熄灭了还没溢出）

   // 简化的时间戳（实际应该用正确的时间获取函数）
   created: 0,
   modified: 0,  // 每次修改时递增
   ```

6. **`nlinks: usize` - 硬链接计数的作用**

   ```rust
   // nlinks记录有多少个名字指向这个Inode
   // 场景演示：
   
   // 初始：创建文件
   let inode = MemInode { nlinks: 1, /* ... */ };  // 一个名字
   
   // 创建硬链接
   ln file1.txt file2.txt
   // nlinks: 1 -> 2（两个名字指向同一个Inode）
   
   // 删除file1.txt
   rm file1.txt
   // nlinks: 2 -> 1（还有file2.txt，不能删除Inode）
   
   // 删除file2.txt
   rm file2.txt
   // nlinks: 1 -> 0（没有名字指向了，可以删除Inode）
   if inode.nlinks == 0 {
       // 释放Inode和数据
   }
   ```

### 4.3 为什么需要 `#[derive(Clone)]`？

```rust
#[derive(Clone)]
pub struct MemInode {
    // ...
}
```

**实际使用场景**：

```rust
// 场景：需要复制Inode信息
let inode = MemInode::new_file(1);

// 克隆Inode（创建副本）
let inode_copy = inode.clone();

// 两个Inode有相同的内容，但是独立的实例
inode_copy.size = 100;
// inode的size不会变化
```

**什么时候需要克隆？**
- 缓存Inode信息
- 快照文件状态
- 复制元数据到其他地方

**注意**：通常我们不需要克隆Inode，而是通过`Arc`共享引用。`Clone`主要用于特殊情况。

### 4.4 构造函数

**文件路径：`os/src/fs/inode.rs`**

```rust
impl MemInode {
    /// 通用构造函数
    ///
    /// 参数：
    /// - ino: Inode编号（必须唯一）
    /// - file_type: 文件类型
    /// - mode: 权限位
    pub fn new(ino: usize, file_type: FileType, mode: u32) -> Self {
        MemInode {
            ino,
            file_type,
            mode,
            size: 0,        // 新创建的文件大小为0
            created: 0,     // TODO: 应该使用实际时间戳
            modified: 0,
            nlinks: 1,      // 初始硬链接数为1（只有一个名字）
        }
    }

    /// 创建普通文件的Inode
    ///
    /// 使用默认的文件权限：0o644 (rw-r--r--)
    pub fn new_file(ino: usize) -> Self {
        MemInode::new(ino, FileType::RegularFile, permissions::S_DEFAULT_FILE)
    }

    /// 创建目录的Inode
    ///
    /// 使用默认的目录权限：0o755 (rwxr-xr-x)
    pub fn new_directory(ino: usize) -> Self {
        MemInode::new(ino, FileType::Directory, permissions::S_DEFAULT_DIR)
    }
}
```

**为什么提供便捷函数？**

```rust
// 方式1：使用通用构造函数（繁琐）
let file_inode = MemInode::new(
    1,
    FileType::RegularFile,
    permissions::S_IRUSR | permissions::S_IWUSR |
    permissions::S_IRGRP | permissions::S_IROTH
);

// 方式2：使用便捷函数（简洁）
let file_inode = MemInode::new_file(1);

// 效果完全相同，但方式2更易读，不容易出错
```

**默认值的设计理由**：

1. **`size = 0`**：新文件当然是空的
2. **`created/modified = 0`**：简化实现（实际应该用真实时间戳）
3. **`nlinks = 1`**：新创建的文件有且仅有一个名字指向它

---

## 步骤5：实现MemInode方法

现在为MemInode添加操作方法。

### 5.1 大小和时间管理

**文件路径：`os/src/fs/inode.rs`**

```rust
impl MemInode {
    /// 设置文件大小
    ///
    /// 自动更新修改时间戳
    pub fn set_size(&mut self, size: usize) {
        self.size = size;
        self.touch();  // 修改文件大小算作修改操作
    }

    /// 更新修改时间戳
    ///
    /// 此处为了简化实现我们用递增计数器模拟时间戳
    /// 实际应该：获取系统当前时间
    fn touch(&mut self) {
        // self.modified = get_current_timestamp();
        self.modified += 1;  // 简化：每次修改递增
    }
}
```

**为什么需要 `touch()` 方法？**

```rust
// Unix系统中，以下操作会更新mtime（修改时间）：
file.write(data);       // 写入数据
file.truncate(0);       // 截断文件
file.set_size(100);     // 修改大小

// touch()确保所有修改操作都更新时间戳
```

**为什么 `touch()` 是私有的？**

```rust
fn touch(&mut self)  // 没有pub，只能在MemInode内部调用
```

- `touch()`是内部实现细节，外部不应该直接调用
- 修改时间应该自动更新，而不是手动调用
- 这是**封装**的体现

### 5.2 硬链接管理

**文件路径：`os/src/fs/inode.rs`**

```rust
impl MemInode {
    /// 增加硬链接计数
    ///
    /// 使用场景：创建硬链接时调用
    pub fn inc_nlinks(&mut self) {
        self.nlinks += 1;
    }

    /// 减少硬链接计数
    ///
    /// 使用场景：删除硬链接时调用
    /// 注意：不会让nlinks变成负数
    pub fn dec_nlinks(&mut self) {
        if self.nlinks > 0 {
            self.nlinks -= 1;
        }
    }

    /// 获取当前硬链接计数
    pub fn nlinks(&self) -> usize {
        self.nlinks
    }

    /// 判断Inode是否可以删除
    ///
    /// 规则：nlinks=0 且没有进程打开文件时才能删除
    /// 简化实现：只检查nlinks
    pub fn can_delete(&self) -> bool {
        self.nlinks == 0
    }
}
```

**完整的硬链接生命周期**：

```rust
// 创建文件
let mut inode = MemInode::new_file(1);
assert_eq!(inode.nlinks(), 1);  // 初始计数为1

// 创建硬链接 ln file1.txt file2.txt
inode.inc_nlinks();
assert_eq!(inode.nlinks(), 2);

// 删除file1.txt
inode.dec_nlinks();
assert_eq!(inode.nlinks(), 1);
assert!(!inode.can_delete());  // 还不能删除

// 删除file2.txt
inode.dec_nlinks();
assert_eq!(inode.nlinks(), 0);
assert!(inode.can_delete());   // 现在可以删除了
```

**为什么需要防止nlinks变负？**

```rust
pub fn dec_nlinks(&mut self) {
    if self.nlinks > 0 {  // 检查边界
        self.nlinks -= 1;
    }
}

// 如果没有这个检查：
// nlinks = 0
// dec_nlinks() -> nlinks变成usize::MAX（溢出！）
```

### 5.3 元数据转换

**文件路径：`os/src/fs/inode.rs`**

```rust
impl MemInode {
    /// 将Inode转换为FileMetadata
    ///
    /// FileMetadata是一个简化的元数据结构，
    /// 用于系统调用返回文件信息（如stat系统调用）
    pub fn to_metadata(&self) -> FileMetadata {
        FileMetadata {
            file_type: self.file_type,
            size: self.size,
            mode: self.mode,
            created: self.created,
            modified: self.modified,
        }
    }
}
```

**为什么需要转换？**

```rust
// 系统调用stat返回文件信息
fn sys_stat(path: &str) -> FileMetadata {
    let inode = lookup_inode(path)?;

    // 不能直接返回Inode（可能包含内部实现细节）
    // 需要转换为公开的元数据结构
    inode.to_metadata()
}

// 用户程序获取文件信息
let metadata = stat("/etc/passwd");
println!("文件大小: {} 字节", metadata.size);
println!("权限: {:o}", metadata.mode);  // 打印八进制
```

### 5.4 权限检查

**文件路径：`os/src/fs/inode.rs`**

```rust
impl MemInode {
    /// 检查是否有读权限
    ///
    /// 检查用户（owner）的读权限位
    pub fn is_readable(&self) -> bool {
        (self.mode & permissions::S_IRUSR) != 0
    }

    /// 检查是否有写权限
    ///
    /// 检查用户（owner）的写权限位
    pub fn is_writable(&self) -> bool {
        (self.mode & permissions::S_IWUSR) != 0
    }

    /// 检查是否有执行权限
    ///
    /// 检查用户（owner）的执行权限位
    pub fn is_executable(&self) -> bool {
        (self.mode & permissions::S_IXUSR) != 0
    }
}
```

**实际应用场景**：

```rust
// 读取文件前检查权限
fn read_file(inode: &MemInode, buf: &mut [u8]) -> Result<usize, FileError> {
    // 权限检查
    if !inode.is_readable() {
        return Err(FileError::PermissionDenied);
    }

    // 执行读取
    // ...
}

// 写入文件前检查权限
fn write_file(inode: &MemInode, buf: &[u8]) -> Result<usize, FileError> {
    // 权限检查
    if !inode.is_writable() {
        return Err(FileError::PermissionDenied);
    }

    // 执行写入
    // ...
}

// 执行程序前检查权限
fn exec_file(inode: &MemInode) -> Result<(), FileError> {
    // 权限检查
    if !inode.is_executable() {
        return Err(FileError::PermissionDenied);
    }

    // 加载并执行程序
    // ...
}
```

**为什么只检查用户权限？**

```rust
// 当前简化实现：只检查用户（owner）权限
(self.mode & permissions::S_IRUSR) != 0

// 完整实现应该：根据当前进程的uid/gid决定检查哪组权限
fn is_readable(&self, uid: usize, gid: usize) -> bool {
    if uid == self.owner_uid {
        // 检查用户权限
        (self.mode & permissions::S_IRUSR) != 0
    } else if gid == self.owner_gid {
        // 检查组权限
        (self.mode & permissions::S_IRGRP) != 0
    } else {
        // 检查其他权限
        (self.mode & permissions::S_IROTH) != 0
    }
}
```

---

## 步骤6：实现Inode trait

最后，让MemInode实现Inode trait，使其可以通过VFS接口使用。

###  步骤6.1: 实现 Inode trait 的方法（Tasks 2-4至2-7）

> **重要说明**：以下代码已在实验框架中完整实现。学生需要**跟着学习理解**这些代码，但不需要自己填写。这部分内容不计分（0分）。

**完整代码**：`os/src/fs/inode.rs` 中的 `impl Inode for MemInode` 块

```rust
impl Inode for MemInode {
    // Task 2-4: 返回Inode编号
    fn ino(&self) -> usize {
        self.ino
    }

    // Task 2-5: 返回文件类型
    fn file_type(&self) -> FileType {
        self.file_type
    }

    // Task 2-6: 返回文件大小
    fn size(&self) -> usize {
        self.size
    }

    // Task 2-7: 返回权限位
    fn mode(&self) -> u32 {
        self.mode
    }
}
```

**代码讲解**：

1. **为什么实现这么简单？**（Tasks 2-4至2-7）
   ```rust
   // 每个方法都只是返回对应的字段
   fn ino(&self) -> usize { self.ino }
   fn file_type(&self) -> FileType { self.file_type }
   fn size(&self) -> usize { self.size }
   fn mode(&self) -> u32 { self.mode }
   ```

   **设计意图**：
   - MemInode已经存储了这些字段
   - Inode trait只需要暴露这些信息
   - 简单的getter方法，直接返回字段值

2. **为什么需要trait而不是直接访问字段？**

   **封装性**：
   ```rust
   // 不好的设计：直接访问字段
   let size = inode.size;  // 破坏封装，如果字段改名就会出错

   // 好的设计：通过方法访问
   let size = inode.size();  // 即使内部实现变化，接口保持不变
   ```

   **多态性**：
   ```rust
   // 通过trait，可以统一处理不同类型的Inode
   fn print_file_info(inode: &dyn Inode) {  // 接受任何实现Inode的类型
       println!("Inode: {}", inode.ino());
       println!("大小: {} 字节", inode.size());
       println!("权限: {:o}", inode.mode());
   }

   // 可以传入不同类型的Inode
   let ram_inode = MemInode::new_file(1);
   print_file_info(&ram_inode);  // OK

   let disk_inode = DiskInode::load(1);
   print_file_info(&disk_inode);  // OK（如果DiskInode也实现了Inode）
   ```

3. **实际应用场景**：

   **VFS层使用**：
   ```rust
   // VFS层只知道Inode trait，不关心具体实现
   fn check_permissions(inode: &dyn Inode, required: u32) -> bool {
       let mode = inode.mode();  // 通过trait方法获取权限
       (mode & required) != 0
   }

   // 可以传入任何实现Inode的类型
   let file_inode = MemInode::new_file(1);
   if check_permissions(&file_inode, permissions::S_IRUSR) {
       println!("有读权限");
   }
   ```

   **文件系统查询**：
   ```rust
   // 显示文件信息
   fn show_file_stat(inode: &dyn Inode) {
       println!("File Information:");
       println!("  Inode Number: {}", inode.ino());
       println!("  Type: {:?}", inode.file_type());
       println!("  Size: {} bytes", inode.size());
       println!("  Permissions: {:o}", inode.mode());
   }
   ```

4. **这就是多态的威力**：
   - 一个函数可以处理多种类型
   - 只要它们实现了相同的trait
   - 无需为每种类型写一个函数

5. **trait设计的好处**：
   - **接口稳定**：即使MemInode内部实现变化，Inode trait接口保持不变
   - **易于扩展**：新增文件系统时，只需实现Inode trait即可
   - **类型安全**：编译器确保所有实现都提供了必需的方法

**完整示例**：

```rust
// 使用场景：文件系统统计
fn filesystem_stats(inodes: &[Arc<Mutex<dyn Inode>>]) {
    let total_size: usize = inodes
        .iter()
        .map(|i| i.lock().size())  // 通过trait方法
        .sum();

    let file_count = inodes
        .iter()
        .filter(|i| i.lock().file_type() == FileType::RegularFile)
        .count();

    println!("Total files: {}", file_count);
    println!("Total size: {} bytes", total_size);
}
print_file_info(&ram_inode);  // OK

let disk_inode = DiskInode::load(1);
print_file_info(&disk_inode);  // OK（如果DiskInode也实现了Inode）
```

**这就是多态的威力**：
- 一个函数可以处理多种类型
- 只要它们实现了相同的trait
- 无需为每种类型写一个函数

---

## 知识点总结

### Inode核心概念

| 概念 | 说明 | 类比 |
|------|------|------|
| Inode编号 | 文件的唯一标识符 | 身份证号 |
| 元数据 | 文件的属性信息（大小、权限、时间） | 身份证上的信息 |
| 硬链接计数 | 记录有多少个目录项指向此Inode | 有多少个名字指向同一个人 |
| 权限位 | Unix风格的rwx权限系统 | 门禁卡的权限级别 |

### File vs Inode

```
Inode (文件本身)
  ↓
  ├─ File1 (第一次打开，offset=0)
  ├─ File2 (第二次打开，offset=100)
  └─ File3 (第三次打开，offset=50)
```

**关键区别**：
- **Inode**：文件的元数据（书的信息）
- **File**：打开文件的句柄（书签位置）
- 一个文件可以被多次打开（多个书签）
- 每次打开有独立的offset，但共享同一个Inode

### Unix权限快速参考

| 八进制 | 二进制 | 权限字符串 | 含义 |
|--------|--------|------------|------|
| 0o644 | 110_100_100 | rw-r--r-- | 普通文件 |
| 0o755 | 111_101_101 | rwxr-xr-x | 目录/可执行文件 |
| 0o600 | 110_000_000 | rw------- | 私密文件 |
| 0o777 | 111_111_111 | rwxrwxrwx | 完全开放（不安全） |

---

## 常见问题

### Q1: 为什么需要硬链接计数？

**答**：防止误删除。

```
场景：
file1.txt → Inode 5 (nlinks=2)
file2.txt → Inode 5

删除file1.txt时：
  nlinks: 2 -> 1
  Inode不能删除（file2.txt还在用）

删除file2.txt时：
  nlinks: 1 -> 0
  现在可以删除Inode了
```

### Q2: 为什么用u32存储权限？

**答**：
- Unix系统传统使用16位mode（包含文件类型和权限）
- 我们用u32是为了：
  1. 对齐友好（CPU处理32位数更高效）
  2. 预留扩展空间（未来可能需要更多标志位）
  3. 简化实现（不需要位操作拆分文件类型和权限）

### Q3: created和modified有什么区别？

**答**：
- `created`：文件创建时间，永不改变
- `modified`：最后修改时间，每次写入时更新

```rust
let inode = MemInode::new_file(1);
// created = T0, modified = T0

file.write(data);  // 修改文件
// created = T0, modified = T1（只有modified变了）

file.write(more_data);
// created = T0, modified = T2（modified再次更新）
```

### Q4: 为什么目录需要执行权限？

**答**：Unix中，目录的`x`权限表示"可以进入（cd）该目录"。

```bash
# 没有x权限的后果
$ chmod 644 mydir  # rw-r--r--（没有x）
$ cd mydir
bash: cd: mydir: Permission denied

# 即使有r权限也无法列出内容
$ ls mydir
ls: cannot access 'mydir': Permission denied

# 正确的目录权限
$ chmod 755 mydir  # rwxr-xr-x
$ cd mydir         # OK
$ ls               # OK
```

### Q5: Arc<Mutex<dyn Inode>>看起来很复杂，能简化吗？

**答**：不能。每一层都有其必要性：

```rust
// dyn Inode: 支持多态（不同类型的Inode）
// Mutex: 线程安全（多线程访问）
// Arc: 共享所有权（多个地方引用同一个Inode）

// 如果去掉任何一层，都会导致问题：
Box<Inode>          // 不能共享所有权
Arc<Inode>          // 不能修改（Inode是immutable的）
Mutex<Inode>        // 不能共享所有权
Arc<Mutex<Inode>>   // 不能支持多态（需要具体类型）
```

---

## 下一步

在下一节（7.1.3）中，我们将实现文件描述符表，管理进程打开的文件。

---

## 练习题

1. **实现权限修改**：添加`set_mode()`方法，修改文件权限
   ```rust
   pub fn set_mode(&mut self, mode: u32) {
       self.mode = mode;
       self.touch();  // 修改权限也算作修改操作
   }
   ```

2. **实现访问时间**：添加`atime`字段，每次读取时更新
   ```rust
   pub fn access(&mut self) {
       self.atime = get_current_timestamp();
   }
   ```

3. **实现完整的权限检查**：根据uid/gid检查对应的权限组
   ```rust
   pub fn can_read(&self, uid: usize, gid: usize) -> bool {
       // 检查用户/组/其他权限
   }
   ```
