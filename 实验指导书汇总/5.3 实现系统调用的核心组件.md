## 5.3 实现系统调用的核心组件

现在我们开始编写代码。按照**需求驱动**的方式，从 main.rs 开始。

### 5.3.1 步骤1：在 main.rs 中创建测试函数

我们首先在 `main.rs` 中编写一个测试函数，定义我们需要的系统调用功能。

#### 在 kernel_main 中调用测试函数

打开 `src/main.rs`，在虚拟内存测试后添加系统调用测试：

```rust
pub extern "C" fn kernel_main() -> ! {
    use os::memory;
    use os::allocator;

    println!("Welcome to Error OS!");

    // ... 内存初始化代码 ...

    // 测试虚拟内存
    test_page_table_features(&mut memory_manager);

    // ======== 新增：测试系统调用 ========
    test_syscall_features();
    // ===================================

    println!("Kernel execution completed!");
    os::hlt_loop();
}
```

#### 创建测试函数框架

在 `kernel_main` 函数后面添加：

```rust
/// 测试系统调用功能
fn test_syscall_features() {
    println!("\n========================================");
    println!("  开始测试系统调用功能");
    println!("========================================\n");

    // TODO: 测试 sys_getpid
    // TODO: 测试 sys_write
    // TODO: 测试未知系统调用

    println!("========================================");
    println!("  系统调用测试完成！");
    println!("========================================\n");
}
```


---

### 5.3.2 步骤2：实现 SyscallContext（系统调用上下文）

继续测试函数，我们需要能够触发系统调用并获取结果。

#### test_syscall_features（main.rs）

我们希望在测试函数中这样调用系统调用：

```rust
fn test_syscall_features() {
    use os::syscall::test_syscall;

    println!("[1] 测试 sys_getpid 系统调用...");
    let pid = test_syscall(172, 0, 0, 0);
    println!("    - 当前进程 PID: {}\n", pid);

    println!("[2] 测试 sys_write 系统调用...");
    let msg = "Hello from syscall!\n";
    let msg_ptr = msg.as_ptr();
    let msg_len = msg.len();

    let written = test_syscall(
        64,                   // sys_write
        1,                    // fd = stdout
        msg_ptr as usize,
        msg_len,
    );

    if written > 0 {
        println!("    - 成功写入 {} 字节\n", written);
    }
}
```


#### 创建 syscall 模块

创建 `src/syscall/mod.rs` 文件。

**在 lib.rs 中添加模块声明**：

打开 `src/lib.rs`，添加：

```rust
pub mod memory;
pub mod allocator;
pub mod syscall;  // 新增
```

#### 定义系统调用号（syscall/mod.rs）

在 `src/syscall/mod.rs` 中添加：

```rust
/// 系统调用编号
#[repr(usize)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SyscallId {
    Write = 64,      // 写入数据
    Exit = 93,       // 退出进程
    GetPid = 172,    // 获取进程ID
    Unknown = 9999,  // 未知系统调用
}

impl From<usize> for SyscallId {
    fn from(id: usize) -> Self {
        match id {
            64 => SyscallId::Write,
            93 => SyscallId::Exit,
            172 => SyscallId::GetPid,
            _ => SyscallId::Unknown,
        }
    }
}
```

**说明**：
- `Write = 64`：写入系统调用（遵循 Linux 约定）
- `Exit = 93`：退出系统调用
- `GetPid = 172`：获取进程ID
- `From<usize>`：将数字转换为枚举

#### 定义系统调用上下文（syscall/mod.rs）

```rust
/// 系统调用上下文
///
/// 保存系统调用的所有参数
#[derive(Debug)]
pub struct SyscallContext {
    pub syscall_id: usize,  // a7：系统调用号
    pub arg0: usize,        // a0：参数0 / 返回值
    pub arg1: usize,        // a1：参数1
    pub arg2: usize,        // a2：参数2
    pub arg3: usize,        // a3：参数3
    pub arg4: usize,        // a4：参数4
    pub arg5: usize,        // a5：参数5
    pub sepc: usize,        // 系统调用发生时的 PC
}
```

#### 从寄存器读取上下文（syscall/mod.rs）

```rust
impl SyscallContext {
    /// 从 RISC-V 寄存器读取系统调用上下文
    ///
    /// # Safety
    /// 必须在系统调用处理器中调用，此时寄存器包含有效的系统调用参数
    pub unsafe fn from_registers() -> Self {
        let syscall_id: usize;
        let arg0: usize;
        let arg1: usize;
        let arg2: usize;
        let arg3: usize;
        let arg4: usize;
        let arg5: usize;

        // 使用内联汇编读取寄存器
        core::arch::asm!(
            "mv {0}, a7",    // 读取系统调用号
            "mv {1}, a0",    // 读取参数
            "mv {2}, a1",
            "mv {3}, a2",
            "mv {4}, a3",
            "mv {5}, a4",
            "mv {6}, a5",
            out(reg) syscall_id,
            out(reg) arg0,
            out(reg) arg1,
            out(reg) arg2,
            out(reg) arg3,
            out(reg) arg4,
            out(reg) arg5,
        );

        let sepc = riscv::register::sepc::read();

        Self {
            syscall_id,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            sepc,
        }
    }

    /// 设置返回值到 a0 寄存器
    ///
    /// # Safety
    /// 必须在系统调用处理器中调用
    pub unsafe fn set_return_value(&self, ret: isize) {
        core::arch::asm!(
            "mv a0, {0}",
            in(reg) ret,
        );
    }
}
```

**关键点**：
- `mv {0}, a7`：将 a7 寄存器的值移动到 Rust 变量
- `out(reg)`：告诉编译器这是输出操作数
- `unsafe`：因为我们直接操作寄存器

---

### 5.3.3 步骤3：实现 syscall_dispatcher（系统调用分发器）

现在我们需要根据系统调用号，分发到具体的处理函数。

#### 系统调用分发器（syscall/mod.rs）

在 `src/syscall/mod.rs` 中添加：

```rust
/// 系统调用分发器
///
/// 根据系统调用号，调用对应的处理函数
pub fn syscall_dispatcher(context: &SyscallContext) -> isize {
    let syscall_id = SyscallId::from(context.syscall_id);

    match syscall_id {
        SyscallId::Write => {
            // TODO: 调用 sys_write
            -1
        }
        SyscallId::Exit => {
            // TODO: 调用 sys_exit
            -1
        }
        SyscallId::GetPid => {
            // TODO: 调用 sys_getpid
            -1
        }
        SyscallId::Unknown => {
            println!("[SYSCALL] Unknown syscall: {}", context.syscall_id);
            -38  // ENOSYS
        }
    }
}
```

**说明**：
- 匹配系统调用号
- 调用对应的处理函数（目前返回 -1）
- 未知系统调用返回 -38（ENOSYS）

#### 测试接口（syscall/mod.rs）

为了方便测试，我们提供一个简化的接口：

```rust
/// 测试系统调用的简化接口
///
/// 用于在内核中测试系统调用，不经过 ecall 指令
pub fn test_syscall(
    syscall_id: usize,
    arg0: usize,
    arg1: usize,
    arg2: usize,
) -> isize {
    let context = SyscallContext {
        syscall_id,
        arg0,
        arg1,
        arg2,
        arg3: 0,
        arg4: 0,
        arg5: 0,
        sepc: 0,
    };
    syscall_dispatcher(&context)
}
```

**说明**：
- 直接构造 `SyscallContext`，不需要 ecall
- 用于内核内部测试

---

### 5.3.4 步骤4：修改 trap_handler 添加系统调用处理

现在我们需要在异常处理器中添加系统调用的处理逻辑。

#### 修改 interrupts.rs

打开 `src/interrupts.rs`，找到 `trap_handler` 函数，添加系统调用处理：

```rust
#[no_mangle]
pub extern "C" fn trap_handler() {
    let scause = scause::read();
    let stval = stval::read();
    let sepc = sepc::read();

    match scause.cause() {
        Trap::Exception(exception) => {
            match exception {
                // ======== 新增：系统调用处理 ========
                Exception::UserEnvCall => {
                    syscall_handler(sepc);
                }
                // ===================================
                Exception::LoadFault => {
                    panic!(
                        "Load fault at {:#x}, trying to access {:#x}",
                        sepc, stval
                    );
                }
                // ... 其他异常处理 ...
            }
        }
        Trap::Interrupt(_interrupt) => {
            // ... 中断处理 ...
        }
    }
}
```

#### 实现 syscall_handler（interrupts.rs）

在 `interrupts.rs` 文件末尾添加：

```rust
/// 系统调用处理函数
///
/// 从寄存器读取上下文，调用分发器，设置返回值
fn syscall_handler(sepc: usize) {
    // 第1步：从寄存器读取系统调用上下文
    let context = unsafe { crate::syscall::SyscallContext::from_registers() };

    // 第2步：调用系统调用分发器
    let result = crate::syscall::syscall_dispatcher(&context);

    // 第3步：设置返回值到 a0 寄存器
    unsafe {
        context.set_return_value(result);
    }

    // 第4步：跳过 ecall 指令（4 字节）
    riscv::register::sepc::write(sepc + 4);
}
```

**关键步骤**：
1. **读取上下文**：从 a0-a7 寄存器读取参数
2. **调用分发器**：执行具体的系统调用
3. **设置返回值**：将结果写入 a0 寄存器
4. **跳过指令**：`sepc += 4`，避免重复执行 ecall
