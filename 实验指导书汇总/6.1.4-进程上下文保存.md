# 6.1.4 进程上下文保存

## 本节新增文件

```
os/src/process/
├── mod.rs          # 进程管理模块入口（已存在）
├── pid.rs          # PID分配器（已完成）
├── pcb.rs          # 进程控制块（本节继续补充）
└── context.rs      # 进程上下文结构（新建）
```

---

## 什么是进程上下文？

**进程上下文（Process Context）** 是进程的执行状态快照，包含CPU寄存器的所有值。

### 为什么需要保存上下文？

当操作系统进行**进程切换**时，我们需要清楚的知道：

1.被移出处理器的进程执行到了哪一步

2.新上处理机执行的进程应该从哪里开始

这些数据都保存在相应的寄存器中，我们需要根据这些信息来对进程进行精确的控制

**用生活中的场景进行类比的话就好比**：

- 你在做数学作业（进程A）
- 妈妈喊你吃饭（中断）
- 你记下做到第几题（保存上下文）
- 吃完饭回来继续做（恢复上下文）

---

## RISC-V寄存器回顾

涉及寄存器底层的知识需要汇编等知识的储备，在本教程中不必深究，但为了理解系统源码，我们仍需进行介绍

RISC-V有**32个通用寄存器** + **CSR寄存器**：

### 通用寄存器（x0-x31）

| 寄存器 | 别名 | 用途 | 是否需要保存 |
|--------|------|------|------------|
| x0 | zero | 硬件固定为0 | 不需要 |
| x1 | ra | 返回地址 | 需要 |
| x2 | sp | 栈指针 | 需要 |
| x3 | gp | 全局指针 | 需要 |
| x4 | tp | 线程指针 | 需要 |
| x5-x7 | t0-t2 | 临时寄存器 | 需要 |
| x8-x9 | s0-s1 | 保存寄存器 | 需要 |
| x10-x17 | a0-a7 | 参数/返回值 | 需要 |
| x18-x27 | s2-s11 | 保存寄存器 | 需要 |
| x28-x31 | t3-t6 | 临时寄存器 | 需要 |

### CSR寄存器（状态控制寄存器）

| 寄存器 | 用途 | 是否需要保存 |
|--------|------|:----------:|
| sepc | 异常返回地址 | 需要 |
| sstatus | 处理器状态 | 需要 |
| satp | 页表基址 | 特殊处理 |

**总共需要保存**：31个通用寄存器 + 3个CSR = **34个寄存器**

---

## 步骤1：创建context.rs

### 1.1 创建文件

```bash
touch os/src/process/context.rs
```

### 1.2 在mod.rs中注册

```rust
// os/src/process/mod.rs
pub mod pid;
pub mod pcb;
pub mod context;  // ← 新增

pub use pid::ProcessId;
pub use pcb::ProcessState;
pub use context::ProcessContext;  // ← 新增
```

---

## 步骤2：定义ProcessContext结构

在 `os/src/process/context.rs` 中：

```rust
/// 进程上下文
///
/// 保存进程的所有CPU寄存器状态
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct ProcessContext {
    /// 通用寄存器 x1-x31（x0固定为0，不需要保存）
    pub x: [usize; 31],
    
    /// sepc: 异常返回地址
    pub sepc: usize,
    
    /// sstatus: 处理器状态寄存器
    pub sstatus: usize,
    
    /// satp: 页表基址寄存器
    pub satp: usize,
}
```

**关键点**：

### `#[repr(C)]`
- 使用C语言的内存布局
- 保证字段顺序和汇编代码一致
- 便于汇编直接访问

### `#[derive(Copy)]`
- 允许按值复制整个上下文
- 复制开销：34 * 8 = 272字节

---

## 步骤3：实现上下文初始化

```rust
impl ProcessContext {
    /// 创建空白上下文
    pub const fn new() -> Self {
        ProcessContext {
            x: [0; 31],
            sepc: 0,
            sstatus: 0,
            satp: 0,
        }
    }
}
```

---

## 步骤4：添加寄存器访问方法

为了方便访问，添加别名方法：

```rust
impl ProcessContext {
    /// 获取栈指针（sp = x2）
    pub fn sp(&self) -> usize {
        self.x[1]  // x[1]对应x2
    }
    
    /// 设置栈指针
    pub fn set_sp(&mut self, sp: usize) {
        self.x[1] = sp;
    }
    
    /// 获取返回地址（ra = x1）
    pub fn ra(&self) -> usize {
        self.x[0]  // x[0]对应x1
    }
    
    /// 设置返回地址
    pub fn set_ra(&mut self, ra: usize) {
        self.x[0] = ra;
    }
    
    /// 获取参数寄存器a0（x10）
    pub fn a0(&self) -> usize {
        self.x[9]  // x[9]对应x10
    }
    
    /// 设置参数寄存器a0
    pub fn set_a0(&mut self, a0: usize) {
        self.x[9] = a0;
    }
}
```

**为什么下标这么奇怪？**

因为x0固定为0不保存，所以：
- `x[0]` 实际存储 `x1`（ra）
- `x[1]` 实际存储 `x2`（sp）
- `x[9]` 实际存储 `x10`（a0）

---

## 步骤5：实现代码

###  任务点11-14: 进程上下文实现 (总分: 11分)

**文件位置**: `os/src/process/context.rs`

#### 任务点清单

| ID | 任务描述 | 分值 | 检查方法 |
|----|---------|------|---------|
| 11 | ProcessContext结构定义 | 4分 | 结构体字段检查 |
| 12 | new()方法 | 3分 | 初始化验证 |
| 13 | set_ra()方法 | 2分 | 返回地址设置测试 |
| 14 | set_sp()方法 | 2分 | 栈指针设置测试 |

#### 实现要求

请在 `os/src/process/context.rs` 中完成以下实现:

1. **ProcessContext结构定义** (任务点11)
   - 使用`#[repr(C)]`保证C语言内存布局
   - 定义4个字段:
     - `x: [usize; 31]` - 通用寄存器x1-x31
     - `sepc: usize` - 异常返回地址
     - `sstatus: usize` - 处理器状态寄存器
     - `satp: usize` - 页表基址寄存器
   - 添加derive宏: Debug, Clone, Copy

2. **new()方法** (任务点12)
   - 实现const fn new()
   - 所有字段初始化为0
   - 返回新创建的ProcessContext

3. **set_ra()方法** (任务点13)
   - 设置返回地址寄存器(ra = x1)
   - ra对应x[0] (因为x0不保存)
   - 参数: ra: usize

4. **set_sp()方法** (任务点14)
   - 设置栈指针寄存器(sp = x2)
   - sp对应x[1]
   - 参数: sp: usize

**提示代码**:

```rust
// 【任务11】ProcessContext结构体定义
// 提示：先添加内存布局和派生宏，再定义字段
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct ProcessContext {
    // TODO: 定义x数组（[usize; 31]）
    // TODO: 定义sepc、sstatus、satp字段（均为usize类型）
}

// 【任务12-14】方法实现
impl ProcessContext {
    // 【任务12】new()初始化方法
    // 提示：常量函数，所有字段初始化为0
    pub const fn new() -> Self {
        todo!("初始化所有字段为0并返回ProcessContext实例")
    }

    // 【任务13】set_ra()设置返回地址
    // 提示：ra = x1 → 对应x[0]
    pub fn set_ra(&mut self, ra: usize) {
        todo!("将ra赋值给self.x[0]")
    }

    // 【任务14】set_sp()设置栈指针
    // 提示：sp = x2 → 对应x[1]
    pub fn set_sp(&mut self, sp: usize) {
        todo!("将sp赋值给self.x[1]")
    }
}
```

#### 验证方法

**编译验证**:

```bash
cd os
cargo build
```

**运行判题**:

```bash
cargo run --release
# 系统会自动运行判题系统，显示任务点完成情况
```

**手动测试**:

```rust
let mut ctx = ProcessContext::new();
ctx.set_sp(0x8020_0000);
ctx.set_ra(0x8000_1000);
println!("sp = 0x{:x}, ra = 0x{:x}", ctx.sp(), ctx.ra());
// 预期输出: sp = 0x80200000, ra = 0x80001000
```

#### 预期输出

如果实现正确，判题系统会显示:

```
========================================
     Chapter 6 Grading Report
========================================

[PASS] Task 11: ProcessContext struct definition (4分)
[PASS] Task 12: new() method (3分)
[PASS] Task 13: set_ra() method (2分)
[PASS] Task 14: set_sp() method (2分)
========================================
Process Context Score: 11/11
```

#### 常见错误

| 错误现象 | 可能原因 | 解决方法 |
|---------|---------|---------|
| 编译错误: "cannot find type ProcessContext" | 结构体未定义 | 检查结构体定义语法 |
| repr(C)错误 | 缺少#[repr(C)]属性 | 在struct前添加#[repr(C)] |
| set_sp设置错误 | 数组下标错误 | sp=x2对应x[1]，不是x[2] |
| set_ra设置错误 | 数组下标错误 | ra=x1对应x[0]，不是x[1] |
| new()不是const | 函数签名错误 | 使用pub const fn new() |

---

## 步骤6：在PCB中使用Context

现在更新 `os/src/process/pcb.rs`，添加context字段：

```rust
use super::{ProcessId, ProcessContext};

pub struct ProcessControlBlock {
    pid: ProcessId,
    state: ProcessState,
    
    // 新增：进程上下文
    context: ProcessContext,
    
    // ... 其他字段
}
```

---

## 知识点总结

### 核心概念

| 概念 | 说明 |
|------|------|
| **进程上下文** | 进程的CPU寄存器快照 |
| **上下文切换** | 保存当前进程上下文，恢复下一个进程上下文 |
| **通用寄存器** | x1-x31，31个 |
| **CSR寄存器** | sepc, sstatus, satp |

### 设计决策

| 决策 | 理由 |
|------|------|
| 用数组存储x1-x31 | 便于汇编代码循环访问 |
| 使用`#[repr(C)]` | 保证与汇编代码的内存布局一致 |
| 实现Copy | 上下文很小（272字节），复制开销低 |
| 提供别名方法 | 提高代码可读性 |

### 寄存器映射表

| 数组下标 | 实际寄存器 | 别名 |
|---------|-----------|------|
| x[0] | x1 | ra |
| x[1] | x2 | sp |
| x[2] | x3 | gp |
| x[9] | x10 | a0 |
| x[10] | x11 | a1 |

---

## 下一步

现在我们有了：
- 6.1.2 - PID分配器
- 6.1.3 - 进程状态枚举
- 6.1.4 - 进程上下文保存（本节）

下一节（6.1.5）将实现**完整的PCB结构**，整合所有组件。

---

## 思考题

1. 为什么x0寄存器不需要保存？
2. 为什么要用`#[repr(C)]`？
3. 上下文切换时，如果忘记保存某个寄存器会发生什么？
