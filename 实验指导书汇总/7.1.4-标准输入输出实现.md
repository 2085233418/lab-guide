# 7.1.4 标准输入输出实现

## 本节目标

- 实现Stdout标准输出
- 实现Stdin标准输入
- 实现Stderr标准错误
- 创建文件系统模块入口
- 完成VFS抽象层

---

## 本节新增文件

```
os/src/fs/
├── stdio.rs        # 标准输入输出实现
└── mod.rs          # 文件系统模块入口
```

---

## 前置要求

- 已完成 7.1.1 节的 File trait 定义
- 已完成 7.1.2 节的 Inode 抽象
- 已完成 7.1.3 节的文件描述符表

---

## 步骤 1：实现 Stdout 标准输出

### 1.1 创建 stdio.rs 文件

进程需要基础的输入输出能力，而标准流（stdin/stdout/stderr）是操作系统提供的核心 I/O 接口。创建 stdio.rs 文件，用于实现标准流的 File trait，为后续 FD 表初始化和 I/O 系统调用提供基础。

**文件路径**：`os/src/fs/stdio.rs`

```rust
//! 标准输入输出文件
//!
//! 提供stdin、stdout、stderr的File实现

use super::file::{File, FileError};
use crate::println;
```

### 1.2 定义 Stdout 结构

为了让 FD 表能管理标准输出，需要将 stdout 抽象为一个具体的 File 对象。Stdout 结构作为标准输出的载体，实现 File trait 以支持 write 操作。

**文件路径**：`os/src/fs/stdio.rs`

```rust
/// 标准输出
pub struct Stdout;

impl Stdout {
    pub fn new() -> Self {
        Stdout
    }
}
```

**设计要点说明**：

- **为什么是零大小类型？** 因为 stdout 的行为完全由系统决定，不需要存储实例状态，ZST 节省内存且所有实例行为一致。

### 1.3 实现 File trait

Stdout 必须实现 File trait 才能被 FD 表管理，进而支持`write()`系统调用。通过实现 File trait，将底层的串口输出（`println!`）封装为标准的文件写入接口。

**文件路径**：`os/src/fs/stdio.rs`

```rust
impl File for Stdout {
    fn read(&mut self, _buf: &mut [u8]) -> Result<usize, FileError> {
        Err(FileError::InvalidOperation)
    }

    fn write(&mut self, buf: &[u8]) -> Result<usize, FileError> {
        if let Ok(s) = core::str::from_utf8(buf) {
            println!("{}", s);
            Ok(buf.len())
        } else {
            Err(FileError::IoError)
        }
    }
}
```

**设计要点说明**：

- **为什么 read () 返回错误？** 遵循 Unix 设计约定：stdout 是只写流，不允许读取，符合 POSIX 标准，避免用户错误使用。
- **为什么 write () 要验证 UTF-8？** 标准输出主要用于显示文本，UTF-8 验证确保输出内容有效，避免终端乱码。

### 1.4 为什么不能从 stdout 读取？

**设计背景**：Unix 系统设计中，标准流的访问权限是明确划分的：

- stdin（FD 0）：只读，用于接收输入
- stdout（FD 1）：只写，用于输出正常信息
- stderr（FD 2）：只写，用于输出错误信息

**实际意义**：这种设计强制区分了输入和输出的流向，避免了程序逻辑混乱。例如，`cat < /dev/stdout` 尝试从 stdout 读取是无意义的，因为 stdout 本身是输出通道。

# 步骤2：实现Stdin标准输入

### 2.1 定义Stdin结构

**文件路径：`os/src/fs/stdio.rs`**

```rust
/// 标准输入
pub struct Stdin;

impl Stdin {
    pub fn new() -> Self {
        Stdin
    }
}
```

### 2.2 实现File trait

**文件路径：`os/src/fs/stdio.rs`**

```rust
impl File for Stdin {
    fn read(&mut self, _buf: &mut [u8]) -> Result<usize, FileError> {
        // TODO: 实现键盘输入
        Err(FileError::InvalidOperation)
    }

    fn write(&mut self, _buf: &[u8]) -> Result<usize, FileError> {
        Err(FileError::InvalidOperation)
    }
}
```

**当前实现**：

- `read()` - 暂时返回错误，后续章节实现键盘输入
- `write()` - 返回错误，不能向stdin写入

### 2.3 为什么暂不实现stdin.read？

**原因**：

- 需要键盘驱动支持
- 需要实现输入缓冲区
- 需要处理中断和阻塞
- 这些内容在后续章节实现

**占位实现**：

```rust
// 当前返回错误
Err(FileError::InvalidOperation)

// 后续实现（第8章）
fn read(&mut self, buf: &mut [u8]) -> Result<usize, FileError> {
    let input = keyboard::read_line()?;
    let n = core::cmp::min(buf.len(), input.len());
    buf[..n].copy_from_slice(&input.as_bytes()[..n]);
    Ok(n)
}
```

---

## 步骤3：实现Stderr标准错误

### 3.1 定义Stderr结构

**文件路径：`os/src/fs/stdio.rs`**

```rust
/// 标准错误
pub struct Stderr;

impl Stderr {
    pub fn new() -> Self {
        Stderr
    }
}
```

### 3.2 实现File trait

**文件路径：`os/src/fs/stdio.rs`**

```rust
impl File for Stderr {
    fn read(&mut self, _buf: &mut [u8]) -> Result<usize, FileError> {
        Err(FileError::InvalidOperation)
    }

    fn write(&mut self, buf: &[u8]) -> Result<usize, FileError> {
        if let Ok(s) = core::str::from_utf8(buf) {
            println!("{}", s);
            Ok(buf.len())
        } else {
            Err(FileError::IoError)
        }
    }
}
```

### 3.3 Stdout vs Stderr

**区别**：

| 特性 | Stdout | Stderr |
|------|--------|--------|
| FD号 | 1 | 2 |
| 用途 | 正常输出 | 错误信息 |
| 缓冲 | 通常有缓冲 | 通常无缓冲 |
| 重定向 | 可以分别重定向 | 可以分别重定向 |

**使用场景**：

```bash
# 分别重定向
command > output.txt 2> error.txt

# 合并输出
command > all.txt 2>&1
```

**当前实现**：

- 两者行为相同，都输出到串口
- 后续可以添加不同的缓冲策略

---

## 步骤4：创建模块入口

### 4.1 创建mod.rs

创建 `os/src/fs/mod.rs`：

**文件路径：`os/src/fs/mod.rs`**

```rust
//! 文件系统模块
//!
//! 提供VFS抽象层

pub mod file;
pub mod inode;
pub mod fd_table;
pub mod stdio;

pub use file::{File, FileError, FileType, FileMetadata, SeekFrom};
pub use inode::{Inode, MemInode, InodeHandle, permissions};
pub use fd_table::{FileDescriptor, FileDescriptorTable, STDIN, STDOUT, STDERR};
pub use stdio::{Stdin, Stdout, Stderr};
```

**模块组织**：

```
os::fs
  ├── file       (File trait)
  ├── inode      (Inode trait)
  ├── fd_table   (FD表)
  └── stdio      (标准流)
```

### 4.2 在lib.rs中注册模块

在 `os/src/lib.rs` 中添加：

**文件路径：`os/src/lib.rs`**

```rust
pub mod fs;
```

现在可以通过 `os::fs::File` 访问文件系统接口。

---

## 步骤5：验证编译

### 5.1 编译测试

```bash
cd os
cargo build
```

**预期结果**：

- 编译成功
- 无警告和错误

### 5.2 如果编译失败

**常见错误1**：模块未找到

```
error[E0583]: file not found for module `fs`
```

**解决**：检查 `os/src/lib.rs` 是否添加了 `pub mod fs;`

**常见错误2**：类型未导出

```
error[E0412]: cannot find type `File` in this scope
```

**解决**：检查 `mod.rs` 是否正确导出类型

---

## 知识点总结

### 标准流特性

| 流 | FD号 | 读 | 写 | 用途 |
|----|------|----|----|------|
| stdin | 0 | √ | × | 接收输入 |
| stdout | 1 | × | √ | 正常输出 |
| stderr | 2 | × | √ | 错误输出 |

### 零大小类型（ZST）

```rust
pub struct Stdout;  // 零大小类型

assert_eq!(std::mem::size_of::<Stdout>(), 0);
```

**优点**：

- 不占用内存
- 编译器优化友好
- 适合无状态的类型

### 模块导出模式

```rust
// 内部模块
pub mod file;
pub mod inode;

// 重新导出常用类型
pub use file::{File, FileError};
pub use inode::{Inode, InodeHandle};
```

**好处**：

- 用户无需深入了解模块结构
- 简化导入路径
- 方便重构

---

## 常见问题

### Q1: 为什么Stdout不需要存储状态？

**原因**：

- 输出直接到串口，无需缓冲
- 每次write都是独立操作
- 不需要记录位置或状态

**对比**：

```rust
// Stdout (无状态)
struct Stdout;

// RamFile (有状态)
struct RamFile {
    inode: Arc<Mutex<RamInode>>,
    offset: usize,  // 需要记录位置
}
```

### Q2: 为什么要分stdout和stderr？

**历史原因**：

- Unix设计者希望分离正常输出和错误信息
- 方便脚本处理和日志分类

**实际用途**：

```bash
# 只保存正常输出
command > output.txt

# 只保存错误信息
command 2> error.txt

# 分别保存
command > output.txt 2> error.txt
```

### Q3: println!如何输出到串口？

**实现链**：

```
println! 宏
  ↓
fmt::write
  ↓
_print 函数
  ↓
串口驱动
  ↓
UART硬件
```

**代码位置**：

- 宏定义：`os/src/console.rs`
- 串口驱动：`os/src/drivers/uart.rs`

---

## VFS抽象层总结

经过7.1.1-7.1.4四个小节，我们完成了VFS抽象层的实现：

### 核心组件

| 组件 | 文件 | 作用 |
|------|------|------|
| File trait | file.rs | 统一的文件操作接口 |
| Inode trait | inode.rs | 文件元数据抽象 |
| FD Table | fd_table.rs | 文件描述符管理 |
| Stdio | stdio.rs | 标准输入输出 |

### 类型关系

```
FD号 (usize)
  ↓
FD_TABLE.get(fd)
  ↓
Arc<Mutex<dyn File>>
  ↓
Stdin/Stdout/Stderr/RamFile
```

### 已实现的功能

- File trait定义（read/write/seek）
- Inode抽象和权限管理
- 文件描述符表（分配/释放/查询）
- 标准输入输出（stdin/stdout/stderr）

### 下一步

在下一节（7.2）中，我们将实现RamFS（内存文件系统），这是VFS抽象层的第一个具体实现。

---

## 练习题

1. **实现缓冲**：为Stdout添加缓冲区，减少串口调用次数
2. **实现颜色**：为Stderr添加红色输出，区分错误信息
3. **实现统计**：记录stdout/stderr的输出字节数
