## 1.3 UART串口驱动实现



#### 什么是UART 16550 寄存器？

UART (Universal Asynchronous Receiver/Transmitter) 是通用异步收发器，用于串行通信。UART 16550 是一个标准的串口控制器。

解决了这个问题，我们再来回答另一个问题：

#### 我们要用它来做什么？

我们在1.1中去除了标准库依赖，因此我们无法继续使用诸如`println！()`之类的方法实现输出。因此我们需要通过串口来实现控制台输入/交互。



**RISC-V QEMU virt 机器的 UART 配置**

- 基地址：`0x10000000`
- 类型：16550 兼容
- 时钟频率：由 QEMU 模拟
- 默认波特率：115200

**重要寄存器**

| 偏移 | 寄存器名                           | 说明            |
| ---- | ---------------------------------- | --------------- |
| `+0` | THR (Transmitter Holding Register) | 发送数据寄存器  |
| `+0` | RBR (Receiver Buffer Register)     | 接收数据寄存器  |
| `+1` | IER (Interrupt Enable Register)    | 中断使能寄存器  |
| `+2` | FCR (FIFO Control Register)        | FIFO 控制寄存器 |
| `+3` | LCR (Line Control Register)        | 线路控制寄存器  |
| `+4` | MCR (Modem Control Register)       | 调制解调器控制  |
| `+5` | LSR (Line Status Register)         | 线路状态寄存器  |

**LSR (Line Status Register) 位定义**

| 位   | 名称              | 说明                                   |
| ---- | ----------------- | -------------------------------------- |
| 0    | Data Ready        | 接收缓冲区有数据                       |
| 5    | THR Empty         | 发送缓冲区为空（**我们需要检查这个**） |
| 6    | Transmitter Empty | 发送器空闲                             |

看不懂？不着急，先把串口驱动写起来。

---

#### 封装 UART 驱动接口

**步骤 1：创建 `serial.rs` 模块**

```
ErrorOS/
├── os/                         # 内核代码目录
│   ├── .cargo/
│   │   └── config.toml         # Cargo 配置
│   ├── src/
│   │   ├── main.rs             # 内核主程序
│   │   ├── lib.rs              # 库入口文件
│   │   └── serial.rs           # 串口驱动模块
│   ├── Cargo.toml              # 项目配置
│   └── linker-riscv64.ld       # 链接器脚本
├── run.sh                      # QEMU 运行脚本
└── README.md                   # 项目说明
```

在 `os/src/` 目录创建 `serial.rs`：

```rust
/*
 * ============================================
 * RISC-V 串口驱动模块
 * ============================================
 * 功能：提供 UART 16550 串口输出功能
 * 用途：调试输出、日志记录、与 QEMU 通信
 *
 * RISC-V QEMU virt 机器的串口地址：0x10000000
 * ============================================
 */

use core::fmt;
use spin::Mutex;
use lazy_static::lazy_static;
use volatile::Volatile;
```

**上面几个依赖的说明**

- `core::fmt`：Rust 核心库的格式化模块，提供 `Arguments`（格式化参数）、`Write`（写入 trait）等，支持像 `println!` 一样的占位符格式化（如 {}、{:x}）。
- `spin::Mutex`：互斥锁（来自 `spin` crate 或内核同步模块），用于**保护全局串口实例的并发访问**（多核环境下避免多个核心同时操作串口硬件导致的数据错乱）。

- `lazy_static`: 运行时初始化静态变量（解决 Rust 不允许直接在全局作用域执行复杂初始化逻辑的问题）。

```rust
// RISC-V QEMU virt 机器的 UART 基地址
const UART_BASE_ADDRESS: usize = 0x1000_0000;

/// UART 16550 寄存器偏移
const UART_THR: usize = 0; // Transmitter Holding Register
const UART_LSR: usize = 5; // Line Status Register

/// Line Status Register 位定义
const UART_LSR_THRE: u8 = 1 << 5; // Transmitter Holding Register Empty

/// 简单的 UART 串口驱动
pub struct SerialPort {
    base_address: usize,
}
```

继续在 `serial.rs` 中添加：

```rust
impl SerialPort {
    
    pub unsafe fn new(base_address: usize) -> Self {
        SerialPort { base_address }
    }  //敲黑板：这是在存储UART硬件寄存器的基地址（即在内存中的起始位置）

 /// 初始化串口
    pub fn init(&mut self) {
        // QEMU 的 UART 默认已初始化，无需额外配置
    }

 /// 核心功能！！！：发送一个字节
    fn send(&mut self, byte: u8) {
        unsafe {
            // 等待发送缓冲区为空
            while !self.is_transmit_empty() {}
            // 写入数据
            let thr = (self.base_address + UART_THR) as *mut Volatile<u8>;
            (*thr).write(byte);
        }
    }

    /// 检查发送缓冲区是否为空
    fn is_transmit_empty(&self) -> bool {
        unsafe {
            let lsr = (self.base_address + UART_LSR) as *const Volatile<u8>;
            (*lsr).read() & UART_LSR_THRE != 0
        }
    }
}
```

这段代码的核心是通过**内存映射I/O直接操作UART硬件寄存器**，实现最基础的字节发送功能。

然后我们接着对上面的串口底层操作进行上层封装，来提供一个**全局可用、线程安全的串口打印工具**，支持像`println!()`一样的格式化输出，适用于RISC-V架构的QEMU虚拟机。

#### 实现字节级输出

**实现 `fmt::Write` trait**

继续在 `serial.rs` 中添加：

```rust
impl fmt::Write for SerialPort {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        for byte in s.bytes() {
            self.send(byte);
        }
        Ok(())
    }
}
```

**创建全局串口实例**

```rust
lazy_static! {
    /// 全局串口实例（UART0）
    /// 使用 Mutex 保护以支持多核访问
    /// 在 RISC-V QEMU virt 机器中，UART 映射到 0x10000000
    pub static ref SERIAL1: Mutex<SerialPort> = {
        let mut serial_port = unsafe{
        SerialPort::new(UART_BASE_ADDRESS) 
        };
        serial_port.init();
        Mutex::new(serial_port)
    };
}
```

笔者注：`Mutex`的作用：

串口硬件是**独占资源**（同一时间只能有一个核心 / 线程操作）。如果多核 CPU 同时调用`send`方法，会导致发送的数据错乱（比如核心 A 写一半，核心 B 插入数据）。而`Mutex` 的作用：提供 “互斥访问”—— 任何时候只有一个持有者能获取 `SerialPort` 的可变引用，其他调用者会阻塞等待，直到锁被释放。

#### 实现格式化输出支持

**底层打印函数`_print`**

继续在 `serial.rs` 中添加：

```rust
/// 底层打印函数
///
/// # 功能
/// - 格式化输出到串口
/// - 在临界区内执行，禁用中断以防止死锁
///
/// # 参数
/// - `args`: 格式化参数
#[doc(hidden)]
pub fn _print(args: ::core::fmt::Arguments) {
    use core::fmt::Write;

    // RISC-V 中断禁用/启用
    // 使用自旋锁时禁用中断，防止死锁
    crate::interrupts::without_interrupts(|| {
        SERIAL1
            .lock()
            .write_fmt(args)
            .expect("Printing to serial failed");
    });
}
```

**注意**: 这里引用了 `crate::interrupts::without_interrupts`，我们将在第2章实现。暂时可以简化为：

```rust
#[doc(hidden)]
pub fn _print(args: ::core::fmt::Arguments) {
    use core::fmt::Write;

    SERIAL1
        .lock()
        .write_fmt(args)
        .expect("Printing to serial failed");
} 
```

**这是格式化输出的 “桥梁”，连接上层宏和底层串口发送。**

##### 1. 函数签名与参数

- `#[doc(hidden)]`：隐藏该函数的文档（用户无需直接调用，仅用于宏内部）。

- 参数`args: ::core::fmt::Arguments`：格式化后的参数结构体（由`format_args!`宏生成，包含待打印的字符串和占位符对应的值）。

  *举例：`serial_print!("x = {}", 42)` 会被 `format_args!` 转换为 `Arguments` 实例，包含字符串 `"x = {}"` 和值 `42`。

##### 2. 核心逻辑：`lock()` + `write_fmt()`

##### （1）`SERIAL1.lock()`：获取互斥锁

- 调用 `Mutex` 的 `lock` 方法，获取 `SerialPort` 的可变引用（`&mut SerialPort`）。
- 如果其他核心已持有锁，当前核心会阻塞等待（自旋锁会循环检查锁状态，直到获取成功）。
- 确保后续的串口操作是 “独占” 的，避免并发冲突。

##### （2）`write_fmt(args)`：格式化写入

- 为什么能调用`write_fmt`？

  因为`SerialPort`一定实现了`core::fmt::Write` trait（否则无法使用格式化输出）。`Write`trait 要求实现`write_str1` 方法（写入字符串），而`write_fmt`是默认实现（会解析`Arguments`，将格式化后的字符串通过`write_str` 写入）。

- `SerialPort`的`Write`实现（隐含代码）：

  ```rust
  impl core::fmt::Write for SerialPort {
      fn write_str(&mut self, s: &str) -> core::fmt::Result {
          // 遍历字符串的每个字节，调用上一轮的 send 方法发送
          for byte in s.bytes() {
              self.send(byte);
          }
          Ok(())
      }
  }
  ```

  这是关键：`write_fmt`会将`Arguments`格式化为字符串，再调用`write_str`，最终通过`send`方法逐字节发送到串口。

##### （3）`expect(...)`：错误处理

- `write_fmt` 返回 `Result<(), fmt::Error>`，`expect` 用于处理错误（如果打印失败，直接 panic，适用于内核早期调试场景 —— 打印失败通常是致命错误）。
