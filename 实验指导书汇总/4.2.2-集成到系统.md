# 4.2.2：集成到系统

## 本节新增/修改文件

```
src/
├── allocator.rs        # 修改：添加 init_heap 函数
├── lib.rs              # 修改：声明 memory 模块
└── main.rs             # 修改：使用物理帧分配器
```

---

## 为什么要修改堆分配器？

在上一节中，我们实现了物理帧分配器，但它还没有被使用。目前系统仍然使用 `init_heap_simple` 直接在物理内存上初始化堆，这个函数完全不知道物理帧分配器的存在。

要让物理帧分配器真正发挥作用，我们需要修改堆分配器的初始化方式，让它通过物理帧分配器来获取物理内存。

---

## 步骤1：修改堆分配器

### 理解当前的 init_heap_simple

让我们先看看当前的堆初始化函数：

```rust
// src/allocator.rs

pub fn init_heap_simple(kernel_end_addr: usize) -> Result<(), &'static str> {
    let heap_start = align_up(kernel_end_addr, 4096);
    unsafe {
        ALLOCATOR.lock().init(heap_start, HEAP_SIZE);
    }
    Ok(())
}
```

这个函数直接在 `kernel_end` 后面初始化堆，没有通过任何分配器。这意味着：
- 物理帧分配器不知道这段内存被占用了
- 如果后续代码试图分配这段内存，会发生冲突

### 设计新的 init_heap

新的 `init_heap` 函数需要做到：
1. 接受物理帧分配器作为参数
2. 计算堆需要多少个物理帧
3. 通过分配器分配这些物理帧
4. 初始化堆分配器

为什么要预先分配物理帧？因为堆分配器需要知道自己管理的内存范围，我们必须先分配好物理内存，然后告诉堆分配器 "这段内存是你的"。

### 学生任务：实现 init_heap

> **Task 4-3**：在 `src/allocator.rs` 中添加以下代码框架，根据要求和提示完成堆初始化函数的编写，通过物理帧分配器为堆分配物理帧并初始化堆分配器。

```rust
pub fn init_heap(
    frame_allocator: &mut crate::memory::SimpleFrameAllocator,
) -> Result<(), &'static str> {
    use crate::{serial_println, memory::PAGE_SIZE};

    serial_println!("[ALLOCATOR] Initializing heap at {:#x}", HEAP_START);
    serial_println!("[ALLOCATOR] Heap size: {} bytes", HEAP_SIZE);

    // TODO: 计算堆需要的物理页数（向上取整）
    
    // TODO: 循环调用frame_allocator.allocate()分配对应数量的帧
    for _i in 0..page_count {
       
    }

    // 初始化堆分配器
    unsafe {
        ALLOCATOR.lock().init(HEAP_START, HEAP_SIZE);
    }

    serial_println!("[ALLOCATOR] Heap initialized successfully");
    Ok(())
}
```

### 理解页数计算

代码中用 `(HEAP_SIZE + PAGE_SIZE - 1) / PAGE_SIZE` 计算需要的页数，这是一个**向上取整**的公式。

为什么不能直接用 `HEAP_SIZE / PAGE_SIZE`？

假设 `HEAP_SIZE = 1 MB = 1048576 字节`：

```
直接除法：
1048576 / 4096 = 256 页（恰好整除，没问题）

但如果 HEAP_SIZE = 1048577 字节（多1个字节）：
1048577 / 4096 = 256 页（向下取整，少算了！）

向上取整：
(1048577 + 4096 - 1) / 4096
= 1052672 / 4096
= 257 页（正确！）
```

只要堆大小不是 4096 的整数倍，直接除法就会少算一页，导致堆的最后几个字节没有对应的物理内存。

### 理解循环分配

循环分配物理帧的代码：

```rust
// src/allocator.rs

for _i in 0..page_count {
    let _frame = frame_allocator.allocate()?;
}
```

这里分配了 `page_count` 个物理帧，但没有保存返回的 `PhysFrame` 对象。为什么？

因为在当前阶段，虚拟内存还没有启用，虚拟地址 = 物理地址（恒等映射）。堆分配器在虚拟地址 `HEAP_START` 处初始化，这个虚拟地址直接对应物理地址 `HEAP_START`。

我们只需要确保这段物理内存被物理帧分配器标记为 "已使用"，不需要保存具体的 `PhysFrame` 对象。

举例说明（假设 `page_count = 256`）：

```
循环第1次：分配帧 @ 0x80401000，next_frame = 525314
循环第2次：分配帧 @ 0x80402000，next_frame = 525315
...
循环第256次：分配帧 @ 0x80500000，next_frame = 525569

结果：物理帧分配器的 next_frame 从 525313 变为 525569
     这 256 个帧被标记为 "已使用"
```

### 当前阶段 vs 虚拟内存阶段

**当前阶段（物理内存管理）**：

虚拟内存尚未启用，地址空间是恒等映射的：

![p33](pictures/p4-33.png)

**虚拟内存启用后**：

虚拟地址通过页表映射到物理地址：

![p34](pictures/p4-34.png)

预分配的物理帧将在虚拟内存启用时，被映射到堆的虚拟地址空间。

---

## 步骤2：在 lib.rs 中声明模块

打开 `src/lib.rs`，找到模块声明部分，添加 `memory` 模块：

```rust
// src/lib.rs

pub mod serial;
pub mod console;
pub mod interrupts;
pub mod memory;      // 新增
pub mod allocator;
pub mod task;
```

现在可以通过 `os::memory` 访问内存管理模块了。

---

## 步骤3：在 main.rs 中集成

### 理解原来的初始化流程

原来的 `kernel_main` 函数：

```rust
// src/main.rs

pub extern "C" fn kernel_main() -> ! {
    use os::allocator;

    println!("Welcome to Error OS!");

    extern "C" { static kernel_end: u8; }
    let kernel_end_addr = unsafe { &kernel_end as *const u8 as usize };

    // 直接初始化堆
    allocator::init_heap_simple(kernel_end_addr)
        .expect("heap initialization failed");

    // ... 后续代码
}
```

这里的 `kernel_end` 是链接器脚本定义的符号，指向内核代码段的结束位置。我们需要在这个位置后面分配内存。

### 修改初始化流程

修改后的 `kernel_main` 函数：

```rust
// src/main.rs

pub extern "C" fn kernel_main() -> ! {
    use os::memory;
    use os::allocator;

    println!("Welcome to Error OS!");

    extern "C" { static kernel_end: u8; }
    let kernel_end_addr = unsafe { &kernel_end as *const u8 as usize };

    // 步骤1：初始化内存管理（包含物理帧分配器）
    let mut memory_manager = memory::init(kernel_end_addr);

    // 步骤2：使用物理帧分配器初始化堆
    allocator::init_heap(&mut memory_manager.frame_allocator)
        .expect("heap initialization failed");

    // 步骤3：测试堆分配
    let heap_value = Box::new(41);
    println!("Heap test: {:?}", heap_value);

    // ... 后续代码
}
```

### 初始化流程详解

**步骤1：初始化内存管理**

```rust
let mut memory_manager = memory::init(kernel_end_addr);
```

这一步创建了 `MemoryManager`，其内部初始化了 `SimpleFrameAllocator`：
- 计算可分配的帧范围（`next_frame` 到 `end_frame`）
- 打印内存布局信息

**步骤2：初始化堆**

```rust
allocator::init_heap(&mut memory_manager.frame_allocator)
    .expect("heap initialization failed");
```

这一步：
- 计算堆需要的页数（例如 256 页）
- 循环分配 256 个物理帧
- 初始化堆分配器

**步骤3：测试堆分配**

```rust
let heap_value = Box::new(41);
println!("Heap test: {:?}", heap_value);
```

`Box::new(41)` 会在堆上分配内存，如果能成功打印出值，说明堆分配器工作正常。

---

## 编译和测试

### 编译

在项目根目录执行：

```bash
cargo build --target riscv64gc-unknown-none-elf
```

如果编译成功，继续下一步。

### 运行

使用 QEMU 运行内核：

```bash
qemu-system-riscv64 \
    -machine virt \
    -nographic \
    -bios none \
    -kernel target/riscv64gc-unknown-none-elf/debug/os
```

### 预期输出

如果一切正常，应该看到类似的输出：

```
Welcome to Error OS!
[MEMORY] Initializing memory management
[MEMORY] Kernel end: 0x80400abc
[MEMORY] Memory range: 0x80000000 - 0x88000000
[MEMORY] Frame allocator initialized: 0x80401000 - 0x88000000
[ALLOCATOR] Initializing heap at 0x80400000
[ALLOCATOR] Heap size: 1048576 bytes
[ALLOCATOR] Allocating 256 pages for heap
[ALLOCATOR] Heap initialized successfully
Heap test: 41
```

输出解析：
- `Kernel end: 0x80400abc` - 内核代码结束地址
- `Frame allocator initialized: 0x80401000 - 0x88000000` - 可分配物理内存范围约 124 MB
- `Allocating 256 pages for heap` - 为堆分配了 256 个物理帧（1 MB）
- `Heap test: 41` - 堆分配成功

---

## 深入理解：内存管理的层次结构

### 修改前的结构

修改前，内存管理非常扁平：

```
用户程序（Box, Vec）
    ↓
堆分配器（FixedSizeBlockAllocator）
    ↓
物理内存（直接使用，无管理）
```

问题：
- 没有物理内存管理层
- 无法追踪内存使用
- 不支持虚拟内存

### 修改后的结构

修改后，有了清晰的层次：

```
用户程序（Box, Vec）
    ↓
堆分配器（FixedSizeBlockAllocator）
    ↓
物理帧分配器（SimpleFrameAllocator）
    ↓
物理内存（QEMU 128 MB）
```

优势：
- 清晰的内存管理层次
- 可追踪物理内存使用（通过 `next_frame`）
- 支持虚拟内存（可为页表分配物理帧）

### 为虚拟内存做准备

有了物理帧分配器，我们可以实现虚拟内存所需的功能：

**分配页表**（下一章）：

```rust
// 分配根页表
let root_table_frame = frame_allocator.allocate()?;
let root_table_addr = root_table_frame.start_address();

// 分配二级页表
let l1_table_frame = frame_allocator.allocate()?;
```

**按需分配物理内存**：

```rust
// 为虚拟页分配物理帧
for page in virtual_pages {
    let frame = frame_allocator.allocate()?;
    map_page(page, frame)?;  // 建立虚拟到物理的映射
}
```

**实现地址空间隔离**：

```rust
// 为不同进程分配独立的物理帧
let process_a_frames = allocate_for_process(&mut allocator, 100);
let process_b_frames = allocate_for_process(&mut allocator, 100);
```

---

## 知识点总结

本节我们完成了物理帧分配器与系统的集成。

实现的功能：
- 新的 `init_heap` 函数，使用物理帧分配器
- 系统集成（lib.rs, main.rs）
- 堆分配测试

关键概念：
- **向上取整**：`(size + PAGE_SIZE - 1) / PAGE_SIZE`
- **预分配物理帧**：为堆分配器提供物理内存
- **内存管理层次**：用户程序 → 堆分配器 → 物理帧分配器 → 物理内存

下一步：

在下一章《4.3 建立虚拟内存到物理内存的映射》中，我们将：
1. 实现虚拟地址类型（`VirtAddr`）
2. 实现三级页表结构（`PageTable`, `PageTableEntry`）
3. 实现页表遍历函数（`walk_page_table`）
4. 实现页面映射函数（`map_page`, `unmap_page`）
5. 激活虚拟内存（写入 `satp` 寄存器）
