# 4.6：从物理内存管理到虚拟内存管理的代码实现

## 引言

在前面的章节中，我们理解了：
- **第1节**：为什么需要虚拟内存
- **第2节**：物理帧分配器的实现
- **第3节**：建立虚拟内存到物理内存的映射、TLB加速地址转换、大页机制

现在，我们将在前3节的基础上，通过编写一个**页表测试函数**来驱动虚拟内存功能的实现。我们将从 `main.rs` 开始，按照实际使用需求，逐步构建所需的类型和函数。


## 实现思路：从使用到定义

1. **从 main.rs 开始**：编写页表测试函数，定义我们需要什么功能
2. **遇到缺少的类型/函数**：去 memory 模块实现它
3. **返回 main.rs**：继续编写测试代码
4. **循环往复**：直到完成所有功能


---

## 步骤1：在 main.rs 中创建测试函数框架

打开 `src/main.rs`，在 `kernel_main` 函数中添加测试函数调用：

### 在 kernel_main 中调用测试函数

找到 `kernel_main` 函数，在堆分配器初始化后添加：

```rust
pub extern "C" fn kernel_main() -> ! {
    use os::memory;
    use os::allocator;

    println!("Welcome to Error OS!");

    extern "C" {
        static kernel_end: u8;
    }
    let kernel_end_addr = unsafe { &kernel_end as *const u8 as usize };

    // 初始化内存管理
    let mut memory_manager = memory::init(kernel_end_addr);

    // 初始化堆分配器
    allocator::init_heap(&mut memory_manager.frame_allocator)
        .expect("heap initialization failed");

    // 测试堆分配
    let heap_value = Box::new(41);
    println!("Heap test: {:?}", heap_value);

    // ======== 新增：测试页表功能 ========
    test_page_table_features(&mut memory_manager);
    // ===================================

    println!("Kernel execution completed!");
    os::hlt_loop();
}
```

### 创建测试函数框架

在 `kernel_main` 函数后面添加测试函数：

```rust
/// 测试页表功能
fn test_page_table_features(memory_manager: &mut os::memory::MemoryManager) {
    println!("\n[1] 创建测试页表...");

    // 分配一个物理帧作为页表
    let test_page_table_frame = memory_manager.frame_allocator
        .allocate()
        .expect("Failed to allocate page table");

    // TODO: 将物理帧转换为页表
    // TODO: 创建虚拟地址和物理地址
    // TODO: 调用 map_page 建立映射
    // TODO: 调用 walk_page_table 验证映射

    println!("页表测试完成！");
}
```

**当前进度**：我们有了测试函数框架，但缺少：
- `PageTable` 类型
- `VirtAddr` 和 `PhysAddr` 的虚拟地址（第3章只有物理地址）
- `map_page` 和 `walk_page_table` 函数

---

## 步骤2：实现 PageTable 类型

回到测试函数，我们需要将物理帧转换为页表。这需要 `PageTable` 类型。

### test_page_table_features（main.rs）

我们希望在测试函数中这样写：

```rust
// 将物理帧转换为页表指针
let test_page_table = unsafe {
    &mut *(test_page_table_frame.start_address().as_usize() as *mut PageTable)
};
test_page_table.zero();
```



### 实现 PageTable（memory/mod.rs）

打开 `src/memory/mod.rs`，在文件中添加页表相关的常量和类型。

#### 添加常量

在 `PAGE_SIZE` 常量后面添加：

```rust
/// 页大小（4KB）
pub const PAGE_SIZE: usize = 4096;

/// 页表项数量（新增）
pub const PAGE_TABLE_ENTRIES: usize = 512;
```

**说明**：Sv39 页表包含 512 个条目（2⁹ = 512）

#### 定义页表项

```rust
/// 页表项（64 位）
#[repr(transparent)]
#[derive(Clone, Copy)]
pub struct PageTableEntry {
    entry: usize,
}

impl PageTableEntry {
    /// 创建空的页表项
    pub const fn new() -> Self {
        PageTableEntry { entry: 0 }
    }
}
```

**说明**：
- 页表项是 64 位（8 字节）
- `#[repr(transparent)]`：保证内存布局与 `usize` 一致
- 初始值为 0 表示无效

#### 定义页表

```rust
/// 页表（512 个条目，4KB 对齐）
#[repr(align(4096))]
pub struct PageTable {
    entries: [PageTableEntry; PAGE_TABLE_ENTRIES],
}

impl PageTable {
    /// 创建新的空页表
    pub const fn new() -> Self {
        PageTable {
            entries: [PageTableEntry::new(); PAGE_TABLE_ENTRIES],
        }
    }

    /// 清空页表
    pub fn zero(&mut self) {
        for entry in self.entries.iter_mut() {
            *entry = PageTableEntry::new();
        }
    }
}
```

**关键点**：
- `#[repr(align(4096))]`：页表必须 4 KB 对齐（RISC-V 硬件要求）
- `entries` 数组：512 个条目 × 8 字节 = 4096 字节 = 1 个物理页帧
- `zero()` 方法：将所有页表项清零

### 为什么使用 unsafe？

回到测试函数中的代码：

```rust
let test_page_table = unsafe {
    &mut *(test_page_table_frame.start_address().as_usize() as *mut PageTable)
};
```

**解释**：
- 我们将物理地址（`usize`）转换为指针（`*mut PageTable`）
- 这个操作是 `unsafe` 的，因为：
  1. Rust 无法验证这个地址是否有效
  2. Rust 无法验证是否有其他引用指向同一内存
  3. 我们需要保证该地址指向的内存已经分配且有效

**但在这里是安全的**：
- 我们刚刚通过 `frame_allocator.allocate()` 分配了这个物理帧
- 物理帧的地址一定是有效的
- 我们是唯一持有这个引用的代码

---

## 步骤3：实现 VirtAddr 类型

继续编写测试函数，我们需要创建虚拟地址和物理地址：

### test_page_table_features（main.rs）

```rust
let vaddr = VirtAddr::new(0x1000_0000);  // 虚拟地址
let paddr = PhysAddr::new(0x8100_0000);  // 物理地址
```



### VirtAddr（memory/mod.rs）

在 `PhysAddr` 定义之前添加虚拟地址类型：

```rust
/// RISC-V Sv39 虚拟地址
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
#[repr(transparent)]
pub struct VirtAddr(usize);

impl VirtAddr {
    /// 创建新的虚拟地址
    pub const fn new(addr: usize) -> Self {
        VirtAddr(addr)
    }

    /// 获取地址值
    pub const fn as_usize(self) -> usize {
        self.0
    }

    /// 获取可变指针
    pub fn as_mut_ptr<T>(self) -> *mut T {
        self.0 as *mut T
    }
}
```


### 添加 VPN 提取方法

虚拟地址需要提取三级页表的索引（VPN）和页内偏移：

```rust
impl VirtAddr {
    /// 获取页偏移（低 12 位）
    pub const fn page_offset(self) -> usize {
        self.0 & 0xFFF
    }

    /// 获取 VPN[0]（12-20 位）
    pub const fn vpn0(self) -> usize {
        (self.0 >> 12) & 0x1FF
    }

    /// 获取 VPN[1]（21-29 位）
    pub const fn vpn1(self) -> usize {
        (self.0 >> 21) & 0x1FF
    }

    /// 获取 VPN[2]（30-38 位）
    pub const fn vpn2(self) -> usize {
        (self.0 >> 30) & 0x1FF
    }
}
```

**说明**：
- `page_offset()`：提取低 12 位，用于在 4 KB 页内定位字节
- `vpn0()`、`vpn1()`、`vpn2()`：提取三级页表的索引
- `0x1FF = 0b1_1111_1111`：9 位掩码

**示例**：
```
虚拟地址：0x12345678
VPN[2] = (0x12345678 >> 30) & 0x1FF = 0
VPN[1] = (0x12345678 >> 21) & 0x1FF = 145
VPN[0] = (0x12345678 >> 12) & 0x1FF = 69
Offset = 0x12345678 & 0xFFF = 0x678
```

---

## 步骤4：实现页表标志位

继续测试函数，我们需要设置页表项的标志位：

### test_page_table_features（main.rs）

```rust
let flags = PageTableFlags::Read as usize
    | PageTableFlags::Write as usize
    | PageTableFlags::Valid as usize;
```


### PageTableFlags（memory/mod.rs）

在 `PageTableEntry` 定义之前添加：

```rust
/// 页表项标志位
#[repr(u64)]
#[derive(Debug, Clone, Copy)]
pub enum PageTableFlags {
    Valid = 1 << 0,      // V: 有效位
    Read = 1 << 1,       // R: 可读
    Write = 1 << 2,      // W: 可写
    Execute = 1 << 3,    // X: 可执行
    User = 1 << 4,       // U: 用户可访问
    Global = 1 << 5,     // G: 全局映射
    Accessed = 1 << 6,   // A: 访问位
    Dirty = 1 << 7,      // D: 脏位
}
```

**说明**：
- 这些标志位对应 RISC-V Sv39 页表项的低 8 位
- 可以通过按位或（`|`）组合多个标志

**常见组合**：
```rust
// 代码段：可读、可执行，不可写
PageTableFlags::Read | PageTableFlags::Execute

// 数据段：可读、可写，不可执行
PageTableFlags::Read | PageTableFlags::Write
```

---

## 步骤5：实现 map_page 函数

现在我们要调用 `map_page` 来建立虚拟地址到物理地址的映射：

### test_page_table_features（main.rs）

```rust
use os::memory::map_page;

match map_page(
    test_page_table,
    vaddr,
    paddr,
    flags,
    &mut memory_manager.frame_allocator
) {
    Ok(_) => println!("✓ 页面映射成功"),
    Err(e) => println!("✗ 页面映射失败: {}", e),
}
```

**问题**：
- `map_page` 函数不存在
- 需要在 `memory/paging.rs` 中实现

### 创建 paging.rs 文件

创建 `src/memory/paging.rs` 文件。

#### 添加模块声明

在 `src/memory/mod.rs` 文件开头添加：

```rust
pub mod paging;
```

#### 导入必要类型

在 `src/memory/paging.rs` 中添加：

```rust
use super::{
    PhysAddr, VirtAddr, PageTable, PageTableEntry,
    PageTableFlags, PhysFrame, SimpleFrameAllocator, PAGE_SIZE
};
```

### 实现 PageTableEntry 的核心方法

在实现 `map_page` 之前，我们需要给 `PageTableEntry` 添加一些方法。

回到 `src/memory/mod.rs`，在 `PageTableEntry` 的 `impl` 块中添加：

> **Task 4-4:** 又有些地方需要你来动动小手填空了，根据给出的提示和你的理解补完下面的代码

```rust
impl PageTableEntry {
    /// 创建空的页表项
    pub const fn new() -> Self {
        PageTableEntry { entry: 0 }
    }

    /// 判断是否有效
    pub fn is_valid(&self) -> bool {
        (self.entry & 1) != 0
    }

    /// TODO: 判断是否为叶子节点（映射到物理页）
    /// 提示：R/W/X 任意一位为 1→ 表达式 ≠ 0 → 返回 true（叶子节点）；
    /// R/W/X 全为 0 → 表达式 = 0 → 返回 false（中间节点）；
    pub fn is_leaf(&self) -> bool {
        (self.entry & ) != 0 
    }

    /// 获取物理页号（PPN）
    pub fn ppn(&self) -> usize {
        (self.entry >> 10) & 0xFFF_FFFF_FFFF 
    }

    /// 获取物理地址
    pub fn phys_addr(&self) -> PhysAddr {
        PhysAddr::new(self.ppn() << 12)
    }

    /// TODO：设置页表项
    /// 提示：初始化一个有效的页表项，传入「物理页号」和「标志位」，组合成完整的 64 位页表项；
    pub fn set(&mut self, ppn: usize, flags: usize) {
        self.entry = 
    }
}
```

**关键方法**：
- `is_valid()`：检查 V 位（第 0 位）
- `is_leaf()`：检查 R/W/X 位，任意一位为 1 表示叶子节点
- `ppn()`：提取 44 位物理页号（第 10-53 位）
- `phys_addr()`：将 PPN 左移 12 位得到物理地址
- `set()`：设置页表项

**页表项结构**：
```
64 位页表项：
┌───────────┬──────────────────────────┬────┬──────────────────┐
│  保留位    │  物理页号（PPN）           │RSW │   标志位          │
│ (10 bits) │    (44 bits)             │(2) │  (8 bits)        │
└───────────┴──────────────────────────┴────┴──────────────────┘
 63       54 53                      10 9  8  7 6 5 4 3 2 1 0
                                              D A G U X W R V
```

### 添加 PageTable 的访问方法

在 `src/memory/mod.rs` 的 `PageTable` 实现中添加：

```rust
impl PageTable {
    /// 创建新的空页表
    pub const fn new() -> Self {
        PageTable {
            entries: [PageTableEntry::new(); PAGE_TABLE_ENTRIES],
        }
    }

    /// 获取页表项
    pub fn get_entry(&self, index: usize) -> &PageTableEntry {
        &self.entries[index]
    }

    /// 获取可变页表项
    pub fn get_entry_mut(&mut self, index: usize) -> &mut PageTableEntry {
        &mut self.entries[index]
    }

    /// 清空页表
    pub fn zero(&mut self) {
        for entry in self.entries.iter_mut() {
            *entry = PageTableEntry::new();
        }
    }
}
```

### 实现 map_page（memory/paging.rs）

> **Task 4-5: **回到 `src/memory/paging.rs`，map_page函数的核心作用是将一个虚拟地址（`vaddr`）映射到物理地址（`paddr`），遵循 RISC-V 三级页表（Level 2 → Level 1 → Level 0）的分层结构。请根据提示完成页表映射实现

```rust
/// 映射单个页面
///
/// # 功能
/// 建立虚拟地址到物理地址的映射，自动分配中间页表
///
/// # 参数
/// - `root_table`: 根页表（可变引用）
/// - `vaddr`: 虚拟地址
/// - `paddr`: 物理地址
/// - `flags`: 页表标志位
/// - `allocator`: 帧分配器（用于分配中间页表）
pub fn map_page(
    root_table: &mut PageTable,
    vaddr: VirtAddr,
    paddr: PhysAddr,
    flags: usize,
    allocator: &mut SimpleFrameAllocator,
) -> Result<(), &'static str> {
    // 第1步：获取或创建 Level 1 页表
    let vpn2 = vaddr.vpn2();
    let pte2 = root_table.get_entry_mut(vpn2);

    let table1 = if !pte2.is_valid() {
        // Level 1 页表不存在，需要分配
        let frame = allocator.allocate().ok_or("Out of memory")?;
        let table1_paddr = frame.start_address();

        // TODO: 设置页表项：指向下一级页表，只设置 Valid 位
        // 提示： 传入Level1页表的PPN和vaild
        pte2.set(, );

        // 清空新页表
        let table1 = unsafe {
            &mut *(table1_paddr.as_usize() as *mut PageTable)
        };
        table1.zero();
        table1
    } else {
        // Level 1 页表已存在，直接使用
        unsafe {
            &mut *(pte2.phys_addr().as_usize() as *mut PageTable)
        }
    };

    // 第2步：获取或创建 Level 0 页表
    let vpn1 = vaddr.vpn1();
    let pte1 = table1.get_entry_mut(vpn1);

    let table0 = if !pte1.is_valid() {
        // TODO: 完成Level 0页表的创建
        // 提示： 参考Level 1的分配和设置逻辑
    } else {
        unsafe {
            &mut *(pte1.phys_addr().as_usize() as *mut PageTable)
        }
    };

    // 第3步：设置最终映射
    let vpn0 = vaddr.vpn0();
    let pte0 = table0.get_entry_mut(vpn0);

    if pte0.is_valid() {
        return Err("Page already mapped");
    }

    // 设置叶子页表项：物理地址 + 标志位
    pte0.set(paddr.as_usize() >> 12, flags | PageTableFlags::Valid as usize);

    // 第4步：刷新 TLB
    unsafe {
        core::arch::asm!(
            "sfence.vma {0}, zero",
            in(reg) vaddr.as_usize(),
        );
    }

    Ok(())
}
```

**关键点**：

1. **三级页表遍历**：VPN[2] → VPN[1] → VPN[0]
2. **按需分配**：如果中间页表不存在，自动分配
3. **清空新页表**：避免随机数据导致错误
4. **刷新 TLB**：使用 `sfence.vma` 指令，确保新映射立即生效

**映射过程**：
```
虚拟地址 0x10000000
    ↓
VPN[2]=0 → 根页表[0] → 如果无效，分配 Level 1 页表
    ↓
VPN[1]=256 → Level 1 页表[256] → 如果无效，分配 Level 0 页表
    ↓
VPN[0]=0 → Level 0 页表[0] → 设置映射到物理地址
    ↓
物理地址 = PPN << 12
```

### 在 mod.rs 中重新导出

在 `src/memory/mod.rs` 文件末尾添加：

```rust
// 重新导出页表管理函数
pub use paging::map_page;
```

---

## 步骤6：实现 walk_page_table 函数

测试函数中，我们需要验证映射是否成功：

### test_page_table_features（main.rs）

```rust
use os::memory::walk_page_table;

let root_paddr = test_page_table_frame.start_address();

match walk_page_table(root_paddr, vaddr) {
    Some(result_paddr) => {
        if result_paddr.as_usize() == paddr.as_usize() {
            println!("✓ 地址转换验证成功!");
        }
    }
    None => println!("✗ 页面未映射"),
}
```

**问题**：
- `walk_page_table` 函数不存在

### 学生任务：实现 walk_page_table（memory/paging.rs）

> **Task 4-6**：在 `src/memory/paging.rs` 中添加以下代码框架，并且根据提示发动你的小脑筋编写完整页表遍历逻辑
>
> 要求：根据虚拟地址三级 VPN 遍历页表，返回对应的物理地址，支持大页（1GB/2MB）。
>
> 提示：
>
> 1. 从根页表开始，依次检查 Level 2 → Level 1 → Level 0 页表项的有效性。
>
> 2. 若某级页表项是叶子节点（`is_leaf()` 为真），直接计算大页物理地址。
>
> 3. 最终物理地址 = 页表项指向的物理页基地址 + 页内偏移。

```rust
/// 遍历页表，将虚拟地址转换为物理地址
///
/// # 功能
/// 执行三级页表遍历，查找虚拟地址对应的物理地址
///
/// # 参数
/// - root_paddr: 根页表的物理地址
/// - vaddr: 要转换的虚拟地址
///
/// # 返回
/// - Some(PhysAddr): 转换成功，返回物理地址
/// - None: 页面未映射
pub fn walk_page_table(root_paddr: PhysAddr, vaddr: VirtAddr) -> Option<PhysAddr> {
    // 第1步：获取根页表
    let root_table = unsafe {
        &*(root_paddr.as_usize() as *const PageTable)
    };

    // 第2步：Level 2 查找
    // TODO: 获取 pte2，检查有效性，判断是否为大页
    
    // 第3步：Level 1 查找
    // TODO: 获取 table1，检查 pte1，判断是否为大页
    
    // 第4步：Level 0 查找
    // TODO: 获取 table0，检查 pte0，计算最终物理地址
    

    // 第5步：计算最终物理地址
    let offset = vaddr.page_offset();
    Some(PhysAddr::new(pte0.phys_addr().as_usize() + offset))
}
```

**关键点**：
- 三级遍历：Level 2 → Level 1 → Level 0
- 每级检查有效性和是否为叶子节点（大页）
- 最终物理地址 = 物理页帧起始地址 + 页内偏移
- 支持 1GB、2MB、4KB 三种页大小

###  在 mod.rs 中重新导出

在 `src/memory/mod.rs` 文件的重新导出部分添加：

```rust
// 重新导出页表管理函数
pub use paging::{map_page, walk_page_table};
```

---

## 步骤7：完整的测试函数

现在我们已经实现了所有需要的功能，可以完成测试函数了：

```rust
/// 测试页表功能
fn test_page_table_features(memory_manager: &mut os::memory::MemoryManager) {
    use os::memory::{VirtAddr, PhysAddr, PageTable, PageTableFlags};
    use os::memory::{map_page, walk_page_table};

    println!("\n========================================");
    println!("  开始测试页表功能");
    println!("========================================\n");

    println!("[1] 创建测试页表...");

    // 分配一个物理帧作为页表
    let test_page_table_frame = memory_manager.frame_allocator
        .allocate()
        .expect("Failed to allocate page table");

    // 将物理帧转换为页表
    let test_page_table = unsafe {
        &mut *(test_page_table_frame.start_address().as_usize() as *mut PageTable)
    };
    test_page_table.zero();

    println!("    ✓ 页表已创建\n");

    // 测试1：映射一个页面
    println!("[2] 测试页面映射...");
    let vaddr = VirtAddr::new(0x1000_0000);  // 虚拟地址
    let paddr = PhysAddr::new(0x8100_0000);  // 物理地址

    let flags = PageTableFlags::Read as usize
        | PageTableFlags::Write as usize
        | PageTableFlags::Valid as usize;

    match map_page(
        test_page_table,
        vaddr,
        paddr,
        flags,
        &mut memory_manager.frame_allocator
    ) {
        Ok(_) => println!("    ✓ 页面映射成功\n"),
        Err(e) => println!("    ✗ 页面映射失败: {}\n", e),
    }

    // 测试2：遍历页表验证映射
    println!("[3] 测试页表遍历...");
    let root_paddr = test_page_table_frame.start_address();

    match walk_page_table(root_paddr, vaddr) {
        Some(result_paddr) => {
            if result_paddr.as_usize() == paddr.as_usize() {
                println!("    ✓ 地址转换验证成功!\n");
            } else {
                println!("    ✗ 地址转换错误\n");
            }
        }
        None => println!("    ✗ 页面未映射\n"),
    }

    // 测试3：映射多个页面
    println!("[4] 映射多个连续页面...");
    for i in 0..3 {
        let v = VirtAddr::new(0x2000_0000 + i * 0x1000);
        let p = PhysAddr::new(0x8200_0000 + i * 0x1000);

        match map_page(
            test_page_table,
            v,
            p,
            flags,
            &mut memory_manager.frame_allocator
        ) {
            Ok(_) => {},
            Err(e) => println!("    ✗ 页面 {} 映射失败: {}", i, e),
        }
    }
    println!("    ✓ 所有页面映射成功\n");

    println!("========================================");
    println!("  页表功能测试完成！");
    println!("========================================\n");
}
```


## 总结

通过本章的学习，我们从 `main.rs` 的测试函数出发，逐步实现了虚拟内存管理的核心功能。

### 实现路径回顾

```
1. main.rs (test_page_table_features)
   ↓ 需要 PageTable
2. memory/mod.rs (实现 PageTable)
   ↓ 需要 VirtAddr
3. memory/mod.rs (实现 VirtAddr)
   ↓ 需要 PageTableFlags
4. memory/mod.rs (实现 PageTableFlags)
   ↓ 需要 map_page
5. memory/paging.rs (实现 map_page)
   ↓ 需要 walk_page_table
6. memory/paging.rs (实现 walk_page_table)
   ↓ 需要 AddressSpace
7. memory/address_space.rs (实现 AddressSpace)
   ↓
8. 完成！
```


### 核心技术点

1. **三级页表遍历**：VPN[2] → VPN[1] → VPN[0] → 物理地址
2. **按需分配**：映射时自动分配中间页表
3. **TLB 管理**：使用 `sfence.vma` 刷新 TLB
4. **类型安全**：虚拟地址和物理地址使用不同类型
5. **恒等映射**：内核代码段使用恒等映射

