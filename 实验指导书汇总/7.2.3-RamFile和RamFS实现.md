# 7.2.3 RamFile和RamFS实现

## 本节目标

- 理解RamFile的作用
- 实现RamFile文件句柄
- 实现File trait（read/write/seek）
- 实现RamFS文件系统
- 实现文件和目录的创建、删除、打开

---

## 前置要求

- 已完成 7.2.1 节的 RamInode 设计和文件读写
- 已完成 7.2.2 节的目录操作实现

---

## 步骤1：理解RamFile的作用

### 1.1 为什么需要RamFile？

**问题**：如果直接使用RamInode会怎样？

```rust
// 错误示例：直接使用RamInode
let inode = ramfs.get_inode(...);
inode.lock().read_at(0, &mut buf)?;  // 从0开始读
inode.lock().read_at(0, &mut buf)?;  // 还是从0开始读
// 每次都要手动指定offset
```

**解决方案**：RamFile包装RamInode，自动维护offset

```rust
// 正确示例：使用RamFile
let mut file = ramfs.open_file(...);
file.read(&mut buf)?;  // 从offset=0读，自动更新offset
file.read(&mut buf)?;  // 从新offset继续读
// offset自动维护
```

### 1.2 RamInode vs RamFile

```
RamInode（文件本身）:
  - 存储文件数据
  - 无状态（没有offset）
  - 可以被多次打开

RamFile（打开的文件）:
  - 引用RamInode
  - 有状态（维护offset）
  - 每次打开创建新的RamFile
```

**类比**：
- **RamInode** - 像一本书
- **RamFile** - 像书签，记录你读到哪一页了

### 1.3 同一文件多次打开

```rust
let inode = ramfs.lookup(root, "test.txt")?;

// 第一次打开
let mut file1 = RamFile::new(inode.clone());
file1.read(&mut buf)?;  // offset = 0 -> N

// 第二次打开
let mut file2 = RamFile::new(inode.clone());
file2.read(&mut buf)?;  // offset = 0 -> N (独立的offset)
```

---

## 步骤2：实现RamFile结构

### 2.1 定义RamFile结构

在 `os/src/fs/ramfs.rs` 中继续添加：

**文件路径：`os/src/fs/ramfs.rs`**

```rust
/// RamFS文件句柄
///
/// 包装RamInode并维护当前offset
pub struct RamFile {
    inode: Arc<Mutex<RamInode>>,
    offset: usize,  // 当前读写位置
}

impl RamFile {
    pub fn new(inode: Arc<Mutex<RamInode>>) -> Self {
        RamFile { inode, offset: 0 }
    }
}
```

**字段说明**：

- `inode` - 指向RamInode的智能指针
- `offset` - 当前读写位置，每次read/write后自动更新

---

## 步骤3：实现File trait

### 3.1 实现File trait的所有方法

**重要说明**：File trait的所有方法必须在同一个 `impl File for RamFile` 块中实现，不能分散在多个impl块中。

**文件路径：`os/src/fs/ramfs.rs`**

```rust
impl File for RamFile {
    /// 从当前offset读取
    fn read(&mut self, buf: &mut [u8]) -> Result<usize, FileError> {
        let n = self.inode.lock().read_at(self.offset, buf)?;
        self.offset += n;  // 更新offset
        Ok(n)
    }

    /// 向当前offset写入
    fn write(&mut self, buf: &[u8]) -> Result<usize, FileError> {
        let n = self.inode.lock().write_at(self.offset, buf)?;
        self.offset += n;  // 更新offset
        Ok(n)
    }

    /// 移动到新位置
    fn seek(&mut self, pos: SeekFrom) -> Result<usize, FileError> {
        // 见下方的"[任务] 实现seek方法"
        todo!("Implement seek - 任务点7-1")
    }
}
```

### 3.2 read方法工作流程

```
1. 调用RamInode::read_at(offset, buf)
2. 获取实际读取的字节数n
3. offset += n
4. 返回n
```

### 3.3 write方法工作流程

```
1. 调用RamInode::write_at(offset, buf)
2. 获取实际写入的字节数n
3. offset += n
4. 返回n
```

### 3.4 seek算法详解

```
文件大小: 100字节
当前offset: 50

SeekFrom::Start(10):
  new_offset = 10
  结果: offset = 10

SeekFrom::Current(5):
  delta = 5 (正数)
  new_offset = 50 + 5 = 55
  结果: offset = 55

SeekFrom::Current(-20):
  delta = -20 (负数)
  new_offset = 50 - 20 = 30
  结果: offset = 30

SeekFrom::Current(-60):
  delta = -60 (负数)
  saturating_sub: 50 - 60 = 0 (不会下溢)
  结果: offset = 0

SeekFrom::End(0):
  delta = 0
  new_offset = 100
  结果: offset = 100 (文件末尾)

SeekFrom::End(-10):
  delta = -10 (负数)
  new_offset = 100 - 10 = 90
  结果: offset = 90
```

### 3.5 saturating_sub安全减法

**为什么需要saturating_sub？**

```rust
// 普通减法：会panic
let x: usize = 5;
let y = x - 10;  // panic: attempt to subtract with overflow

// saturating_sub：返回0
let x: usize = 5;
let y = x.saturating_sub(10);  // y = 0
```

**使用场景**：

```rust
// 向前seek超过文件开头
file.seek(SeekFrom::Current(-1000))?;
// 结果：offset = 0（而不是panic）
```

### 3.6 [任务] 实现seek方法（任务点7-1，4分）

现在请你实现 `seek` 方法！根据上面的算法讲解，完成以下实现：

**文件位置**：`os/src/fs/ramfs.rs`（在File trait实现块中）

**实现要求**：

1. **获取文件大小**：使用 `self.inode.lock().size()`
2. **处理三种SeekFrom模式**：
   - `Start(offset)`：直接设置为offset
   - `Current(delta)`：从当前位置偏移（注意正负号）
   - `End(delta)`：从文件末尾偏移（注意正负号）
3. **使用saturating_sub**：防止负数溢出
4. **更新self.offset**：保存新位置
5. **返回新offset**：`Ok(self.offset)`

**思考题**：
1. 为什么`Current`和`End`的delta是`isize`而不是`usize`？
2. 如果seek到超出文件末尾的位置会发生什么？
3. 为什么需要`saturating_sub`而不是普通减法？

```rust
/// 调整文件的读取/写入偏移量（支持从开头、当前位置、末尾偏移）
/// # 参数
/// - pos: 偏移量的计算方式（SeekFrom枚举：Start/Current/End）
/// # 返回值
/// - Ok(new_offset): 调整后的新偏移量
/// - Err: 仅当底层inode操作出错时返回（本方法核心逻辑无额外错误）
fn seek(&mut self, pos: SeekFrom) -> Result<usize, FileError> {
    // 【步骤1】获取文件总大小：通过self.inode.lock()获取inode锁，再调用size()方法
    // 提示：这一步已给出核心代码，需补全变量定义

    // 【步骤2】根据SeekFrom的不同类型，计算新的偏移量new_offset：
    // 子步骤2.1: SeekFrom::Start(offset) → 直接使用传入的offset作为新偏移量
    // 子步骤2.2: SeekFrom::Current(delta) → 基于当前偏移量(self.offset)加减delta：
    //   - delta为正数：new_offset = self.offset + delta（转为usize）
    //   - delta为负数：new_offset = self.offset 减去delta的绝对值（注意避免下溢，用saturating_sub）
    // 子步骤2.3: SeekFrom::End(delta) → 基于文件末尾（size）加减delta：
    //   - delta为正数：new_offset = size + delta（转为usize）
    //   - delta为负数：new_offset = size 减去delta的绝对值（注意避免下溢，用saturating_sub）
    // 提示：saturating_sub是usize的安全减法，下溢时返回0

    // 【步骤3】更新文件的当前偏移量：将计算出的new_offset赋值给self.offset

    // 【步骤4】返回调整后的新偏移量（Ok(new_offset)）
}
```

**验证方法**：

完成后，确保代码可以编译：
```bash
cd os
cargo check
```

参考示例代码查看完整实现（初版指导书或测试代码）。

---

## 步骤4：实现RamFS文件系统

### 4.1 RamFS结构定义

**文件路径：`os/src/fs/ramfs.rs`**

```rust
/// RamFS文件系统
///
/// 管理inode分配和根目录
pub struct RamFS {
    root: Arc<Mutex<RamInode>>,  // 根目录
    next_ino: Mutex<usize>,      // 下一个可用的inode号
}
```

**设计要点**：

- `root` - 根目录（Inode 1）
- `next_ino` - Inode号生成器（从2开始）

### 4.2 初始化方法

**文件路径：`os/src/fs/ramfs.rs`**

```rust
impl RamFS {
    pub fn new() -> Self {
        let root = Arc::new(Mutex::new(RamInode::new_directory(1)));
        RamFS {
            root,
            next_ino: Mutex::new(2),  // 1已分配给root
        }
    }

    fn alloc_ino(&self) -> usize {
        let mut next = self.next_ino.lock();
        let ino = *next;
        *next += 1;
        ino
    }

    pub fn root(&self) -> Arc<Mutex<RamInode>> {
        self.root.clone()
    }
}
```

### 4.3 Inode分配过程

```
初始化:
  root -> Inode 1
  next_ino = 2

创建第1个文件:
  alloc_ino() -> 2
  next_ino -> 3

创建第2个文件:
  alloc_ino() -> 3
  next_ino -> 4
```

---

## 步骤5：实现文件和目录操作

### 5.1 创建文件的设计思路

创建文件需要完成以下几步：

1. **分配Inode号**：调用 `alloc_ino()` 获取新的Inode编号
2. **创建RamInode**：使用 `RamInode::new_file(ino)` 创建文件Inode
3. **包装为智能指针**：使用 `Arc::new(Mutex::new(...))` 实现共享和线程安全
4. **添加到父目录**：调用 `parent.lock().add_entry(name, inode.clone())?`
5. **返回Inode引用**：返回 `Ok(inode)`

**完整流程图**：

```
调用 create_file(parent, "test.txt")
  ↓
alloc_ino() -> 5
  ↓
RamInode::new_file(5)
  ↓
Arc::new(Mutex::new(...))
  ↓
parent.entries.insert("test.txt", inode)
  ↓
返回 Ok(inode)
```

### 5.2 [任务] 实现create_file方法（任务点7-2，3分）

现在请你实现 `create_file` 方法！

**文件位置**：`os/src/fs/ramfs.rs`（在RamFS实现块中）

**方法签名**：

```rust
pub fn create_file(
    &self,
    parent: Arc<Mutex<RamInode>>,
    name: String,
) -> Result<Arc<Mutex<RamInode>>, FileError>
```

**实现要求**：

1. **分配Inode号**：`let ino = self.alloc_ino();`
2. **创建RamInode**：`let inode = Arc::new(Mutex::new(RamInode::new_file(ino)));`
3. **添加到父目录**：`parent.lock().add_entry(name, inode.clone())?;`
4. **返回结果**：`Ok(inode)`

**思考题**：
1. 为什么需要 `inode.clone()` 而不是直接传 `inode`？
2. 如果父目录已经有同名文件会发生什么？
3. 为什么返回值是 `Arc<Mutex<RamInode>>` 而不是 `RamInode`？

**代码框架**（参考代码中的TODO注释）：

```rust
pub fn create_file(
    &self,
    parent: Arc<Mutex<RamInode>>,
    name: String,
) -> Result<Arc<Mutex<RamInode>>, FileError> {
    // Step 1: 分配Inode号
    let ino = self.alloc_ino();

    // Step 2: 创建RamInode并包装
    let inode = Arc::new(Mutex::new(RamInode::new_file(ino)));

    // Step 3: 添加到父目录
    parent.lock().add_entry(name, inode.clone())?;

    // Step 4: 返回Inode引用
    Ok(inode)
}
```

**验证方法**：

完成后测试文件创建：
```bash
cd os
cargo check
```

参考初版指导书查看完整实现。

### 5.3 create_directory的参考实现

**文件路径：`os/src/fs/ramfs.rs`**

```rust
impl RamFS {
    /// 在父目录中创建目录
    pub fn create_directory(
        &self,
        parent: Arc<Mutex<RamInode>>,
        name: String,
    ) -> Result<Arc<Mutex<RamInode>>, FileError> {
        let ino = self.alloc_ino();
        let inode = Arc::new(Mutex::new(RamInode::new_directory(ino)));
        parent.lock().add_entry(name, inode.clone())?;
        Ok(inode)
    }
}
```

**与create_file的区别**：

- `new_file(ino)` vs `new_directory(ino)`
- 权限不同：`0o644` vs `0o755`
- file_type不同：`RegularFile` vs `Directory`

### 5.3 删除文件/目录

**文件路径：`os/src/fs/ramfs.rs`**

```rust
impl RamFS {
    /// 删除文件或目录
    ///
    /// # 注意
    /// 删除目录前必须为空
    pub fn remove(
        &self,
        parent: Arc<Mutex<RamInode>>,
        name: &str,
    ) -> Result<(), FileError> {
        parent.lock().remove_entry(name)
    }
}
```

### 5.4 查找文件

**文件路径：`os/src/fs/ramfs.rs`**

```rust
impl RamFS {
    /// 在目录中查找文件
    pub fn lookup(
        &self,
        parent: Arc<Mutex<RamInode>>,
        name: &str,
    ) -> Result<Arc<Mutex<RamInode>>, FileError> {
        parent.lock().lookup(name)
    }
}
```

### 5.5 打开文件

**文件路径：`os/src/fs/ramfs.rs`**

```rust
impl RamFS {
    /// 打开文件用于读写
    ///
    /// # 错误
    /// * IsDirectory - 不能将目录作为文件打开
    pub fn open_file(
        &self,
        inode: Arc<Mutex<RamInode>>,
    ) -> Result<RamFile, FileError> {
        let file_type = inode.lock().file_type();
        if file_type != FileType::RegularFile {
            return Err(FileError::IsDirectory);
        }
        Ok(RamFile::new(inode))
    }
}
```

**检查点**：只能打开普通文件，不能打开目录

```rust
// 正确
let file_inode = ramfs.lookup(root, "test.txt")?;
let file = ramfs.open_file(file_inode)?;

// 错误
let dir_inode = ramfs.lookup(root, "mydir")?;
let file = ramfs.open_file(dir_inode)?;  // Error: IsDirectory
```

---

## 知识点总结

### RamFile vs RamInode

| 概念 | RamInode | RamFile |
|------|----------|---------|
| 作用 | 文件本身 | 打开的文件句柄 |
| 状态 | 无状态 | 有状态（offset） |
| 生命周期 | 文件存在期间 | 打开到关闭 |
| 数量 | 一个文件一个 | 可以多次打开 |

### RamFS核心方法

| 方法 | 作用 | 返回值 |
|------|------|--------|
| create_file | 创建文件 | Arc<Mutex<RamInode>> |
| create_directory | 创建目录 | Arc<Mutex<RamInode>> |
| remove | 删除文件/目录 | Result<()> |
| lookup | 查找 | Arc<Mutex<RamInode>> |
| open_file | 打开文件 | RamFile |

### 类型组合关系

```
RamFS
  ↓
Arc<Mutex<RamInode>>  (通过lookup/create获得)
  ↓
RamFile::new(inode)   (通过open_file获得)
  ↓
impl File             (实现统一接口)
```

---

## 常见问题

### Q1: 为什么RamFile需要维护offset？

**场景对比**：

```rust
// 不维护offset（繁琐）
let inode = ...;
let mut offset = 0;
loop {
    let n = inode.read_at(offset, &mut buf)?;
    if n == 0 { break; }
    offset += n;  // 手动更新
}

// 维护offset（方便）
let mut file = RamFile::new(inode);
loop {
    let n = file.read(&mut buf)?;
    if n == 0 { break; }
    // offset自动更新
}
```

### Q2: 为什么open_file不能打开目录？

**Unix设计**：

- 文件支持read/write/seek
- 目录不支持这些操作
- 目录使用readdir系统调用

**实际行为**：

```bash
# 错误
cat /etc  # Error: Is a directory

# 正确
ls /etc   # 使用readdir
```

### Q3: 为什么RamFS需要全局唯一的Inode号？

**原因**：

- Inode号用于标识文件
- 多个目录项可能指向同一个Inode（硬链接）
- 全局唯一避免冲突

**示例**：

```rust
let file = ramfs.create_file(root, "file1.txt")?;  // ino = 5
let link = file.clone();
dir.add_entry("file2.txt", link)?;  // 同一个ino = 5
```

---

## 下一步

在下一节（7.2.4）中，我们将实现全局文件系统管理器，提供统一的访问接口。

---

## 练习题

1. **实现文件大小**：为RamFile添加`size()`方法，返回文件大小
2. **实现文件位置**：为RamFile添加`tell()`方法，返回当前offset
3. **实现文件截断**：为RamFile添加`truncate(size)`方法，调用inode的truncate
