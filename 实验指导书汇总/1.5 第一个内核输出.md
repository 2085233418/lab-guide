## 1.5 第一个内核输出

#### 在kernel_main中输出欢迎信息

首先先声明模块，

在 `os/src/lib.rs` 中添加：

```rust
pub mod serial;      // 串口驱动
pub mod console;     // 控制台输出
```

**实现临时的 `without_interrupts`**

在实现第2章的中断系统之前，我们需要一个临时实现。在 `lib.rs` 中添加：

```rust
pub mod interrupts {
    pub fn without_interrupts<F, R>(f: F) -> R
    where
        F: FnOnce() -> R,
    {
        // 临时实现：直接执行闭包
        // 第2章会实现真正的中断禁用
        f()
    }
}
```

**修改 `kernel_main`**

在 `main.rs` 中修改：

```rust
use os::println;

#[no_mangle]
pub extern "C" fn kernel_main() -> ! {
    println!("Welcome to Error OS!");
    println!("Hello from RISC-V kernel!");

    loop {}
}
```

---

#### 验证 QEMU 中的输出

编译内核

```bash
cd os
cargo build --release
```

然后运行 QEMU

```bash
qemu-system-riscv64 \
    -machine virt \
    -cpu rv64 \
    -smp 1 \
    -m 128M \
    -bios default \
    -nographic \
    -serial mon:stdio \
    -kernel target/riscv64imac-unknown-none-elf/release/os
```

或使用项目根目录的 `run.sh` 脚本：

```bash
./run.sh
```

**预期输出**

```
OpenSBI v1.x
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 | |  | | '_ \ / _ \ '_ \ \___ \|  _ < | |
 | |__| | |_) |  __/ | | |____) | |_) || |_
  \____/| .__/ \___|_| |_|_____/|____/_____|
        | |
        |_|

Platform Name             : riscv-virtio,qemu
...

Boot HART MIDELEG         : 0x0000000000000222
Boot HART MEDELEG         : 0x000000000000b109

Welcome to Error OS!
Hello from RISC-V kernel!
```

**退出 QEMU**: 按 `Ctrl+A`，然后按 `X`

---

#### 测试不同格式的输出

**1. 测试各种格式化输出**

修改 `kernel_main`:

```rust
#[no_mangle]
pub extern "C" fn kernel_main() -> ! {
    println!("Welcome to Error OS!");
    println!();  // 空行

    // 测试格式化输出
    println!("Testing format output:");
    println!("  Decimal: {}", 42);
    println!("  Hex: {:#x}", 0xdeadbeef);
    println!("  Binary: {:#b}", 0b1010);
    println!("  Boolean: {}", true);

    // 测试 serial_print! 宏
    serial_println!("[SERIAL] This is serial output");

    // 测试不带换行的输出
    print!("Loading");
    for _ in 0..3 {
        print!(".");
    }
    println!(" Done!");

    println!("\nKernel initialization complete!");

    loop {}
}
```

**2. 编译运行**

```bash
cargo build --release
qemu-system-riscv64 -machine virt -cpu rv64 -m 128M -bios default -nographic -serial mon:stdio -kernel target/riscv64imac-unknown-none-elf/release/os
```

**预期输出**

```
Welcome to Error OS!

Testing format output:
  Decimal: 42
  Hex: 0xdeadbeef
  Binary: 0b1010
  Boolean: true
[SERIAL] This is serial output
Loading... Done!

Kernel initialization complete!
```

---

#### 实验验证

#### 完整性检查清单

在继续下一章之前，请确认以下功能正常：

```bash
# 1. 编译无错误
cargo build --release

# 2. 查看符号表
riscv64-unknown-elf-nm target/riscv64imac-unknown-none-elf/release/os | grep -E "(_start|kernel_main)"

# 3. 查看段信息
riscv64-unknown-elf-objdump -h target/riscv64imac-unknown-none-elf/release/os

# 4. 运行测试
cargo run --release
```

#### 测试程序

创建一个综合测试程序：

```rust
#[no_mangle]
pub extern "C" fn kernel_main() -> ! {
    // 测试1：基本输出
    println!("========================================");
    println!("  Error OS v0.1.0");
    println!("  RISC-V 64 Kernel");
    println!("========================================");
    println!();

    // 测试2：格式化输出
    println!("[TEST] Format output:");
    println!("  Integer: {}", 12345);
    println!("  Hex: {:#x}", 0xABCD);
    println!("  Pointer: {:p}", 0x80200000 as *const u8);

    // 测试3：串口输出
    serial_println!("[SERIAL] Direct serial output test");

    // 测试4：混合输出
    print!("Progress: [");
    for i in 0..10 {
        print!("#");
        if i < 9 {
            print!(" ");
        }
    }
    println!("] 100%");

    println!();
    println!("All tests passed!");
    println!("System ready. Press Ctrl+A then X to exit QEMU.");

    loop {}
}
```



好了，接下来我们的小操作系统的基本框架已经搭起来了。下一章我们讲一讲系统的中断。
