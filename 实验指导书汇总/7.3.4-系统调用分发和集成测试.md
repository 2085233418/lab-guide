# 7.3.4 系统调用分发和集成测试

## 本节目标

- 更新系统调用分发器
- 集成所有文件系统系统调用
- 编译验证
- 进行简单测试

---

## 前置要求

- 已完成 7.3.1-7.3.3 节的所有系统调用实现

---

## 步骤1：理解系统调用分发器

### 1.1 分发器的作用

**设计意图**：系统调用分发器（dispatcher）是内核的"总机"，负责根据系统调用号将请求路由到正确的处理函数。

**工作流程**：
```
用户态程序
  ↓ ecall指令
trap_handler
  ↓ 识别为系统调用
syscall_dispatcher ← 我们在这里
  ↓ match syscall_id
具体系统调用函数 (sys_open, sys_read, etc.)
```

**为什么需要分发器？**

1. **统一入口**：所有系统调用都通过同一个入口点进入内核
2. **参数统一处理**：从trap context提取参数（a0-a5）
3. **错误统一处理**：未知系统调用返回-1（ENOSYS）
4. **可视化调试**：可以在分发器层面打印所有系统调用信息

**分发器结构**：
```rust
pub fn syscall_dispatcher(context: &SyscallContext) -> isize {
    // 1. 可选：打印系统调用信息（调试）
    // 2. match分发到具体函数
    // 3. 返回结果
}
```

---

## 步骤2：更新系统调用分发器

### 2.1 [任务] 添加文件系统系统调用分发（任务点12-2，2分）

现在请你完成系统调用分发器的更新！在已有的Read、Write、Open分支基础上，添加Close和Mkdir的分发。

**文件位置**：`os/src/syscall/mod.rs`

**实现要求**：

1. **添加Close分支**：
   - 匹配 `SyscallId::Close`
   - 调用 `syscall_impl::sys_close(context.arg0)`
   - arg0 是文件描述符fd

2. **添加Mkdir分支**：
   - 匹配 `SyscallId::Mkdir`
   - 调用 `syscall_impl::sys_mkdir(context.arg0)`
   - arg0 是目录路径的C字符串指针

**思考题**：

1. 为什么Close和Mkdir只需要一个参数，而Read和Write需要三个？
2. 如果用户传入无效的系统调用号会发生什么？哪个分支会处理？
3. 为什么Open已经实现了，但标记为"已部分提供作为示例"？

**代码框架**（参考mod.rs中的TODO注释）：

```rust
// 在syscall_dispatcher函数的match块中

SyscallId::Open => {
    // 已提供作为示例
    syscall_impl::sys_open(context.arg0, context.arg1)
}
SyscallId::Close => {
    // TODO: Task 12-2 - 添加sys_close分发
    // Hint: syscall_impl::sys_close(context.arg0)
    todo!("Add sys_close dispatch")
}
SyscallId::Mkdir => {
    // TODO: Task 12-2 - 添加sys_mkdir分发
    // Hint: syscall_impl::sys_mkdir(context.arg0)
    todo!("Add sys_mkdir dispatch")
}
```

**验证方法**：

完成后测试编译：
```bash
cd os
cargo check
```

参考初版指导书查看完整实现。

---

## 步骤3：分发器设计要点

### 3.1 参数映射说明

**read**：

```
a0 = fd
a1 = buf (用户态指针)
a2 = len
```

**write**：

```
a0 = fd
a1 = buf (用户态指针)
a2 = len
```

**open**：

```
a0 = path (C字符串指针)
a1 = flags
```

**close**：

```
a0 = fd
```

**mkdir**：

```
a0 = path (C字符串指针)
```

---

## 步骤4：导出模块

### 4.1 更新mod.rs导出

**文件路径：`os/src/syscall/mod.rs`**

```rust
// os/src/syscall/mod.rs

mod syscall_impl;

pub use syscall_impl::{
    // 文件系统系统调用
    sys_read,
    sys_write,
    sys_open,
    sys_close,
    sys_mkdir,

    // 进程系统调用
    sys_exit,
    sys_getpid,
    // ...
};
```

### 4.2 确保syscall_impl导入

在 `os/src/syscall/syscall_impl.rs` 开头添加：

**文件路径：`os/src/syscall/syscall_impl.rs`**

```rust
use crate::fs::{RAMFS, FD_TABLE, FileDescriptor};
use crate::serial_println;
use alloc::string::String;
use alloc::sync::Arc;
use alloc::vec::Vec;
use spin::Mutex;
```

---

## 步骤5：编译验证

### 5.1 编译项目

```bash
cd os
cargo build
```

**预期结果**：编译成功，无错误和警告

### 5.2 常见编译错误

**错误1**：类型未导入

```
error[E0433]: failed to resolve: use of undeclared crate or module `RAMFS`
```

**解决**：添加 `use crate::fs::RAMFS;`

**错误2**：函数未导出

```
error[E0425]: cannot find function `sys_read` in this scope
```

**解决**：检查 `mod.rs` 是否导出了函数

**错误3**：模块未声明

```
error[E0583]: file not found for module `syscall_impl`
```

**解决**：检查文件名和mod声明是否匹配

---

## 步骤6：简单测试

### 6.1 在kernel_main中测试

在 `os/src/main.rs` 中添加测试代码：

**文件路径：`os/src/main.rs`**

```rust
fn kernel_main() -> ! {
    println!("[Kernel] Booting...");

    // 初始化文件系统
    os::fs::init();

    // 测试文件系统系统调用
    test_filesystem_syscalls();

    // ... 启动调度器 ...
}

fn test_filesystem_syscalls() {
    use os::syscall::{sys_open, sys_write, sys_read, sys_close, sys_mkdir};

    println!("[Test] Testing filesystem syscalls...");

    // 测试创建目录
    let dir_path = "/testdir\0";
    let result = sys_mkdir(dir_path.as_ptr() as usize);
    println!("[Test] mkdir result: {}", result);

    // 测试打开文件（创建）
    let file_path = "/test.txt\0";
    let flags = 0x42;  // O_RDWR | O_CREAT
    let fd = sys_open(file_path.as_ptr() as usize, flags);
    println!("[Test] open result: fd={}", fd);

    if fd >= 0 {
        // 测试写入
        let data = b"Hello, RamFS!";
        let n = sys_write(fd as usize, data.as_ptr() as usize, data.len());
        println!("[Test] write result: {} bytes", n);

        // 测试读取（需要先移动到开头）
        // 注意：当前没有lseek，读取会从offset=13开始，返回0
        let mut buf = [0u8; 20];
        let n = sys_read(fd as usize, buf.as_mut_ptr() as usize, buf.len());
        println!("[Test] read result: {} bytes", n);

        // 测试关闭
        let result = sys_close(fd as usize);
        println!("[Test] close result: {}", result);
    }

    println!("[Test] Filesystem syscalls test complete");
}
```

### 6.2 预期输出

```
[Kernel] Booting...
[FS] File system initialized
[Test] Testing filesystem syscalls...
[SYSCALL] sys_mkdir: path=0x...
[SYSCALL] sys_mkdir: path="testdir"
[SYSCALL] sys_mkdir: success
[Test] mkdir result: 0
[SYSCALL] sys_open: path=0x..., flags=0x42
[SYSCALL] sys_open: path="test.txt"
[SYSCALL] sys_open: file created
[SYSCALL] sys_open: success, fd=3
[Test] open result: fd=3
[SYSCALL] sys_write: fd=3, buf=0x..., len=13
[SYSCALL] sys_write: success, wrote 13 bytes
[Test] write result: 13 bytes
[SYSCALL] sys_read: fd=3, buf=0x..., len=20
[SYSCALL] sys_read: success, read 0 bytes
[Test] read result: 0 bytes
[SYSCALL] sys_close: fd=3
[SYSCALL] sys_close: success
[Test] close result: 0
[Test] Filesystem syscalls test complete
```

### 6.3 测试说明

**为什么read返回0？**

- write后offset=13
- read从offset=13开始
- 文件只有13字节，已到末尾
- 返回0（EOF）

**如何读取刚写入的数据？**

需要实现 `sys_lseek` 移动offset：

```rust
// 写入后移动到开头
sys_lseek(fd, 0, SEEK_SET);
// 然后读取
sys_read(fd, buf, len);
```

---

## 知识点总结

### 系统调用完整流程

```
用户态:
  open("/file.txt", O_RDWR | O_CREAT)
    ↓
  ecall (触发异常)
    ↓
硬件:
  保存sepc
  切换到S模式
  跳转到stvec
    ↓
内核态:
  trap_handler
    ↓
  syscall_dispatcher
    ↓
  sys_open
    ↓
  read_c_string
  RAMFS.lookup/create
  RAMFS.open_file
  FD_TABLE.alloc
    ↓
  返回fd
    ↓
  sret (返回用户态)
    ↓
用户态:
  继续执行，a0=fd
```

### 已实现的系统调用

| 系统调用 | 功能 | 状态 |
|---------|------|------|
| sys_read | 读取文件 | 完成 |
| sys_write | 写入文件 | 完成 |
| sys_open | 打开/创建文件 | 完成 |
| sys_close | 关闭文件 | 完成 |
| sys_mkdir | 创建目录 | 完成 |

### 待实现的系统调用

| 系统调用 | 功能 | 优先级 |
|---------|------|--------|
| sys_lseek | 移动文件位置 | 高 |
| sys_unlink | 删除文件 | 中 |
| sys_rmdir | 删除目录 | 中 |
| sys_stat | 获取文件信息 | 中 |
| sys_readdir | 列出目录内容 | 低 |

---

## 常见问题

### Q1: 为什么测试代码中字符串要加'\0'？

**原因**：

- 系统调用接收C字符串指针
- C字符串以'\0'结尾
- read_c_string需要'\0'来判断结束

**示例**：

```rust
// 正确
let path = "/test.txt\0";
sys_open(path.as_ptr() as usize, flags);

// 错误（会读取到未知内存）
let path = "/test.txt";
sys_open(path.as_ptr() as usize, flags);
```

### Q2: 为什么不能直接传String？

**原因**：

- 系统调用通过寄存器传参
- 只能传递简单类型（整数、指针）
- 不能传递复杂类型（String、Vec）

**ABI限制**：

```
RISC-V系统调用ABI：
  a0-a5: 参数1-6
  a7: 系统调用号
  a0: 返回值

只能传递usize大小的值
```

### Q3: 如何测试多进程文件共享？

**需要实现**：

1. 进程管理（第6章）
2. fork系统调用
3. 进程间FD继承

**示例**：

```c
int fd = open("file.txt", O_RDWR);
int pid = fork();
if (pid == 0) {
    // 子进程
    write(fd, "child", 5);
} else {
    // 父进程
    write(fd, "parent", 6);
}
```

---

## 第7.3节总结

经过7.3.1-7.3.4四个小节，我们完成了文件系统系统调用的实现：

### 核心组件

| 组件 | 文件 | 作用 |
|------|------|------|
| 系统调用号 | mod.rs | 定义调用号和分发 |
| read/write | syscall_impl.rs | 读写文件 |
| open | syscall_impl.rs | 打开/创建文件 |
| close/mkdir | syscall_impl.rs | 关闭文件和创建目录 |

### 已实现的功能

- 系统调用号定义（兼容Linux RISC-V）
- 文件读写（sys_read/sys_write）
- 文件打开（sys_open，支持O_CREAT）
- 文件关闭（sys_close）
- 目录创建（sys_mkdir）
- C字符串处理（read_c_string）
- 系统调用分发（syscall_dispatcher）

### 下一步

在第7.4节中，我们将进行完整的文件系统测试，验证所有功能是否正常工作。

---

## 练习题

1. **实现sys_lseek**：添加lseek系统调用，支持移动文件位置
2. **实现sys_unlink**：添加unlink系统调用，删除文件
3. **实现sys_stat**：添加stat系统调用，获取文件元数据
