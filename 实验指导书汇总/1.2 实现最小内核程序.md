## 1.2 实现最小内核程序

上一节的末尾我们提到，程序因遗失了`start`语言项而报错。

我们通常会认为，当运行一个程序时，首先被调用的是 `main` 函数。但是，大多数语言都拥有一个**运行时系统**，它通常为**垃圾回收**或**绿色线程**服务，如 Java 的 GC 或 Go 语言的协程；这个运行时系统需要在 main 函数前启动，因为它需要让程序初始化。

在一个典型的使用标准库的 Rust 程序中，程序运行是从一个名为 `crt0` 的运行时库开始的。`crt0` 意为 C runtime zero，它能建立一个适合运行 C 语言程序的环境，这包含了栈的创建和可执行程序参数的传入。在这之后，这个运行时库会调用 **Rust 的运行时入口点**，这个入口点被称作 **start语言项**。Rust 只拥有一个极小的运行时，它被设计为拥有较少的功能，如爆栈检测和打印**栈轨迹**。这之后，这个运行时将会调用 main 函数。

我们的裸机程序并不能访问 Rust 运行时或 `crt0` 库，所以我们需要定义自己的入口点。



#### 编写 RISC-V 汇编入口点 (`_start`)

RISC-V 处理器启动后，会从特定地址开始执行。在 QEMU virt 机器中：

1. OpenSBI 固件加载到 `0x80000000`
2. OpenSBI 加载我们的内核到 `0x80200000`
3. 跳转到 `_start` 符号开始执行

**使用 `global_asm!` 宏编写汇编**

在 `main.rs` 中添加：

```rust
use core::arch::global_asm;

// RISC-V 汇编入口点
// 定义在汇编中，负责：
// - 清零 BSS 段
// - 设置栈指针
// - 跳转到 kernel_main
global_asm!(
    ".section .text.entry",
    ".globl _start",
    "_start:",
    // 设置栈指针
    "   la sp, stack_end",
    // 清零 BSS 段
    "   la t0, bss_start",
    "   la t1, bss_end",
    "1:",
    "   bgeu t0, t1, 2f",
    "   sd zero, (t0)",
    "   addi t0, t0, 8",
    "   j 1b",
    "2:",
    // 跳转到 kernel_main
    "   call kernel_main",
    // 如果返回，进入死循环
    "3:",
    "   wfi",
    "   j 3b",
);
```

**代码逐行解析**

| 汇编指令               | 说明                                                |
| ---------------------- | --------------------------------------------------- |
| `.section .text.entry` | 将代码放入 `.text.entry` 段（链接器脚本中最先加载） |
| `.globl _start`        | 声明 `_start` 为全局符号（链接器可见）              |
| `_start:`              | 入口点标签                                          |
| `la sp, stack_end`     | 加载栈顶地址到栈指针 `sp`                           |
| `la t0, bss_start`     | 加载 BSS 段起始地址到临时寄存器 `t0`                |
| `la t1, bss_end`       | 加载 BSS 段结束地址到 `t1`                          |
| `bgeu t0, t1, 2f`      | 如果 `t0 >= t1`，跳转到标签 `2`                     |
| `sd zero, (t0)`        | 将 0 写入地址 `t0`（8 字节）                        |
| `addi t0, t0, 8`       | `t0` 递增 8 字节                                    |
| `j 1b`                 | 跳转回标签 `1`（向后跳转）                          |
| `call kernel_main`     | 调用 Rust 的 `kernel_main` 函数                     |
| `wfi`                  | Wait For Interrupt（低功耗等待）                    |
| `j 3b`                 | 无限循环                                            |

---

#### 实现 BSS 段清零

BSS（Block Started by Symbol）段包含未初始化的全局变量和静态变量。C/Rust 标准要求 BSS 段在程序启动时清零。

**为什么需要清零？**

- 内存中可能包含随机数据
- 未初始化的全局变量应该是 0
- 确保程序行为可预测

**实现说明**

BSS 段清零已经在 `_start` 汇编代码中实现：

```asm
// 清零 BSS 段
la t0, bss_start      # t0 = BSS 起始地址
la t1, bss_end        # t1 = BSS 结束地址
1:
    bgeu t0, t1, 2f   # 如果 t0 >= t1，跳出循环
    sd zero, (t0)     # *t0 = 0（8字节）
    addi t0, t0, 8    # t0 += 8
    j 1b              # 循环
2:
```

**符号定义位置**

这些符号在链接器脚本 `linker-riscv64.ld` 中定义：

```ld
.bss : ALIGN(4K) {
    bss_start = .;
    *(.bss .bss.*)
    *(.sbss .sbss.*)
    bss_end = .;
}
```

---

#### 初始化栈指针

栈（Stack）用于：

- 函数调用的返回地址
- 局部变量存储
- 函数参数传递

RISC-V 使用 `sp` 寄存器作为栈指针，栈向下增长（从高地址到低地址）。

**实现说明**

栈指针初始化已在 `_start` 中完成：

```asm
la sp, stack_end    # 加载栈顶地址到 sp
```

**栈空间定义**

在链接器脚本中定义：

```ld
.stack : ALIGN(4K) {
    stack_start = .;
    . += 512K;        /* 512 KB 栈空间 */
    stack_end = .;
}
```

---

#### 跳转到 Rust `kernel_main`

**定义 `kernel_main` 函数**

在 `main.rs` 中添加：

```rust
/// 内核主函数
///
/// # 功能
/// - 初始化内核
/// - 测试基本功能
#[no_mangle]
pub extern "C" fn kernel_main() -> ! {
    // 暂时使用死循环
    loop {}
}
```

我们使用`no_mangle`标记这个函数，来禁止编译器修改函数名（确保汇编能找到）。

我们还将函数标记为`extern "C"`，告诉编译器这个函数应当使用 C 调用约定（与汇编兼容）；函数名为`kernel_main`。

与前文的`panic`函数类似，这个函数的返回值类型为**！**。它定义了一个发散函数，即不允许返回的一个函数。作为操作系统的主函数，不会被任何函数调用，直接被操作系统的**引导程序**调用。所以作为函数返回的替代，这个入口点应该去调用，比如操作系统提供的 **exit 系统调用**函数。在我们编写操作系统的情况下，关机应该是一个合适的选择，因为当一个独立式可执行程序返回时，不会留下任何需要做的事情。现在来看，我们可以添加一个无限循环，来满足对返回值类型的需求。

编译测试一下

```bash
cargo build --release
```

查看生成的二进制文件，

```bash
# 查看二进制文件信息
file target/riscv64imac-unknown-none-elf/release/os

# 查看符号表（确认 _start 和 kernel_main 存在）
riscv64-unknown-elf-nm target/riscv64imac-unknown-none-elf/release/os | grep -E "(_start|kernel_main)"
```

预期输出：

```
0000000080200000 T _start
0000000080200xxx T kernel_main
```
