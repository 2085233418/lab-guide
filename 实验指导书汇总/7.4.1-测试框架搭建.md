# 7.4.1 测试框架搭建

## 本节目标

- 理解文件系统测试的组织结构
- 搭建测试框架
- 配置测试环境
- 实现测试运行器

---

## 本节新增文件

```
os/tests/
└── test_filesystem.rs  # 文件系统集成测试（初始框架）
```

---

## 重要提示

### 测试输出使用英文

所有测试输出必须使用英文，确保在不同终端环境下都能正确显示：

```rust
// 正确
serial_print!("test_create_file... ");
serial_println!("[ok]");

// 错误
serial_print!("测试创建文件... ");
serial_println!("[成功]");
```

### 使用trap模块

测试代码运行在内核态，不需要通过系统调用，但初始化时仍需要trap模块：

```rust
// 系统初始化使用trap模块
os::trap::init();
```

---

## 步骤1：理解测试的重要性

### 1.1 为什么需要测试？

**测试** 是验证代码正确性的重要手段，尤其对于操作系统这种复杂系统。

**类比**：测试就像体检

- 确保各项功能正常工作（功能测试）
- 发现潜在问题（回归测试）
- 避免线上故障（集成测试）
- 证明代码质量（持续集成）

### 1.2 测试的价值

```
没有测试:
  修改代码 → 不知道是否破坏原有功能
  添加功能 → 不确定是否引入bug
  重构代码 → 担心改坏已有逻辑

有了测试:
  修改代码 → 运行测试验证
  添加功能 → 编写测试保护
  重构代码 → 测试通过则安全
```

### 1.3 测试类型

| 类型 | 范围 | 示例 |
|------|------|------|
| 单元测试 | 单个函数 | 测试read_at |
| 集成测试 | 多个模块 | 测试文件系统 |
| 系统测试 | 整个系统 | 测试用户程序 |

**本节重点**：集成测试（测试文件系统各模块协作）

---

## 步骤2：创建测试文件

### 2.1 创建test_filesystem.rs

创建 `os/tests/test_filesystem.rs`：

**文件路径：`os/tests/test_filesystem.rs`**

```rust
//! File system integration tests
//!
//! Tests file creation, reading, writing, and directory operations

#![no_std]
#![no_main]
#![feature(custom_test_frameworks)]
#![test_runner(os::test_runner)]
#![reexport_test_harness_main = "test_main"]

use core::panic::PanicInfo;
use os::fs::{RAMFS, FD_TABLE, File, SeekFrom};
use os::{serial_println, serial_print};
use alloc::sync::Arc;
use spin::Mutex;
use alloc::string::String;

extern crate alloc;
```

**属性说明**：

- `#![no_std]` - 不使用标准库
- `#![no_main]` - 不使用标准main函数
- `#![feature(custom_test_frameworks)]` - 使用自定义测试框架
- `#![test_runner(...)]` - 指定测试运行器
- `#![reexport_test_harness_main]` - 重命名test_main

### 2.2 实现_start入口点

**文件路径：`os/tests/test_filesystem.rs`**

```rust
#[no_mangle]
pub extern "C" fn _start() -> ! {
    // Initialize OS
    os::init();

    // Run tests
    test_main();

    // Exit
    loop {
        unsafe {
            core::arch::asm!("wfi");
        }
    }
}
```

**流程说明**：

```
1. os::init()
   - 初始化trap模块
   - 初始化文件系统
   - 初始化其他子系统

2. test_main()
   - 运行所有标记#[test_case]的函数

3. 进入无限循环
   - wfi指令等待中断
   - 或者退出QEMU
```

### 2.3 实现panic_handler

**文件路径：`os/tests/test_filesystem.rs`**

```rust
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    os::test_panic_handler(info)
}
```

**panic处理**：

- 测试失败时会panic
- test_panic_handler打印错误信息
- 退出QEMU

---

## 步骤3：配置测试运行器

### 3.1 在lib.rs中添加test_runner

修改 `os/src/lib.rs`，添加：

**文件路径：`os/src/lib.rs`**

```rust
#[cfg(test)]
pub fn test_runner(tests: &[&dyn Fn()]) {
    serial_println!("Running {} tests", tests.len());
    for test in tests {
        test();
    }
    serial_println!("All tests passed!");
    exit_qemu(QemuExitCode::Success);
}

#[cfg(test)]
pub fn test_panic_handler(info: &PanicInfo) -> ! {
    serial_println!("[failed]\n");
    serial_println!("Error: {}\n", info);
    exit_qemu(QemuExitCode::Failed);
    loop {}
}
```

### 3.2 实现QEMU退出

**文件路径：`os/src/lib.rs`**

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u32)]
pub enum QemuExitCode {
    Success = 0x10,
    Failed = 0x11,
}

pub fn exit_qemu(exit_code: QemuExitCode) {
    use x86_64::instructions::port::Port;

    unsafe {
        let mut port = Port::new(0xf4);
        port.write(exit_code as u32);
    }
}
```

**QEMU退出机制**：

- 写入0xf4端口
- QEMU检测到写入后退出
- 退出码0x10表示成功，0x11表示失败

---

## 步骤4：配置Cargo.toml

### 4.1 添加测试配置

修改 `os/Cargo.toml`：

**文件路径：`os/Cargo.toml`**

```toml
[[test]]
name = "test_filesystem"
harness = false
```

**说明**：

- `name` - 测试名称（对应tests/test_filesystem.rs）
- `harness = false` - 不使用默认测试框架

### 4.2 添加测试依赖

**文件路径：`os/Cargo.toml`**

```toml
[dev-dependencies]
# 测试依赖在这里添加（如果有）
```

---

## 步骤5：编写第一个测试

### 5.1 添加简单测试

在 `test_filesystem.rs` 中添加：

**文件路径：`os/tests/test_filesystem.rs`**

```rust
#[test_case]
fn test_dummy() {
    serial_print!("test_dummy... ");
    assert_eq!(1 + 1, 2);
    serial_println!("[ok]");
}
```

**测试结构**：

```rust
#[test_case]  // 标记为测试用例
fn test_xxx() {
    serial_print!("test_xxx... ");  // 输出测试名称
    // 测试逻辑
    assert_eq!(actual, expected);   // 断言
    serial_println!("[ok]");        // 测试通过
}
```

### 5.2 运行测试

```bash
cd os
cargo test --test test_filesystem
```

**预期输出**：

```
Running 1 tests
test_dummy... [ok]
All tests passed!
```

---

## 知识点总结

### 测试框架组件

| 组件 | 作用 |
|------|------|
| #[test_case] | 标记测试函数 |
| test_runner | 运行所有测试 |
| _start | 测试入口点 |
| panic_handler | 处理测试失败 |

### 测试流程

```
1. cargo test
   ↓
2. 编译测试二进制
   ↓
3. QEMU启动
   ↓
4. _start()
   ↓
5. os::init()
   ↓
6. test_main()
   ↓
7. 运行所有#[test_case]
   ↓
8. 退出QEMU
```

### 断言宏

| 宏 | 作用 |
|-----|------|
| assert!(expr) | 断言表达式为true |
| assert_eq!(a, b) | 断言a == b |
| assert_ne!(a, b) | 断言a != b |

---

## 常见问题

### Q1: 为什么测试要用#![no_std]？

**原因**：

- 操作系统内核不能依赖标准库
- 测试运行在内核态，没有std环境
- 必须使用no_std + alloc

### Q2: 为什么需要自定义test_runner？

**原因**：

- 默认test_runner依赖std
- 我们需要通过串口输出测试结果
- 需要自定义QEMU退出机制

### Q3: 测试如何输出到终端？

**输出路径**：

```
serial_println!(...)
  ↓
串口驱动
  ↓
QEMU串口
  ↓
主机终端
```

---

## 步骤6：实现文件系统测试用例

### 6.1 [任务] 实现文件创建测试（任务点13-1，2分）

现在请你实现文件创建测试！这个测试验证文件系统能否正确创建文件。

**文件位置**：`os/tests/test_filesystem.rs`

**测试要求**：

1. **打印测试名称**：使用 `serial_print!("test_create_file... ")`
2. **获取文件系统和根目录**：使用 `FS_MANAGER.lock()` 和 `ramfs().root()`
3. **创建文件**：调用 `create_file()` 创建名为 "test.txt" 的文件
4. **验证文件创建成功**：使用 `assert!(file_inode.is_ok())`
5. **打印成功信息**：使用 `serial_println!("[ok]")`

**思考题**：

1. 为什么测试要使用 `#[test_case]` 属性标记？
2. 如果创建失败，会发生什么？测试框架如何处理？
3. 测试中直接操作 `FS_MANAGER` 和系统调用有什么区别？

**代码框架**：

```rust
#[test_case]
fn test_create_file() {
    serial_print!("test_create_file... ");

    // TODO: Task 13-1 - Implement file creation test (2 points)
    // Step 1: 获取文件系统管理器
    // Hint: use os::fs::FS_MANAGER;
    // Hint: let manager = FS_MANAGER.lock();

    // Step 2: 获取RamFS和根目录
    // Hint: let ramfs = manager.ramfs();
    // Hint: let root = manager.root();

    // Step 3: 创建文件
    // Hint: let file_inode = ramfs.create_file(root, String::from("test.txt"));

    // Step 4: 断言创建成功
    // Hint: assert!(file_inode.is_ok());

    serial_println!("[ok]");
}
```

**验证方法**：

```bash
cd os
cargo test --test test_filesystem
```

### 6.2 [任务] 实现读写测试（任务点13-2，2分）

现在请你实现文件读写测试！这个测试验证文件的写入和读取功能。

**文件位置**：`os/tests/test_filesystem.rs`

**测试要求**：

1. **创建并打开文件**：复用上一个测试的逻辑，创建文件并获取File对象
2. **写入数据**：向文件写入 "Hello, RamFS!"
3. **移动到文件开头**：使用 `seek(SeekFrom::Start(0))` 重置offset
4. **读取数据**：读取文件内容到缓冲区
5. **验证数据正确**：断言读取的数据与写入的一致

**思考题**：

1. 为什么写入后需要 `seek` 到开头才能读取？
2. 如果不 `seek`，直接 `read` 会返回什么？
3. 这个测试验证了文件系统的哪些功能？

**代码框架**：

```rust
#[test_case]
fn test_read_write() {
    serial_print!("test_read_write... ");

    // TODO: Task 13-2 - Implement read/write test (2 points)
    // Step 1: 创建文件（参考test_create_file）
    // Step 2: 打开文件
    // Hint: let file = ramfs.open_file(file_inode.unwrap()).unwrap();

    // Step 3: 写入数据
    // Hint: let data = b"Hello, RamFS!";
    // Hint: let n = file.lock().write(data).unwrap();
    // Hint: assert_eq!(n, data.len());

    // Step 4: 移动到文件开头
    // Hint: file.lock().seek(SeekFrom::Start(0)).unwrap();

    // Step 5: 读取数据
    // Hint: let mut buf = [0u8; 20];
    // Hint: let n = file.lock().read(&mut buf).unwrap();

    // Step 6: 验证数据
    // Hint: assert_eq!(&buf[..n], data);

    serial_println!("[ok]");
}
```

**验证方法**：

```bash
cd os
cargo test --test test_filesystem
```

### 6.3 [任务] 实现目录创建测试（任务点13-3，1分）

现在请你实现目录创建测试！这个测试验证目录创建功能。

**文件位置**：`os/tests/test_filesystem.rs`

**测试要求**：

1. **创建目录**：在根目录下创建名为 "testdir" 的目录
2. **验证创建成功**：断言返回值为 `Ok`
3. **可选：验证目录存在**：通过 `lookup` 查找创建的目录

**思考题**：

1. 目录和文件的区别是什么？在Inode层面如何区分？
2. 为什么目录测试相对简单（只有1分）？
3. 如何测试在子目录中创建文件？

**代码框架**：

```rust
#[test_case]
fn test_mkdir() {
    serial_print!("test_mkdir... ");

    // TODO: Task 13-3 - Implement mkdir test (1 point)
    // Step 1: 获取文件系统和根目录
    // Hint: let manager = FS_MANAGER.lock();
    // Hint: let ramfs = manager.ramfs();
    // Hint: let root = manager.root();

    // Step 2: 创建目录
    // Hint: let dir_inode = ramfs.create_directory(root, String::from("testdir"));

    // Step 3: 断言创建成功
    // Hint: assert!(dir_inode.is_ok());

    serial_println!("[ok]");
}
```

**验证方法**：

```bash
cd os
cargo test --test test_filesystem
```

参考初版指导书查看完整实现。

---

## 知识点总结（更新）

### 测试用例类型

| 测试 | 验证功能 | 复杂度 |
|------|---------|--------|
| test_create_file | 文件创建 | 低 |
| test_read_write | 读写功能 | 中 |
| test_mkdir | 目录创建 | 低 |

### 完整测试流程

```
1. cargo test --test test_filesystem
   ↓
2. 运行test_create_file
   - 创建文件
   - 验证成功
   ↓
3. 运行test_read_write
   - 创建文件
   - 写入数据
   - 移动offset
   - 读取数据
   - 验证正确
   ↓
4. 运行test_mkdir
   - 创建目录
   - 验证成功
   ↓
5. All tests passed!
```

---

## 下一步

完成这些测试后，你已经搭建了完整的文件系统测试框架。在后续章节中，可以继续添加更多测试用例，如：
- 文件删除测试
- 目录列表测试
- 错误处理测试

---

## 练习题

1. **添加测试统计**：记录通过/失败的测试数量
2. **实现测试超时**：单个测试超过一定时间自动失败
3. **添加lseek测试**：测试不同的SeekFrom模式
3. **实现测试过滤**：支持只运行指定的测试
