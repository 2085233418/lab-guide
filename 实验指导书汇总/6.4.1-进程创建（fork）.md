# 6.4.1 进程创建（fork）

> **本节可以完整实现**
>
> 与6.4.2的exec不同，fork系统调用不依赖文件系统，因此可以在第6章完整实现。
>
> **6.4节实现状态对比**：
> - **6.4.1 fork** -  完整实现（不需要文件系统）
> - **6.4.2 exec** - ！！！请注意！本章节只有框架实现（需要第7章文件系统）
> - **6.4.3 exit** -  完整实现
> - **6.4.4 wait** -  完整实现

## 本节目标

- 理解fork系统调用的原理
- 实现fork系统调用
- 复制进程地址空间
- 建立父子进程关系
- 测试进程创建

---

## 本节修改文件

```
os/src/
├── syscall/
│   ├── mod.rs              # 添加Fork系统调用号（修改）
│   └── syscall_impl.rs     # 实现sys_fork（新增）
├── process/
│   ├── mod.rs              # 导出fork相关函数（修改）
│   └── pcb.rs              # 添加fork方法（修改）
└── main.rs                 # 添加测试代码（修改）
```

---

## 重要提示

### 使用trap模块

从第6章开始，所有陷阱处理使用`trap`模块：

```rust
// 正确
use crate::trap;

// 错误
// use crate::interrupts;  // 已废弃
```

### 输出使用英文

所有系统调用相关的输出必须使用英文：

```rust
// 正确
serial_println!("[SYSCALL] fork: parent={}, child={}", parent_pid, child_pid);

// 错误
serial_println!("[系统调用] fork: 父进程={}, 子进程={}", parent_pid, child_pid);
```

---

## 什么是fork？

**fork** 是Unix/Linux中创建新进程的系统调用。

### fork的特点

```
调用前:
  只有父进程

fork()调用:
  复制父进程的所有资源

调用后:
  父进程: fork返回子进程PID
  子进程: fork返回0
```

**类比**：就像细胞分裂
- 原细胞（父进程）
- 分裂产生新细胞（子进程）
- 两个细胞拥有相同的DNA（代码和数据）
- 但各自独立运行

### 为什么fork返回两次？

```c
int pid = fork();
if (pid == 0) {
    // 这是子进程
    printf("I am child\n");
} else {
    // 这是父进程
    printf("I am parent, child=%d\n", pid);
}
```

**关键点**：
- fork调用一次，返回两次
- 父进程中返回子进程的PID
- 子进程中返回0
- 两个进程各自继续执行

---

## 知识补充：fork的执行流程

```
父进程执行:
  1. 调用fork()
  2. 进入内核态（ecall）
  3. sys_fork()执行：
     - 分配新PID
     - 复制PCB
     - 复制地址空间
     - 复制寄存器状态
     - 设置子进程返回值为0
     - 设置父进程返回值为child_pid
  4. 父进程返回用户态
  5. fork返回child_pid
  6. 继续执行if (pid > 0)分支

子进程开始运行:
  1. 被调度器选中
  2. 恢复上下文（从fork返回点）
  3. fork返回0
  4. 继续执行if (pid == 0)分支
```

**为什么子进程从fork返回？**
- fork复制了父进程的所有寄存器
- 包括PC（程序计数器）
- 所以子进程恢复时从fork返回点继续

---

## 知识补充：写时复制（COW）

**问题**：如果完全复制父进程的内存，开销很大。

**解决方案**：写时复制（Copy-On-Write）

```
fork时:
  父子进程共享相同的物理页
  页表项标记为只读

写入时:
  触发页错误异常
  内核复制该页
  修改页表指向新页
```

**类比**：就像双胞胎共用一本书
- 开始时看同一本书（共享内存）
- 谁要修改，就复印一页（复制页）
- 各自修改各自的副本

**本节简化**：
- 我们暂不实现COW
- 直接复制所有内存
- 第8章会实现完整的COW机制

---

## 步骤0：补充PCB内存管理字段

在实现fork之前，我们需要为PCB添加内存管理相关字段，这些字段将在后续的exec系统调用中使用。

### 0.1 添加内存管理字段

修改 `os/src/process/pcb.rs` 中的 `ProcessControlBlock` 结构体：

```rust
/// 进程控制块
pub struct ProcessControlBlock {
    // === 身份信息 ===
    pid: ProcessId,
    name: &'static str,

    // === 状态信息 ===
    state: ProcessState,
    exit_code: Option<i32>,

    // === 关系信息 ===
    parent_pid: Option<ProcessId>,
    children: Vec<ProcessId>,

    // === 执行上下文 ===
    context: ProcessContext,

    // === 内存管理 ===
    address_space: Option<usize>,  // 页表基址（暂未实现完整虚拟内存）
    heap_bottom: usize,            // 堆起始地址
    heap_top: usize,               // 堆结束地址

    // === 调度信息 ===
    time_slice: usize,
    priority: usize,
}
```

**新增字段说明**：

| 字段 | 类型 | 用途 |
|------|------|------|
| `address_space` | `Option<usize>` | 页表基址，用于虚拟内存管理（暂未实现） |
| `heap_bottom` | `usize` | 堆的起始地址 |
| `heap_top` | `usize` | 堆的结束地址 |

**为什么现在添加这些字段？**
- fork需要复制内存信息
- exec需要替换地址空间
- exit需要释放内存资源
- 提前添加可以避免后续修改结构体导致兼容性问题

### 0.2 更新PCB构造函数

修改 `ProcessControlBlock::new()` 方法：

```rust
impl ProcessControlBlock {
    /// 创建新进程
    pub fn new(
        pid: ProcessId,
        name: &'static str,
        parent_pid: Option<ProcessId>,
    ) -> Self {
        ProcessControlBlock {
            pid,
            name,
            state: ProcessState::Ready,
            exit_code: None,
            parent_pid,
            children: Vec::new(),
            context: ProcessContext::new(),
            address_space: None,    // NEW: 暂未分配地址空间
            heap_bottom: 0,         // NEW: 堆起始地址
            heap_top: 0,            // NEW: 堆结束地址
            time_slice: 5,
            priority: 1,
        }
    }
}
```

**初始化说明**：
- `address_space = None`：进程创建时暂无地址空间
- `heap_bottom = 0` 和 `heap_top = 0`：堆未分配
- 实际的内存分配将在exec或程序加载时进行

**验证修改**：

```bash
cargo check
```

应该编译通过。如果出现fork方法中的字段缺失错误，将在下一步修复。

---

## 步骤1：添加fork系统调用号

修改 `os/src/syscall/mod.rs`：

```rust
/// System call IDs
#[repr(usize)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum SyscallId {
    // File system syscalls
    Read = 63,
    Write = 64,

    // Process syscalls
    Exit = 93,
    GetPid = 172,
    Fork = 220,      // NEW: Fork process
    Exec = 221,
    WaitPid = 260,

    Unknown = 9999,
}
```

更新 `From<usize>` 实现：

```rust
impl From<usize> for SyscallId {
    fn from(id: usize) -> Self {
        match id {
            63 => SyscallId::Read,
            64 => SyscallId::Write,
            93 => SyscallId::Exit,
            172 => SyscallId::GetPid,
            220 => SyscallId::Fork,   // NEW
            221 => SyscallId::Exec,
            260 => SyscallId::WaitPid,
            _ => SyscallId::Unknown,
        }
    }
}
```

**系统调用号来源**：兼容Linux RISC-V调用约定
- 220是Linux中clone的简化版本
- fork在现代Linux中通过clone实现

---

## 步骤2：实现PCB的fork方法

### 2.1 设计fork方法签名

在 `os/src/process/pcb.rs` 中添加：

```rust
impl ProcessControlBlock {
    /// Fork current process
    ///
    /// Creates a child process that is a copy of the parent
    ///
    /// # Returns
    /// - Parent process: Returns child's PID
    /// - Child process: Returns 0
    pub fn fork(&self) -> Result<ProcessId, &'static str> {
        // Implementation in next section
    }
}
```

### 2.2 实现fork逻辑

**fork需要做什么？**

1. 分配新PID
2. 复制PCB字段
3. 复制地址空间（本节简化，共享地址空间）
4. 复制上下文
5. 设置子进程返回值为0
6. 建立父子关系
7. 将子进程加入调度队列

**完整实现**：

```rust
impl ProcessControlBlock {
    /// Fork current process
    pub fn fork(&self) -> Result<ProcessId, &'static str> {
        use crate::process::pid::ProcessId;
        use crate::process::scheduler;
        use alloc::sync::Arc;
        use spin::Mutex;

        // 1. Allocate new PID for child
        let child_pid = ProcessId::new();

        serial_println!("[FORK] Creating child process, parent={}, child={}",
            self.pid, child_pid);

        // 2. Copy PCB fields
        let mut child_pcb = ProcessControlBlock {
            // Identity
            pid: child_pid,
            name: self.name,

            // State
            state: ProcessState::Ready,
            exit_code: None,

            // Relationships
            parent_pid: Some(self.pid),
            children: Vec::new(),

            // Context (will modify return value)
            context: self.context,

            // Memory management
            address_space: self.address_space,
            heap_bottom: self.heap_bottom,
            heap_top: self.heap_top,

            // Scheduling
            time_slice: 5,  // Default time slice
            priority: self.priority,
        };

        // 3. Set child's return value to 0
        // In RISC-V, a0 register holds return value
        child_pcb.context.set_return_value(0);

        // 4. Wrap in Arc<Mutex<>>
        let child_handle = Arc::new(Mutex::new(child_pcb));

        // 5. Add to scheduler
        scheduler::add_process(child_handle.clone());

        serial_println!("[FORK] Child process created successfully");

        Ok(child_pid)
    }
}
```

**关键点解析**：

| 步骤 | 说明 | 原因 |
|------|------|------|
| 分配新PID | `ProcessId::new()` | 子进程需要唯一标识 |
| 复制PCB | 大部分字段直接复制 | 子进程继承父进程属性 |
| 设置父子关系 | `parent_pid: Some(self.pid)` | 用于wait系统调用 |
| 复制上下文 | `context.clone()` | 子进程从fork返回点继续 |
| 设置返回值为0 | `set_return_value(0)` | fork在子进程中返回0 |
| 加入调度队列 | `scheduler::add_process()` | 子进程变为可运行状态 |

### 2.3 添加上下文方法

在 `os/src/process/context.rs` 中添加：

```rust
impl ProcessContext {
    /// Set return value (a0 register in RISC-V)
    pub fn set_return_value(&mut self, value: usize) {
        self.x[10] = value;  // x[10] is a0 register
    }

    /// Get return value
    pub fn get_return_value(&self) -> usize {
        self.x[10]
    }
}
```

**RISC-V调用约定**：
```
寄存器用途：
x10 (a0) - 函数返回值 / 第1个参数
x11 (a1) - 第2个参数
x12 (a2) - 第3个参数
...
```

---

## 步骤3：实现sys_fork系统调用

在 `os/src/syscall/syscall_impl.rs` 中添加：

```rust
/// sys_fork - Create child process
///
/// # Returns
/// - Parent process: child PID
/// - Child process: 0
/// - Error: -1
pub fn sys_fork() -> isize {
    use crate::process::scheduler::current_process;

    serial_println!("[SYSCALL] sys_fork called");

    // 1. Get current process
    let current = match current_process() {
        Some(p) => p,
        None => {
            serial_println!("[SYSCALL] sys_fork: no current process");
            return -1;
        }
    };

    // 2. Call fork method
    let pcb = current.lock();
    match pcb.fork() {
        Ok(child_pid) => {
            serial_println!("[SYSCALL] sys_fork: success, child={}", child_pid);
            child_pid.as_usize() as isize
        }
        Err(e) => {
            serial_println!("[SYSCALL] sys_fork: failed, error={}", e);
            -1
        }
    }
}
```

**错误处理**：
- 如果没有当前进程，返回-1
- 如果fork失败，返回-1
- 成功则返回子进程PID

---

## 步骤4：更新系统调用分发器

在 `os/src/syscall/mod.rs` 的 `syscall_dispatcher` 函数中添加：

```rust
pub fn syscall_dispatcher(context: &SyscallContext) -> isize {
    let syscall_id = SyscallId::from(context.syscall_number);

    serial_println!("[SYSCALL] Dispatching syscall: {:?}", syscall_id);

    match syscall_id {
        SyscallId::Fork => {
            syscall_impl::sys_fork()
        }
        SyscallId::Exit => {
            syscall_impl::sys_exit(context.arg0 as i32)
        }
        SyscallId::GetPid => {
            syscall_impl::sys_getpid()
        }
        // ... other syscalls
        SyscallId::Unknown => {
            serial_println!("[SYSCALL] Unknown syscall: {}", context.syscall_number);
            -1
        }
    }
}
```

---

## 步骤5：添加current_process辅助函数

在 `os/src/process/scheduler.rs` 中添加：

```rust
/// Get current running process
pub fn current_process() -> Option<ProcessHandle> {
    SCHEDULER.lock().current.clone()
}
```

在 `os/src/process/mod.rs` 中导出：

```rust
pub use scheduler::{
    add_process,
    schedule,
    yield_now,
    ready_count,
    current_process,  // NEW
};
```

---

## 步骤6：测试fork

### 6.1 用户态测试程序

创建一个简单的测试：

```rust
// In os/src/main.rs
fn test_fork() {
    println!("Testing fork...");

    let pid = unsafe { syscall(220, 0, 0, 0) };  // syscall 220 = fork

    if pid == 0 {
        // Child process
        println!("[Child] I am the child process!");
        println!("[Child] My parent is {}", unsafe { syscall(172, 0, 0, 0) });
    } else {
        // Parent process
        println!("[Parent] I am the parent process!");
        println!("[Parent] My child is {}", pid);
    }
}

// Syscall wrapper
unsafe fn syscall(id: usize, arg0: usize, arg1: usize, arg2: usize) -> isize {
    let ret: isize;
    core::arch::asm!(
        "ecall",
        in("a7") id,
        in("a0") arg0,
        in("a1") arg1,
        in("a2") arg2,
        lateout("a0") ret,
    );
    ret
}
```

### 6.2 预期输出

```
Testing fork...
[SYSCALL] sys_fork called
[FORK] Creating child process, parent=1, child=2
[FORK] Child process created successfully
[SYSCALL] sys_fork: success, child=2
[Parent] I am the parent process!
[Parent] My child is 2
[Scheduler] Switching to process 2
[Child] I am the child process!
[Child] My parent is 1
```

---

## 知识补充：fork与exec的配合

fork通常与exec配合使用：

```c
int pid = fork();
if (pid == 0) {
    // Child process
    exec("/bin/ls");  // 替换为新程序
} else {
    // Parent process
    wait(pid);  // 等待子进程结束
}
```

**工作流程**：
1. fork创建子进程（复制父进程）
2. 子进程调用exec（替换为新程序）
3. 父进程调用wait（等待子进程）

**这就是shell的工作原理**！

---

## 完整代码：PCB的fork方法

<details>
<summary>点击展开：完整的fork实现</summary>

```rust
// os/src/process/pcb.rs

impl ProcessControlBlock {
    /// Fork current process
    ///
    /// Creates a child process that is a copy of the parent.
    /// The child process inherits:
    /// - Code and data (address space)
    /// - Open file descriptors
    /// - Current working directory
    /// - Register state (except return value)
    ///
    /// The child process gets:
    /// - New PID
    /// - fork() returns 0
    /// - parent_pid set to parent's PID
    ///
    /// # Returns
    /// - Ok(child_pid): Successfully created child process
    /// - Err(msg): Fork failed
    pub fn fork(&self) -> Result<ProcessId, &'static str> {
        use crate::process::pid::ProcessId;
        use crate::process::scheduler;
        use alloc::sync::Arc;
        use spin::Mutex;
        use crate::serial_println;

        // Allocate new PID for child
        let child_pid = ProcessId::new();

        serial_println!("[FORK] Creating child process, parent={}, child={}",
            self.pid, child_pid);

        // Copy PCB
        let mut child_pcb = ProcessControlBlock {
            // Identity
            pid: child_pid,
            name: self.name,

            // State
            state: ProcessState::Ready,
            exit_code: None,

            // Relationships
            parent_pid: Some(self.pid),
            children: Vec::new(),

            // Context (will modify return value)
            context: self.context.clone(),

            // Memory (simplified: share for now)
            address_space: self.address_space.clone(),
            heap_bottom: self.heap_bottom,
            heap_top: self.heap_top,

            // Scheduling
            time_slice: DEFAULT_TIME_SLICE,
            priority: self.priority,
        };

        // Set child's return value to 0
        child_pcb.context.set_return_value(0);

        // Wrap in Arc<Mutex<>>
        let child_handle = Arc::new(Mutex::new(child_pcb));

        // Add child to parent's children list
        // (We'll do this in next section to avoid deadlock)

        // Add to scheduler
        scheduler::add_process(child_handle.clone());

        serial_println!("[FORK] Child process created successfully");

        Ok(child_pid)
    }
}
```

</details>

---

## 常见问题

**Q1: 为什么fork要复制整个地址空间？**

这是Unix的设计哲学：创建一个完全独立的进程。但现代系统使用写时复制（COW）优化，避免不必要的复制。

**Q2: fork后父子进程谁先运行？**

不确定。这取决于调度器的决策。不应该依赖特定的执行顺序。

**Q3: 如果fork失败怎么办？**

返回-1。常见原因：
- 内存不足
- 进程数达到上限
- 权限不足

**Q4: fork能创建多少层子进程？**

理论上无限，但受限于：
- 内存大小
- 最大进程数
- 栈深度

---

## 知识点总结

### 核心概念

| 概念 | 说明 | 作用 |
|------|------|------|
| **fork** | 创建子进程 | Unix进程创建的基础 |
| **写时复制** | 共享内存直到写入 | 优化fork性能 |
| **父子关系** | parent_pid字段 | 用于wait和进程管理 |

### 设计决策

| 决策 | 原因 |
|------|------|
| 为什么返回两次？ | 父子进程各自继续执行 |
| 为什么子进程返回0？ | 区分父子进程，0是无效PID |
| 为什么复制上下文？ | 子进程从fork返回点继续 |

---

## 下一步

现在已经实现了fork，下一节将实现**exec系统调用**，允许进程替换为新程序。

---

## 练习题

1. 修改fork，让子进程继承父进程的优先级+1
2. 实现fork统计：记录系统总共fork了多少次
3. 思考：如果fork时不复制上下文会怎样？
