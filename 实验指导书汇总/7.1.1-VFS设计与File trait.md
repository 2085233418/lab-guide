# 7.1.1 VFS设计与File trait

## 本节目标

- 理解VFS（虚拟文件系统）的设计哲学
- 理解Trait Object的概念
- 定义File trait统一文件操作接口
- 实现FileError和相关类型

```
本章节实验环境内有系统运行效果演示动画，请在OS路径下运行以下指令运行：
当前路径：../os
终端输入：
$ cd ..
$ ./start.sh
（需要确保有python3环境）
```

---

## 本节新增文件

```text
os/src/fs/
├── mod.rs          # 文件系统模块入口
└── file.rs         # File trait定义
```

---

## 前置要求

在开始本章之前，请确认：

- 已完成第6章轮转调度实现
- 代码中使用了 `trap` 模块（而非 `interrupts.rs`）
- 系统能够正常启动和运行

---

## 什么是VFS？

在本章中，我们将实现一个**虚拟文件系统（Virtual File System，VFS）**。在开始实现之前，先理解VFS的核心思想。

### "一切皆文件"的统一接口

VFS是一个**抽象层**，它的核心思想是：**通过统一的接口（read/write/seek）操作不同类型的资源**。

```text
用户程序调用 read()
    ↓
VFS层：File trait
    ↓
具体实现：普通文件 / 设备 / 管道 / ...
```

**为什么需要VFS？**

- **统一接口**：用户程序用同样的 `read()`/`write()` 操作文件、设备、管道
- **易于扩展**：添加新文件系统时，只需实现统一的trait即可
- **简化设计**：应用层无需关心底层是磁盘、内存还是网络

>  **关于架构选型**：我们采用类Unix的VFS设计，详见[章节README](README.md#设计理念为何选择类unix的vfs架构)了解完整的架构选型理由。

### 本节要做什么？

我们将定义VFS的核心接口：`File` trait，它是所有文件类型的统一抽象。为了实现这个trait，我们需要先理解Rust中的**Trait Object**机制。

---

## 步骤1：理解 Trait Object—Rust 动态多态的核心

在实现 VFS 的 `File` trait 前，我们需要掌握 **Trait Object（特征对象）** 这一关键概念，它是 Rust 实现**动态多态**的核心机制。

- ### 静态分发 vs 动态分发：代码对比

  我们通过代码直观对比两种分发方式：

  ```rust
  // 定义一个简单的 File trait（接口）
  trait File {
      fn read(&self) -> Vec<u8>;
  }
  
  // 实现1：磁盘文件
  struct DiskFile;
  impl File for DiskFile {
      fn read(&self) -> Vec<u8> { vec![1, 2, 3] }
  }
  
  // 实现2：内存文件
  struct MemoryFile;
  impl File for MemoryFile {
      fn read(&self) -> Vec<u8> { vec![4, 5, 6] }
  }
  ```

  #### 方式 1：静态分发（泛型函数）

  ```rust
  // 泛型函数：T 必须实现 File trait
  fn process_file<T: File>(file: &T) {
      let data = file.read();  // 编译时确定调用哪个 read 实现
  }
  
  fn main() {
      let disk_file = DiskFile;
      let mem_file = MemoryFile;
      
      // 编译时，编译器会为 DiskFile 和 MemoryFile 分别生成两个独立的函数版本
      process_file(&disk_file);  // 调用：process_file::<DiskFile>(&disk_file)
      process_file(&mem_file);   // 调用：process_file::<MemoryFile>(&mem_file)
  }
  ```

  **特点**：

  - 编译时确定类型，**性能高**（直接调用，无额外开销）
  - 但**灵活性低**：无法在运行时动态切换类型

  #### 方式 2：动态分发（Trait Object）

  ```rust
  // 动态分发函数：参数是 &dyn File（Trait Object）
  fn process_file_dynamic(file: &dyn File) {
      let data = file.read();  // 运行时通过虚表查找具体的 read 实现
  }
  
  fn main() {
      let disk_file = DiskFile;
      let mem_file = MemoryFile;
      
      // 运行时，根据 file 指向的实际类型调用对应方法
      process_file_dynamic(&disk_file);  // 运行时知道是 DiskFile
      process_file_dynamic(&mem_file);   // 运行时知道是 MemoryFile
  }
  ```

  **核心机制**：

  &dyn File是一个rait Object，包含两部分：

  1. **数据指针**：指向具体类型的实例（如 `DiskFile` 或 `MemoryFile`）
  2. **虚表（vtable）指针**：指向编译时生成的 “方法查找表”，存储了该类型实现的所有 trait 方法地址

  - 调用 `file.read()` 时，Rust 会通过虚表查找 `read` 方法的具体地址，然后跳转执行

### 1.2 为什么VFS需要Trait Object？

VFS 的核心需求是**支持多种文件系统和设备**，但它们的实现细节各不相同。Trait Object 恰好解决了这个问题：

```rust
// FD表需要存储不同类型的文件
let fd_table: Vec<Option<Arc<Mutex<dyn File>>>> = vec![
    Some(Arc::new(Mutex::new(Stdin))),   // 标准输入
    Some(Arc::new(Mutex::new(Stdout))),  // 标准输出
    Some(Arc::new(Mutex::new(RamFile))), // RamFS文件
];
```

**关键点**：

- `Stdin`, `Stdout`, `RamFile` 都实现了 `File` trait
- 但它们是不同的类型
- `dyn File` 允许我们用统一的类型存储它们

### 1.3 Send + Sync约束

```rust
pub trait File: Send + Sync {
    // ...
}
```

**Send**：可以安全地在线程间转移所有权
**Sync**：可以安全地在多线程间共享引用

**为什么需要**：

- VFS 中的文件可能被多个进程 / 线程同时访问（如共享文件）
- 磁盘设备、网络套接字等硬件资源的并发访问需要严格控制
- `Send + Sync` 约束确保了实现 `File` trait 的类型**天生具备并发安全性**，无需额外的同步机制

---

## 步骤2：定义File Trait

### 2.1 创建file.rs文件

创建 `os/src/fs/file.rs`：

**文件路径：`os/src/fs/file.rs`**

```rust
//! File抽象
//!
//! 提供所有文件类型的统一接口

use alloc::vec::Vec;
use core::fmt;
```

### 2.2 定义File trait核心方法

**文件路径：`os/src/fs/file.rs`**

```rust
/// File trait - 统一的文件操作接口
///
/// 所有文件类型（普通文件、目录、设备）都必须实现此trait
pub trait File: Send + Sync {
    /// 读取数据到缓冲区
    ///
    /// # 返回值
    /// - Ok(n): 成功读取n字节
    /// - Err(e): 读取失败，错误码e
    fn read(&mut self, buf: &mut [u8]) -> Result<usize, FileError>;

    /// 从缓冲区写入数据
    ///
    /// # 返回值
    /// - Ok(n): 成功写入n字节
    /// - Err(e): 写入失败，错误码e
    fn write(&mut self, buf: &[u8]) -> Result<usize, FileError>;

    /// 移动文件读写位置
    ///
    /// # 默认实现
    /// 默认返回InvalidOperation（不是所有文件都支持seek）
    fn seek(&mut self, pos: SeekFrom) -> Result<usize, FileError> {
        Err(FileError::InvalidOperation)
    }
}
```

**设计要点**：

1. **trait object**：使用 `dyn File` 实现运行时多态
2. **Send + Sync**：确保线程安全
3. **默认实现**：seek提供默认实现，返回错误

### 2.3 定义SeekFrom枚举

`SeekFrom` 定义了文件随机访问时的**起始参考点**，支持从文件的不同位置开始移动。

**应用场景**：

- 读取文件头/尾（快速跳到开头或末尾）
- 数据库文件（根据索引跳转到记录位置）
- 媒体播放（拖动进度条时跳转）
- 大文件处理（只读取特定区域）

**文件路径：`os/src/fs/file.rs`**

```rust
/// Seek起始位置
#[derive(Debug, Clone, Copy)]
pub enum SeekFrom {
    Start(usize),       // 从文件开头（绝对位置）
    Current(isize),     // 从当前位置（相对位置，可正可负）
    End(isize),         // 从文件末尾（相对位置，通常为负数）
}
```

**为什么Current和End使用isize？**

需要支持负数偏移：`Current(-10)` 表示往前移动10字节，`End(-5)` 表示从末尾往前5字节。

### 2.4 SeekFrom使用示例

```text
文件内容: [0][1][2][3][4][5][6][7][8][9]  (10字节)
当前位置: offset = 5

SeekFrom::Start(3)    -> offset = 3
SeekFrom::Current(2)  -> offset = 5 + 2 = 7
SeekFrom::Current(-3) -> offset = 5 - 3 = 2
SeekFrom::End(0)      -> offset = 10
SeekFrom::End(-2)     -> offset = 10 - 2 = 8
```

---

## 步骤3：定义错误类型和辅助类型

### 3.1 定义FileError错误类型

文件操作可能因多种原因失败，定义清晰的错误类型有助于精确定位问题、提供有用信息并支持错误恢复。

我们定义8种核心错误，覆盖POSIX系统最常见的文件错误（相比Linux的100+错误码，这是简化但够用的设计）：

**文件路径：`os/src/fs/file.rs`**

```rust
/// File operation errors
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FileError {
    NotFound,           // 文件不存在 (ENOENT)
    PermissionDenied,   // 权限不足 (EACCES)
    EndOfFile,          // 到达文件末尾
    InvalidOperation,   // 无效操作 (EINVAL)
    IoError,            // I/O错误 (EIO)
    AlreadyExists,      // 文件已存在 (EEXIST)
    NotDirectory,       // 不是目录 (ENOTDIR)
    IsDirectory,        // 是目录 (EISDIR)
}
```

**常见错误场景**：

| 错误类型 | 典型场景 | 处理方式 |
|---------|---------|---------|
| `NotFound` | 打开不存在的文件 | 检查路径或创建文件 |
| `PermissionDenied` | 访问无权限的文件 | 检查权限设置 |
| `InvalidOperation` | 对设备执行不支持的操作（如seek stdin） | 检查文件类型 |
| `IoError` | 磁盘故障、网络中断 | 重试或报告硬件错误 |

### 3.2 实现FileError的Display trait

**文件路径：`os/src/fs/file.rs`**

```rust
impl fmt::Display for FileError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            FileError::NotFound => write!(f, "File not found"),
            FileError::PermissionDenied => write!(f, "Permission denied"),
            FileError::EndOfFile => write!(f, "End of file"),
            FileError::InvalidOperation => write!(f, "Invalid operation"),
            FileError::IoError => write!(f, "I/O error"),
            FileError::AlreadyExists => write!(f, "File already exists"),
            FileError::NotDirectory => write!(f, "Not a directory"),
            FileError::IsDirectory => write!(f, "Is a directory"),
        }
    }
}
```

**注意**：所有输出使用英文，避免终端输出编码问题。

### 3.3 定义FileType枚举

在Unix的"一切皆文件"哲学中，不同类型的"文件"有不同的行为。`FileType` 帮助系统：

- 正确处理操作（目录用readdir，设备用ioctl）
- 执行权限检查
- 防止错误操作（如写入目录）

**文件路径：`os/src/fs/file.rs`**

```rust
/// 文件类型
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FileType {
    RegularFile,    // 普通文件
    Directory,      // 目录
    SymbolicLink,   // 符号链接
    CharDevice,     // 字符设备
    BlockDevice,    // 块设备
    Pipe,           // 管道
}
```

**6种类型说明**（对应POSIX标准）：

| 类型 | 用途 | 示例 | 特点 |
|------|------|------|------|
| `RegularFile` | 普通文件 | 文本、程序、图片 | 支持read/write/seek |
| `Directory` | 目录 | `/home`、`/usr/bin` | 存储文件名到inode的映射 |
| `SymbolicLink` | 符号链接 | `/usr/bin/python -> python3.9` | 存储目标路径 |
| `CharDevice` | 字符设备 | `/dev/tty`（终端） | 流式传输，不支持随机访问 |
| `BlockDevice` | 块设备 | `/dev/sda`（硬盘） | 按块传输，支持随机访问 |
| `Pipe` | 管道 | `ls \| grep` | FIFO队列，进程间通信 |

> **字符设备 vs 块设备**：字符设备（如键盘）流式传输数据，不可seek；块设备（如硬盘）按块读写，可随机访问。

### 3.4 定义FileMetadata结构

**文件路径：`os/src/fs/file.rs`**

```rust
/// 文件元数据
#[derive(Debug, Clone)]
pub struct FileMetadata {
    pub file_type: FileType,
    pub size: usize,
    pub mode: u32,
    pub created: u64,
    pub modified: u64,
}
```

---

## 知识点总结

### VFS核心思想

| 概念 | 说明 |
|------|------|
| 统一接口 | 不同文件系统使用相同的trait |
| 动态分发 | 使用trait object支持不同实现 |
| 线程安全 | Send + Sync保证并发安全 |

### Trait Object vs 泛型

| 特性 | Trait Object (dyn File) | 泛型 (<T: File>) |
|------|------------------------|-----------------|
| 性能 | 运行时查表，稍慢 | 编译时特化，快 |
| 灵活性 | 可存储不同类型 | 同一类型 |
| 代码大小 | 小 | 每个类型生成副本 |

---

## 下一步

在下一节（7.1.2）中，我们将实现Inode抽象和权限管理系统。

---

## 常见问题

### Q1: 为什么seek需要默认实现？

不是所有文件都支持seek操作：

- 普通文件：支持seek
- 终端设备：不支持seek（stdin/stdout）
- 网络socket：不支持seek

### Q2: 为什么用isize而不是usize作为Current/End的参数？

因为需要支持负数偏移：

- `Current(-10)` - 往前移动10字节
- `End(-5)` - 从末尾往前5字节
