## 2.5 异常分发器

现在我们实现 Rust 端的异常处理函数。

#### 根据 scause 分发异常

**实现 trap_handler 函数**

在 `src/trap/mod.rs` 中添加：

```rust
// src/trap/mod.rs

/// Rust 异常处理函数
#[no_mangle]
pub extern "C" fn trap_handler(ctx: &mut TrapContext) {
    let scause = scause::read();
    let stval = stval::read();
    let sepc = sepc::read();

    // 打印异常信息（调试用）
    println!("[Trap] scause: {:?}, stval: 0x{:x}, sepc: 0x{:x}",
             scause.cause(), stval, sepc);

    // 根据异常类型分发
    match scause.cause() {
        Trap::Exception(Exception::Breakpoint) => {
            handle_breakpoint(ctx);
        }
        Trap::Exception(Exception::IllegalInstruction) => {
            handle_illegal_instruction(ctx);
        }
        Trap::Exception(Exception::UserEnvCall) => {
            handle_syscall(ctx);
        }
        Trap::Interrupt(Interrupt::SupervisorTimer) => {
            handle_timer_interrupt(ctx);
        }
        _ => {
            panic!("Unhandled trap: {:?}", scause.cause());
        }
    }
}
```

---

#### 实现断点异常处理 (ebreak)

**什么是断点异常？**

执行 `ebreak` 指令会触发断点异常，常用于调试。

**处理逻辑**

1. 打印断点信息
2. 将 `sepc += 2`（跳过 `ebreak` 指令）
   - **注意**：`ebreak` 可能是 2 字节（压缩指令）或 4 字节

```rust
// src/trap/mod.rs

fn handle_breakpoint(ctx: &mut TrapContext) {
    println!("[Trap] Breakpoint at 0x{:x}", ctx.sepc);

    // 跳过 ebreak 指令
    // 注意：ebreak 在压缩指令集中是 2 字节，否则是 4 字节
    // 简单起见，我们假设是压缩指令
    ctx.sepc += 2;
}
```

**测试断点异常**

在 `kernel_main` 中添加：

```rust
#[no_mangle]
pub extern "C" fn kernel_main() {
    println!("Hello, RISC-V!");
    trap::init();

    // 触发断点异常
    unsafe {
        core::arch::asm!("ebreak");
    }

    println!("Breakpoint handled!");
}
```

---

#### 实现非法指令异常处理

**什么是非法指令异常？**

执行不存在或不支持的指令会触发非法指令异常。

**处理逻辑**

非法指令通常是严重错误，我们直接 panic：

```rust
// src/trap/mod.rs

fn handle_illegal_instruction(ctx: &mut TrapContext) {
    let stval = stval::read();
    panic!("[Trap] Illegal instruction at 0x{:x}, instruction: 0x{:x}",
           ctx.sepc, stval);
}
```

**测试非法指令异常**

在 `kernel_main` 中添加：

```rust
// 触发非法指令异常
unsafe {
    core::arch::asm!(".word 0x00000000");  // 全 0 是非法指令
}
```

---

#### 实现系统调用异常处理 (ecall)

**什么是系统调用？**

用户程序通过 `ecall` 指令请求内核服务，会触发 `Environment Call` 异常。

**系统调用约定**

- `a7`（x17）：系统调用号
- `a0`-`a6`（x10-x16）：参数
- `a0`（x10）：返回值

**处理逻辑**

```rust
// src/trap/mod.rs

fn handle_syscall(ctx: &mut TrapContext) {
    let syscall_num = ctx.x[17];  // a7
    let args = [
        ctx.x[10],  // a0
        ctx.x[11],  // a1
        ctx.x[12],  // a2
    ];

    println!("[Trap] Syscall {} called with args: {:?}", syscall_num, args);

    // 简单示例：返回固定值
    ctx.x[10] = 42;  // a0 = 返回值

    // 跳过 ecall 指令（4 字节）
    ctx.sepc += 4;
}
```

**测试系统调用**

在 `kernel_main` 中添加：

```rust
// 触发系统调用
let result: usize;
unsafe {
    core::arch::asm!(
        "ecall",
        in("a7") 1,    // 系统调用号 = 1
        in("a0") 100,  // 参数 1 = 100
        lateout("a0") result,  // 返回值
    );
}
println!("Syscall returned: {}", result);
```

---

#### 实现页面错误处理（占位）

页面错误处理将在第4章（虚拟内存）中详细实现。这里我们先添加一个占位函数：

```rust
// src/trap/mod.rs

fn handle_page_fault(ctx: &mut TrapContext) {
    let stval = stval::read();
    panic!("[Trap] Page fault at address 0x{:x}, sepc: 0x{:x}",
           stval, ctx.sepc);
}
```

在 `trap_handler` 中添加：

```rust
match scause.cause() {
    // ...
    Trap::Exception(Exception::LoadPageFault) |
    Trap::Exception(Exception::StorePageFault) |
    Trap::Exception(Exception::InstructionPageFault) => {
        handle_page_fault(ctx);
    }
    // ...
}
```
