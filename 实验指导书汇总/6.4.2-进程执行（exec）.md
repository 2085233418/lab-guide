# 6.4.2 进程执行（exec）

> **重要说明**本节提供的是**简化版框架实现**
>
> **为什么是简化版？**
>
> - exec需要从文件系统加载ELF可执行文件
> - 但第6章尚未实现文件系统（VFS、open、read等）
> - 本节使用硬编码数据演示exec的核心机制
>
> **完整实现时机**：
> - 学习完第7章文件系统后
> - 使用`sys_open()`和`sys_read()`加载真实ELF文件
> - 详见 [章节README的依赖关系说明](README.md#64节与第7章的依赖关系)
>
> **本节学习重点**：
> -  理解exec的工作原理和流程
> -  学习ELF文件格式解析
> -  掌握进程地址空间替换
> -  文件加载部分为占位符实现（第7章完善）

## 本节目标

- 理解exec系统调用的原理
- 实现exec系统调用
- 加载ELF可执行文件格式
- 替换进程地址空间
- 测试程序执行

---

## 前置要求

**重要**：本节依赖6.4.1中添加的PCB内存管理字段。如果你直接跳到本节，请先完成6.4.1的"步骤0"，添加以下字段：

```rust
// os/src/process/pcb.rs - ProcessControlBlock 结构体中
address_space: Option<usize>,  // 页表基址
heap_bottom: usize,            // 堆起始地址
heap_top: usize,               // 堆结束地址
```

这些字段在6.4.1的"步骤0：补充PCB内存管理字段"中已详细说明。

---

## 本节修改文件

```
os/src/
├── syscall/
│   ├── mod.rs              # 已有Exec系统调用号
│   └── syscall_impl.rs     # 实现sys_exec（新增）
├── process/
│   ├── mod.rs              # 导出exec相关函数（修改）
│   ├── pcb.rs              # 添加exec方法（修改）
│   └── elf.rs              # ELF加载器（新建）
└── main.rs                 # 添加测试代码（修改）
```

---

## 什么是exec？

**exec** 是Unix/Linux中替换当前进程映像的系统调用。

### exec的特点

```
调用前:
  进程运行程序A
  PID = 100

exec("/bin/ls")调用:
  清空原有地址空间
  加载新程序
  重置栈和堆

调用后:
  进程运行程序B
  PID = 100 (不变!)
  但代码和数据完全不同
```

**类比**：就像换芯片
- 手机外壳不变（PID不变）
- 内部主板完全更换（代码和数据替换）
- 手机功能完全改变

### fork与exec的配合

```c
// Shell的工作原理
int pid = fork();         // 1. 复制进程
if (pid == 0) {
    exec("/bin/ls");      // 2. 子进程替换为新程序
    // exec成功后，这里的代码不会执行
}
// 父进程继续运行shell
```

**为什么分成两步？**
- fork：创建新进程
- exec：加载新程序
- 分离关注点，灵活组合

---

## 知识补充：exec的执行流程

```
用户态:
  exec("/bin/ls")
    ↓
    ecall
    ↓
内核态:
  sys_exec("/bin/ls")
    ↓
  1. 解析路径，查找文件
  2. 读取文件内容
  3. 验证ELF格式
  4. 清空旧地址空间
  5. 创建新地址空间
  6. 加载程序段（代码段、数据段）
  7. 设置栈空间
  8. 重置寄存器
  9. 设置PC为程序入口
    ↓
  返回用户态
    ↓
  新程序开始执行
```

**关键点**：
- exec不创建新进程（PID不变）
- exec不返回（成功则进入新程序）
- exec失败才返回-1

---

## 知识补充：ELF文件格式

**ELF（Executable and Linkable Format）** 是Linux的可执行文件格式。

### ELF文件结构

![p9](pictures/p6-9.png)

### ELF Header关键字段

```rust
struct ElfHeader {
    magic: [u8; 4],        // 0x7F, 'E', 'L', 'F'
    class: u8,             // 1=32位, 2=64位
    endian: u8,            // 1=小端, 2=大端
    version: u8,           // ELF版本
    // ...
    entry: u64,            // 程序入口地址
    phoff: u64,            // Program Header偏移
    // ...
}
```

**最关键的字段**：
- `magic`：验证是否是ELF文件
- `entry`：程序入口地址（main函数地址）
- `phoff`：程序头表位置

### Program Header（程序头）

```rust
struct ProgramHeader {
    type: u32,      // PT_LOAD=1（需要加载）
    offset: u64,    // 文件偏移
    vaddr: u64,     // 虚拟地址
    paddr: u64,     // 物理地址
    filesz: u64,    // 文件中大小
    memsz: u64,     // 内存中大小
    flags: u32,     // 权限：R/W/X
    align: u64,     // 对齐
}
```

**加载过程**：
```
for each PT_LOAD segment:
  1. 分配内存：vaddr -> memsz字节
  2. 复制数据：从文件offset处复制filesz字节
  3. 清零BSS：如果memsz > filesz，清零多余部分
  4. 设置权限：根据flags设置页表权限
```

---

## 步骤1：创建简化的ELF加载器

由于完整的ELF加载器非常复杂，我们实现一个简化版本。

创建 `os/src/process/elf.rs`：

```rust
//! Simple ELF loader
//!
//! Supports basic ELF64 loading for RISC-V

use alloc::vec::Vec;
use crate::serial_println;

/// ELF magic number
const ELF_MAGIC: [u8; 4] = [0x7f, b'E', b'L', b'F'];

/// Verify ELF magic number
pub fn verify_elf(data: &[u8]) -> Result<(), &'static str> {
    if data.len() < 4 {
        return Err("File too small");
    }

    if &data[0..4] != ELF_MAGIC {
        return Err("Not an ELF file");
    }

    serial_println!("[ELF] Valid ELF magic number found");
    Ok(())
}

/// Get ELF entry point
///
/// # ELF Header Layout (simplified for 64-bit)
/// Offset | Size | Field
/// -------|------|-------
/// 0x00   | 16   | Magic + identification
/// 0x10   | 2    | Type
/// 0x12   | 2    | Machine
/// 0x14   | 4    | Version
/// 0x18   | 8    | Entry point
pub fn get_entry_point(data: &[u8]) -> Result<usize, &'static str> {
    if data.len() < 0x20 {
        return Err("ELF header incomplete");
    }

    // Entry point at offset 0x18 (24 bytes)
    let entry = u64::from_le_bytes([
        data[0x18], data[0x19], data[0x1a], data[0x1b],
        data[0x1c], data[0x1d], data[0x1e], data[0x1f],
    ]);

    serial_println!("[ELF] Entry point: {:#x}", entry);
    Ok(entry as usize)
}

/// Simple ELF loader
///
/// # Simplifications
/// - Assumes entire ELF fits in memory
/// - Loads at fixed address
/// - Ignores complex relocations
pub fn load_elf(data: &[u8]) -> Result<usize, &'static str> {
    // 1. Verify ELF
    verify_elf(data)?;

    // 2. Get entry point
    let entry = get_entry_point(data)?;

    // 3. For now, we'll just return the entry point
    // Full implementation would:
    // - Parse program headers
    // - Allocate memory for each PT_LOAD segment
    // - Copy data from file to memory
    // - Set up page table permissions

    serial_println!("[ELF] ELF loaded successfully");

    Ok(entry)
}
```

**简化说明**：
- 我们只验证ELF魔数
- 只提取入口点地址
- 完整实现需要解析程序头表并加载各段

---

## 步骤2：实现PCB的exec方法

在 `os/src/process/pcb.rs` 中添加：

```rust
impl ProcessControlBlock {
    /// Execute new program
    ///
    /// Replaces the current process's address space with a new program.
    /// If successful, this function does not return (jumps to new program).
    /// If failed, returns error and process continues.
    ///
    /// # Parameters
    /// - `path`: Path to executable file
    ///
    /// # Returns
    /// - Ok(()): Never returns (jumps to new program)
    /// - Err(msg): Exec failed, process continues
    pub fn exec(&mut self, path: &str) -> Result<(), &'static str> {
        use crate::process::elf;
        use crate::serial_println;

        serial_println!("[EXEC] Loading program: {}", path);

        // 1. Load file content (simplified: embedded in kernel for now)
        let program_data = load_program(path)?;

        // 2. Verify and parse ELF
        let entry_point = elf::load_elf(program_data)?;

        serial_println!("[EXEC] Entry point: {:#x}", entry_point);

        // 3. Clear old address space
        self.address_space = None;

        // 4. Create new address space (simplified)
        // In a real OS, we would:
        // - Create new page table
        // - Map program segments
        // - Set up stack
        // - Set up heap

        // 5. Reset context
        self.context.reset();
        self.context.set_pc(entry_point);

        // 6. Reset heap
        self.heap_bottom = 0;
        self.heap_top = 0;

        // 7. Update process name (note: lifetime issue, keep old name for now)
        // self.name = path;  // Can't do this because of 'static lifetime

        serial_println!("[EXEC] Program loaded successfully");

        Ok(())
    }
}
```

### 添加上下文辅助方法

在 `os/src/process/context.rs` 中添加：

```rust
impl ProcessContext {
    /// Reset all registers to 0
    pub fn reset(&mut self) {
        for i in 0..31 {
            self.x[i] = 0;
        }
        self.sepc = 0;
        self.sstatus = 0;
    }

    /// Set program counter (PC)
    pub fn set_pc(&mut self, pc: usize) {
        self.sepc = pc;
    }

    /// Get program counter
    pub fn get_pc(&self) -> usize {
        self.sepc
    }
}
```

**RISC-V上下文**：
- `sepc`：Supervisor Exception Program Counter
- 保存异常返回地址
- exec设置为新程序入口
- `reset()` 清空所有寄存器，包括 sepc 和 sstatus

---

## 步骤3：实现程序加载（简化版）

> ** 本步骤是占位符实现**
>
> 这是本节最关键的简化点！真实的exec需要：
>
> ```rust
> // 完整实现（需要第7章）
> let fd = sys_open(path, O_RDONLY)?;
> let mut elf_data = Vec::new();
> sys_read(fd, &mut elf_data)?;
> sys_close(fd)?;
> ```
>
> 但第6章还没有文件系统，所以使用硬编码数据模拟。

在 `os/src/process/pcb.rs` 中添加辅助函数：

```rust
/// Load program from embedded data
///
/// # SIMPLIFIED PLACEHOLDER IMPLEMENTATION
///
/// This is a temporary implementation for Chapter 6.
///
/// ## What's missing?
/// In a real OS, this function would:
/// 1. Open file from filesystem using sys_open()
/// 2. Read file content using sys_read()
/// 3. Close file using sys_close()
///
/// ## Why simplified?
/// - Chapter 6 focuses on process management concepts
/// - File system (VFS, open, read) is implemented in Chapter 7
/// - This placeholder lets us test exec's core logic
///
/// ## When to replace?
/// After completing Chapter 7, replace this with:
/// ```rust
/// let fd = open(path, O_RDONLY)?;
/// let mut data = Vec::new();
/// read(fd, &mut data)?;
/// close(fd)?;
/// Ok(data)
/// ```
fn load_program(path: &str) -> Result<&'static [u8], &'static str> {
    match path {
        "test_program" => {
            // Embedded test program (minimal ELF)
            // This is a placeholder - real ELF would be larger
            static TEST_PROGRAM: &[u8] = &[
                0x7f, b'E', b'L', b'F',  // ELF magic
                // ... more ELF header bytes ...
            ];
            Ok(TEST_PROGRAM)
        }
        _ => Err("Program not found"),
    }
}
```

**关键说明**：

| 方面 | 当前实现（第6章） | 完整实现（第7章后） |
|------|----------------|-------------------|
| 数据来源 | 硬编码在内核中 | 从文件系统读取 |
| 路径解析 | 字符串匹配 | VFS路径解析 |
| 文件操作 | 无 | open/read/close |
| 灵活性 | 只能加载预定义程序 | 可加载任意ELF文件 |
| 依赖 | 无 | 需要第7章文件系统 |

**为什么这样做？**

1. **教学分离**：先学习exec的核心概念（地址空间替换、ELF解析），再学习文件加载
2. **可测试性**：即使没有文件系统，也能测试exec的基本流程
3. **真实开发**：实际OS开发也是迭代的，先实现框架，再完善功能

**这是极度简化的版本。实际系统中会：**

1. 从文件系统读取文件
2. 完整解析ELF格式
3. 创建新的页表
4. 加载所有段到内存

---

## 步骤4：实现sys_exec系统调用

在 `os/src/syscall/syscall_impl.rs` 中添加：

```rust
/// sys_exec - Execute program
///
/// # Parameters
/// - path: Pointer to C string (program path)
///
/// # Returns
/// - Does not return if successful (jumps to new program)
/// - Returns -1 if failed
pub fn sys_exec(path: *const u8) -> isize {
    use crate::process::scheduler::current_process;
    use crate::serial_println;

    serial_println!("[SYSCALL] sys_exec called");

    // 1. Validate pointer
    if path.is_null() {
        serial_println!("[SYSCALL] sys_exec: null pointer");
        return -1;
    }

    // 2. Parse C string
    let path_str = unsafe {
        let mut len = 0;
        while *path.add(len) != 0 {
            len += 1;
            if len > 256 {
                serial_println!("[SYSCALL] sys_exec: path too long");
                return -1;
            }
        }

        // Convert to Rust string
        let slice = core::slice::from_raw_parts(path, len);
        match core::str::from_utf8(slice) {
            Ok(s) => s,
            Err(_) => {
                serial_println!("[SYSCALL] sys_exec: invalid UTF-8");
                return -1;
            }
        }
    };

    serial_println!("[SYSCALL] sys_exec: path={}", path_str);

    // 3. Get current process
    let current = match current_process() {
        Some(p) => p,
        None => {
            serial_println!("[SYSCALL] sys_exec: no current process");
            return -1;
        }
    };

    // 4. Execute program
    let mut pcb = current.lock();
    match pcb.exec(path_str) {
        Ok(_) => {
            // Success - will jump to new program
            // This code should not be reached
            serial_println!("[SYSCALL] sys_exec: unexpected return");
            0
        }
        Err(e) => {
            serial_println!("[SYSCALL] sys_exec: failed, error={}", e);
            -1
        }
    }
}
```

**关键点**：
1. **C字符串解析**：与第7章sys_open相同的处理
2. **路径验证**：检查长度和UTF-8编码
3. **exec不返回**：成功时跳转到新程序

---

## 知识补充：C字符串处理

### 什么是C字符串？

```
内存布局:
['h']['e']['l']['l']['o']['\0']
  0    1    2    3    4    5

特点:
- 以'\0'结尾
- 不存储长度信息
- 需要遍历才能知道长度
```

### 为什么需要解析C字符串？

用户态程序使用C语言编写，传递字符串时：
```c
// 用户态
char path[] = "test_program";
exec(path);  // 传递的是指针
```

内核需要：
1. 验证指针有效
2. 查找'\0'终止符
3. 计算字符串长度
4. 验证UTF-8编码
5. 转换为Rust字符串

### 安全检查

```rust
// 1. 检查空指针
if path.is_null() { return -1; }

// 2. 限制长度（防止恶意输入）
if len > 256 { return -1; }

// 3. 验证UTF-8
match core::str::from_utf8(slice) {
    Ok(s) => s,
    Err(_) => return -1,
}
```

---

## 步骤5：更新系统调用分发器

在 `os/src/syscall/mod.rs` 中添加：

```rust
pub fn syscall_dispatcher(context: &SyscallContext) -> isize {
    let syscall_id = SyscallId::from(context.syscall_number);

    match syscall_id {
        SyscallId::Exec => {
            syscall_impl::sys_exec(context.arg0 as *const u8)
        }
        SyscallId::Fork => {
            syscall_impl::sys_fork()
        }
        // ... other syscalls
    }
}
```

---

## 步骤6：注册elf模块

在 `os/src/process/mod.rs` 中：

```rust
pub mod pid;
pub mod state;
pub mod context;
pub mod pcb;
pub mod scheduler;
pub mod elf;  // NEW

// Re-exports
pub use pid::ProcessId;
pub use state::ProcessState;
pub use context::ProcessContext;
pub use pcb::{ProcessControlBlock, ProcessHandle};
pub use scheduler::{add_process, schedule, yield_now, current_process};
```

---

## 测试exec

### 测试代码

```rust
// In os/src/main.rs
fn test_exec() {
    println!("Testing exec...");
    println!("Before exec: Running kernel main");

    unsafe {
        syscall(221, "test_program".as_ptr() as usize, 0, 0);
    }

    // If exec succeeds, this line will not execute
    println!("After exec: This should not print!");
}

unsafe fn syscall(id: usize, arg0: usize, arg1: usize, arg2: usize) -> isize {
    let ret: isize;
    core::arch::asm!(
        "ecall",
        in("a7") id,
        in("a0") arg0,
        lateout("a0") ret,
    );
    ret
}
```

### 预期输出

```
Testing exec...
Before exec: Running kernel main
[SYSCALL] sys_exec called
[SYSCALL] sys_exec: path=test_program
[EXEC] Loading program: test_program
[ELF] Valid ELF magic number found
[ELF] Entry point: 0x80001000
[ELF] ELF loaded successfully
[EXEC] Program loaded successfully
[New program starts executing...]
```

---

## 知识补充：exec族系统调用

Unix提供了多个exec变体：

| 系统调用 | 特点 | 示例 |
|---------|------|------|
| execl | 列表传参 | `execl("/bin/ls", "ls", "-l", NULL)` |
| execv | 数组传参 | `execv("/bin/ls", argv)` |
| execle | 带环境变量 | `execle("/bin/ls", "ls", NULL, envp)` |
| execvp | 搜索PATH | `execvp("ls", argv)` |

**它们的区别**：
- l vs v：参数传递方式（list vs vector）
- e：是否传递环境变量
- p：是否搜索PATH

**本质相同**：都调用同一个内核函数

---

## 完整代码：ELF加载器

<details>
<summary>点击展开：完整的elf.rs</summary>

```rust
//! Simple ELF loader for RISC-V
//!
//! Supports basic ELF64 loading

use crate::serial_println;

/// ELF magic number
const ELF_MAGIC: [u8; 4] = [0x7f, b'E', b'L', b'F'];

/// ELF class
const ELFCLASS64: u8 = 2;

/// ELF endianness
const ELFDATA2LSB: u8 = 1;  // Little endian

/// ELF machine
const EM_RISCV: u16 = 243;

/// Verify ELF magic number
pub fn verify_elf(data: &[u8]) -> Result<(), &'static str> {
    if data.len() < 64 {
        return Err("File too small for ELF header");
    }

    // Check magic
    if &data[0..4] != ELF_MAGIC {
        return Err("Not an ELF file");
    }

    // Check class (64-bit)
    if data[4] != ELFCLASS64 {
        return Err("Not a 64-bit ELF");
    }

    // Check endianness
    if data[5] != ELFDATA2LSB {
        return Err("Not little endian");
    }

    // Check machine (RISC-V)
    let machine = u16::from_le_bytes([data[0x12], data[0x13]]);
    if machine != EM_RISCV {
        return Err("Not a RISC-V executable");
    }

    serial_println!("[ELF] Valid ELF file for RISC-V");
    Ok(())
}

/// Get ELF entry point
pub fn get_entry_point(data: &[u8]) -> Result<usize, &'static str> {
    if data.len() < 0x20 {
        return Err("ELF header incomplete");
    }

    let entry = u64::from_le_bytes([
        data[0x18], data[0x19], data[0x1a], data[0x1b],
        data[0x1c], data[0x1d], data[0x1e], data[0x1f],
    ]);

    serial_println!("[ELF] Entry point: {:#x}", entry);
    Ok(entry as usize)
}

/// Load ELF file
pub fn load_elf(data: &[u8]) -> Result<usize, &'static str> {
    verify_elf(data)?;
    let entry = get_entry_point(data)?;

    serial_println!("[ELF] ELF loaded successfully");

    Ok(entry)
}
```

</details>

---

## 常见问题

**Q1: exec成功后为什么不返回？**

因为整个地址空间都被替换了，包括代码段。旧程序的代码已经不存在了，所以无处可返回。

**Q2: exec失败后进程状态如何？**

进程保持原样，继续执行原程序。这就是为什么通常这样写：
```c
exec("/bin/ls");
perror("exec failed");  // 只有exec失败才会执行
```

**Q3: 为什么fork后通常调用exec？**

- fork创建进程容器（PID、资源）
- exec填充程序内容
- 分离创建和加载，更灵活

**Q4: exec能执行任意文件吗？**

不能。文件必须：
- 是有效的ELF格式
- 有执行权限
- 架构匹配（RISC-V）

---

## 知识点总结

### 核心概念

| 概念 | 说明 | 作用 |
|------|------|------|
| **exec** | 替换进程映像 | 加载新程序 |
| **ELF** | 可执行文件格式 | Linux标准格式 |
| **入口点** | 程序开始地址 | main函数地址 |

### 设计决策

| 决策 | 原因 |
|------|------|
| 为什么PID不变？ | exec替换内容，不创建进程 |
| 为什么需要ELF？ | 统一的可执行文件格式 |
| 为什么重置上下文？ | 新程序需要全新的寄存器状态 |

---

## 下一步

现在已经实现了fork和exec，下一节将实现**exit系统调用**，允许进程正常退出。

---

## 练习题

1. 实现execve，支持传递命令行参数
2. 添加exec权限检查
3. 思考：如果exec后恢复原程序，需要保存什么？
