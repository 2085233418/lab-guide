# 6.4.4 进程等待（wait）

## 本节目标

- 理解wait系统调用的原理
- 实现waitpid系统调用
- 回收僵尸进程资源
- 获取子进程退出码
- 完成进程生命周期闭环

---

## 本节修改文件

```
os/src/
├── syscall/
│   ├── mod.rs              # 已有WaitPid系统调用号
│   └── syscall_impl.rs     # 实现sys_waitpid（新增）
├── process/
│   ├── pcb.rs              # 添加查找子进程方法（修改）
│   └── scheduler.rs        # 添加进程查找功能（修改）
└── main.rs                 # 添加完整测试（修改）
```

---

## 什么是wait？

**wait** 是父进程等待子进程退出并回收资源的系统调用。

### wait的特点

```
子进程状态:
  Running -> exit(42) -> Zombie

父进程:
  wait(&status) -> 阻塞等待
    ↓
  子进程退出
    ↓
  wait返回 -> status=42
    ↓
  子进程PCB被清理
```

**类比**：就像快递签收
- 快递员送货（子进程运行）
- 把包裹放门口（进程变Zombie）
- 等你签收（父进程wait）
- 签收后才离开（清理PCB）

### wait族系统调用

| 系统调用 | 功能 | 参数 |
|---------|------|------|
| wait | 等待任意子进程 | status指针 |
| waitpid | 等待指定子进程 | pid, status, options |
| wait3 | 等待并获取资源使用 | status, options, rusage |
| wait4 | waitpid + 资源使用 | pid, status, options, rusage |

**本节实现**：waitpid（最通用的版本）

---

## 知识补充：wait的执行流程

```
父进程:
  waitpid(child_pid, &status, 0)
    ↓
    ecall
    ↓
内核态:
  sys_waitpid(child_pid, status_ptr, options)
    ↓
  1. 查找子进程
  2. 检查是否是自己的子进程
  3. 检查子进程状态:
     - Zombie: 回收并返回
     - Running/Ready: 阻塞等待
     - 不存在: 返回错误
  4. 如果是Zombie:
     - 读取退出码
     - 清理PCB
     - 从进程表删除
     - 返回退出码
  5. 如果未退出:
     - 父进程进入Blocked状态
     - 调度其他进程
     - 子进程退出时唤醒父进程
```

**关键点**：
- wait会阻塞父进程
- 只能wait自己的子进程
- 回收资源，删除PCB

---

## 知识补充：waitpid的参数

```c
pid_t waitpid(pid_t pid, int *status, int options);
```

### pid参数

| pid值 | 含义 |
|-------|------|
| < -1 | 等待进程组ID为\|pid\|的任意子进程 |
| -1 | 等待任意子进程 |
| 0 | 等待同一进程组的任意子进程 |
| > 0 | 等待PID为pid的子进程 |

### options参数

| 选项 | 含义 |
|------|------|
| 0 | 阻塞等待 |
| WNOHANG | 非阻塞，立即返回 |
| WUNTRACED | 报告停止的子进程 |
| WCONTINUED | 报告继续的子进程 |

### 返回值

```c
pid_t result = waitpid(pid, &status, options);

if (result > 0) {
    // 成功，返回子进程PID
    int exit_code = WEXITSTATUS(status);
} else if (result == 0) {
    // WNOHANG且子进程未退出
} else {
    // 错误（如：不是子进程、pid不存在）
}
```

---

## 步骤1：添加进程查找功能

### 1.1 在调度器中添加查找方法

在 `os/src/process/scheduler.rs` 中添加：

```rust
impl RoundRobinScheduler {
    /// Find process by PID
    ///
    /// Searches in ready queue and current process
    pub fn find_process(&self, pid: ProcessId) -> Option<ProcessHandle> {
        // Check current process
        if let Some(ref current) = self.current {
            if current.lock().pid() == pid {
                return Some(current.clone());
            }
        }

        // Check ready queue
        for process in &self.ready_queue.queue {
            if process.lock().pid() == pid {
                return Some(process.clone());
            }
        }

        None
    }

    /// Remove zombie process
    ///
    /// Called by wait to clean up zombie process
    pub fn remove_zombie(&mut self, pid: ProcessId) -> bool {
        let initial_len = self.ready_queue.len();

        self.ready_queue.queue.retain(|p| {
            let pcb = p.lock();
            !(pcb.pid() == pid && pcb.state() == ProcessState::Zombie)
        });

        self.ready_queue.len() < initial_len
    }
}

/// Find process by PID (global function)
pub fn find_process(pid: ProcessId) -> Option<ProcessHandle> {
    SCHEDULER.lock().find_process(pid)
}

/// Remove zombie process (global function)
pub fn remove_zombie(pid: ProcessId) -> bool {
    SCHEDULER.lock().remove_zombie(pid)
}
```

### 1.2 导出新函数

在 `os/src/process/mod.rs` 中：

```rust
pub use scheduler::{
    add_process,
    schedule,
    yield_now,
    ready_count,
    current_process,
    find_process,     // NEW
    remove_zombie,    // NEW
};
```

---

## 步骤2：实现PCB的wait辅助方法

在 `os/src/process/pcb.rs` 中添加：

```rust
impl ProcessControlBlock {
    /// Check if given PID is a child of this process
    pub fn is_child(&self, pid: ProcessId) -> bool {
        self.children.contains(&pid)
    }

    /// Remove child from children list
    pub fn remove_child(&mut self, pid: ProcessId) -> bool {
        if let Some(pos) = self.children.iter().position(|&p| p == pid) {
            self.children.remove(pos);
            true
        } else {
            false
        }
    }

    /// Get number of children
    pub fn child_count(&self) -> usize {
        self.children.len()
    }
}
```

---

## 步骤3：实现sys_waitpid系统调用

在 `os/src/syscall/syscall_impl.rs` 中添加：

```rust
/// sys_waitpid - Wait for child process to exit
///
/// # Parameters
/// - pid: Process ID to wait for
///   - -1: wait for any child
///   - >0: wait for specific child
/// - status_ptr: Pointer to store exit code (can be null)
/// - options: Wait options (0 = blocking)
///
/// # Returns
/// - >0: PID of exited child
/// - 0: WNOHANG and child not exited
/// - -1: Error (not a child, invalid PID, etc.)
pub fn sys_waitpid(pid: isize, status_ptr: *mut i32, options: usize) -> isize {
    use crate::process::scheduler::{current_process, find_process, remove_zombie};
    use crate::process::ProcessId;
    use crate::serial_println;

    serial_println!("[SYSCALL] sys_waitpid called: pid={}, options={}", pid, options);

    // 1. Get current process (parent)
    let parent = match current_process() {
        Some(p) => p,
        None => {
            serial_println!("[SYSCALL] sys_waitpid: no current process");
            return -1;
        }
    };

    // 2. Determine which child to wait for
    let target_pid = if pid == -1 {
        // Wait for any child
        let parent_pcb = parent.lock();
        if parent_pcb.child_count() == 0 {
            serial_println!("[SYSCALL] sys_waitpid: no children");
            return -1;
        }

        // For simplicity, wait for first child
        // Full implementation would check all children for zombies
        parent_pcb.children[0]
    } else if pid > 0 {
        // Wait for specific child
        let child_pid = ProcessId::from_usize(pid as usize);

        let parent_pcb = parent.lock();
        if !parent_pcb.is_child(child_pid) {
            serial_println!("[SYSCALL] sys_waitpid: {} is not a child", pid);
            return -1;
        }

        child_pid
    } else {
        serial_println!("[SYSCALL] sys_waitpid: invalid pid={}", pid);
        return -1;
    };

    serial_println!("[SYSCALL] sys_waitpid: waiting for child {}", target_pid);

    // 3. Find child process
    let child = match find_process(target_pid) {
        Some(p) => p,
        None => {
            serial_println!("[SYSCALL] sys_waitpid: child {} not found", target_pid);
            return -1;
        }
    };

    // 4. Check child state
    let (is_zombie, exit_code) = {
        let child_pcb = child.lock();
        (
            child_pcb.state() == ProcessState::Zombie,
            child_pcb.exit_code,
        )
    };

    if !is_zombie {
        // Child still running
        serial_println!("[SYSCALL] sys_waitpid: child {} still running", target_pid);

        // Check WNOHANG option
        const WNOHANG: usize = 1;
        if options & WNOHANG != 0 {
            // Non-blocking: return 0
            return 0;
        }

        // TODO: Block parent process until child exits
        // For now, just return error
        serial_println!("[SYSCALL] sys_waitpid: blocking not implemented yet");
        return -1;
    }

    // 5. Child is zombie - reap it
    serial_println!("[SYSCALL] sys_waitpid: reaping zombie child {}", target_pid);

    // 6. Store exit code
    if !status_ptr.is_null() {
        unsafe {
            *status_ptr = exit_code.unwrap_or(-1);
        }
        serial_println!("[SYSCALL] sys_waitpid: exit code = {}", exit_code.unwrap_or(-1));
    }

    // 7. Remove from parent's children list
    {
        let mut parent_pcb = parent.lock();
        parent_pcb.remove_child(target_pid);
    }

    // 8. Remove zombie from scheduler
    if !remove_zombie(target_pid) {
        serial_println!("[SYSCALL] sys_waitpid: warning - zombie not in scheduler");
    }

    // 9. Return child PID
    serial_println!("[SYSCALL] sys_waitpid: success, reaped child {}", target_pid);
    target_pid.as_usize() as isize
}
```

**关键点解析**：

| 步骤 | 说明 | 原因 |
|------|------|------|
| 验证是子进程 | `is_child()` | 只能wait自己的子进程 |
| 检查Zombie状态 | `state == Zombie` | 只能回收已退出的进程 |
| 复制退出码 | `*status_ptr = exit_code` | 传递给父进程 |
| 从children删除 | `remove_child()` | 清理父子关系 |
| 从调度器删除 | `remove_zombie()` | 清理PCB |

---

## 步骤4：更新系统调用分发器

在 `os/src/syscall/mod.rs` 中添加：

```rust
pub fn syscall_dispatcher(context: &SyscallContext) -> isize {
    let syscall_id = SyscallId::from(context.syscall_number);

    match syscall_id {
        SyscallId::WaitPid => {
            syscall_impl::sys_waitpid(
                context.arg0 as isize,
                context.arg1 as *mut i32,
                context.arg2
            )
        }
        SyscallId::Exit => {
            syscall_impl::sys_exit(context.arg0 as i32);
            unreachable!()
        }
        SyscallId::Fork => {
            syscall_impl::sys_fork()
        }
        SyscallId::Exec => {
            syscall_impl::sys_exec(context.arg0 as *const u8)
        }
        // ... other syscalls
    }
}
```

---

## 测试完整的进程生命周期

### 完整测试代码

```rust
// In os/src/main.rs
fn test_process_lifecycle() {
    println!("=== Testing Complete Process Lifecycle ===");
    println!("");

    // Test 1: Fork + Exit + Wait
    println!("Test 1: Fork + Exit + Wait");
    test_fork_exit_wait();

    println!("");

    // Test 2: Multiple children
    println!("Test 2: Multiple Children");
    test_multiple_children();

    println!("");

    // Test 3: Orphan process
    println!("Test 3: Orphan Process (parent exits first)");
    test_orphan_process();
}

fn test_fork_exit_wait() {
    let pid = unsafe { syscall(220, 0, 0, 0) };  // fork

    if pid == 0 {
        // Child process
        println!("[Child] I am child, PID={}", unsafe { syscall(172, 0, 0, 0) });
        println!("[Child] Doing some work...");

        // Simulate work
        for i in 1..=3 {
            println!("[Child] Working... {}/3", i);
        }

        println!("[Child] Work done, exiting with code 42");
        unsafe { syscall(93, 42, 0, 0) };  // exit(42)
    } else {
        // Parent process
        println!("[Parent] Forked child with PID={}", pid);
        println!("[Parent] Waiting for child to exit...");

        let mut status: i32 = 0;
        let result = unsafe {
            syscall(260, pid as usize, &mut status as *mut i32 as usize, 0)
        };  // waitpid

        if result > 0 {
            println!("[Parent] Child {} exited with code {}", result, status);
        } else {
            println!("[Parent] Wait failed!");
        }
    }
}

fn test_multiple_children() {
    println!("[Parent] Creating 3 children...");

    for i in 1..=3 {
        let pid = unsafe { syscall(220, 0, 0, 0) };  // fork

        if pid == 0 {
            // Child process
            println!("[Child {}] Created", i);
            println!("[Child {}] Exiting with code {}", i, i * 10);
            unsafe { syscall(93, i * 10, 0, 0) };  // exit
        } else {
            println!("[Parent] Created child {} with PID={}", i, pid);
        }
    }

    // Parent waits for all children
    println!("[Parent] Waiting for all children...");

    for i in 1..=3 {
        let mut status: i32 = 0;
        let pid = unsafe {
            syscall(260, -1, &mut status as *mut i32 as usize, 0)
        };  // wait(-1)

        if pid > 0 {
            println!("[Parent] Child {} exited with code {}", pid, status);
        }
    }

    println!("[Parent] All children reaped");
}

fn test_orphan_process() {
    let pid = unsafe { syscall(220, 0, 0, 0) };  // fork

    if pid == 0 {
        // Child process
        println!("[Child] I am child");
        println!("[Child] My parent is about to exit");
        println!("[Child] I will become an orphan");

        // Simulate long-running child
        println!("[Child] Sleeping...");
        for _ in 0..1000000 {
            unsafe { core::arch::asm!("nop"); }
        }

        println!("[Child] I am now orphan, parent=1 (init)");
        unsafe { syscall(93, 0, 0, 0) };  // exit
    } else {
        // Parent process
        println!("[Parent] Created child PID={}", pid);
        println!("[Parent] I will exit before child");
        println!("[Parent] Child will be reparented to init");

        // Parent exits immediately
        unsafe { syscall(93, 0, 0, 0) };  // exit
    }
}

// Syscall wrapper
unsafe fn syscall(id: usize, arg0: usize, arg1: usize, arg2: usize) -> isize {
    let ret: isize;
    core::arch::asm!(
        "ecall",
        in("a7") id,
        in("a0") arg0,
        in("a1") arg1,
        in("a2") arg2,
        lateout("a0") ret,
    );
    ret
}
```

### 预期输出

```
=== Testing Complete Process Lifecycle ===

Test 1: Fork + Exit + Wait
[Parent] Forked child with PID=2
[Parent] Waiting for child to exit...
[Child] I am child, PID=2
[Child] Doing some work...
[Child] Working... 1/3
[Child] Working... 2/3
[Child] Working... 3/3
[Child] Work done, exiting with code 42
[EXIT] Process 2 exiting with code 42
[EXIT] Process 2 is now zombie
[Parent] Child 2 exited with code 42

Test 2: Multiple Children
[Parent] Creating 3 children...
[Parent] Created child 1 with PID=3
[Parent] Created child 2 with PID=4
[Parent] Created child 3 with PID=5
[Child 1] Created
[Child 1] Exiting with code 10
[Child 2] Created
[Child 2] Exiting with code 20
[Child 3] Created
[Child 3] Exiting with code 30
[Parent] Waiting for all children...
[Parent] Child 3 exited with code 10
[Parent] Child 4 exited with code 20
[Parent] Child 5 exited with code 30
[Parent] All children reaped

Test 3: Orphan Process (parent exits first)
[Parent] Created child PID=6
[Parent] I will exit before child
[Parent] Child will be reparented to init
[EXIT] Reparenting 1 children to init
[Child] I am child
[Child] My parent is about to exit
[Child] I will become an orphan
[Child] Sleeping...
[Child] I am now orphan, parent=1 (init)
```

---

## 知识补充：进程回收的重要性

### 为什么必须回收？

```
不回收的后果:
  子进程1 -> Zombie (PCB: 512字节)
  子进程2 -> Zombie (PCB: 512字节)
  ...
  子进程1000 -> Zombie (PCB: 512字节)

  总共: 512KB PCB内存泄漏
  进程表槽位耗尽
  无法创建新进程！
```

### 回收机制

```
方式1: 主动wait
  父进程定期调用wait

方式2: init回收
  父进程退出 -> 子进程过继给init
  init的主循环不断wait

方式3: 信号机制
  子进程退出 -> 发SIGCHLD信号给父进程
  父进程在信号处理中wait
```

---

## 知识补充：WEXITSTATUS宏

在完整的Unix系统中，status不直接是退出码：

```c
int status;
waitpid(pid, &status, 0);

if (WIFEXITED(status)) {
    // 正常退出
    int code = WEXITSTATUS(status);  // 提取退出码
}

if (WIFSIGNALED(status)) {
    // 被信号终止
    int sig = WTERMSIG(status);  // 提取信号编号
}
```

**status编码**：
```
位15-8: 退出码
位7: core dump标志
位6-0: 信号编号
```

**宏定义**：
```c
#define WEXITSTATUS(s)  (((s) >> 8) & 0xff)
#define WTERMSIG(s)     ((s) & 0x7f)
#define WIFEXITED(s)    (WTERMSIG(s) == 0)
#define WIFSIGNALED(s)  (WTERMSIG(s) != 0)
```

**我们的简化**：
- status直接存储退出码
- 不支持信号机制（暂时）

---

## 完整代码：sys_waitpid

<details>
<summary>点击展开：完整的waitpid实现</summary>

```rust
// os/src/syscall/syscall_impl.rs

/// sys_waitpid - Wait for child process to exit
///
/// # Behavior
/// - Blocks until child process exits (unless WNOHANG)
/// - Reaps zombie child and frees resources
/// - Returns child's exit code
/// - Only works for direct children
///
/// # Parameters
/// - pid: Which child to wait for
///   - -1: any child
///   - >0: specific child PID
/// - status_ptr: Where to store exit code (can be NULL)
/// - options: Wait options
///   - 0: blocking wait
///   - WNOHANG (1): non-blocking
///
/// # Returns
/// - >0: PID of reaped child
/// - 0: WNOHANG and no zombie children
/// - -1: Error (ECHILD, EINVAL, etc.)
///
/// # Errors
/// - ECHILD: No children, or PID is not a child
/// - EINVAL: Invalid PID or options
pub fn sys_waitpid(pid: isize, status_ptr: *mut i32, options: usize) -> isize {
    use crate::process::scheduler::{current_process, find_process, remove_zombie};
    use crate::process::ProcessId;
    use crate::serial_println;

    serial_println!("[SYSCALL] sys_waitpid: pid={}, options={:#x}", pid, options);

    // Constants
    const WNOHANG: usize = 1;

    // Get parent process
    let parent = match current_process() {
        Some(p) => p,
        None => {
            serial_println!("[SYSCALL] sys_waitpid: no current process");
            return -1;  // ESRCH
        }
    };

    // Determine target child PID
    let target_pid = if pid == -1 {
        // Wait for any child - find first zombie
        let parent_pcb = parent.lock();

        if parent_pcb.child_count() == 0 {
            serial_println!("[SYSCALL] sys_waitpid: no children");
            return -1;  // ECHILD
        }

        // Find first zombie child
        let mut zombie_pid = None;
        for &child_pid in &parent_pcb.children {
            if let Some(child) = find_process(child_pid) {
                if child.lock().state() == ProcessState::Zombie {
                    zombie_pid = Some(child_pid);
                    break;
                }
            }
        }

        match zombie_pid {
            Some(pid) => pid,
            None => {
                // No zombie children
                if options & WNOHANG != 0 {
                    return 0;  // Non-blocking, return 0
                }
                // TODO: Block and wait
                serial_println!("[SYSCALL] sys_waitpid: no zombie children (blocking NYI)");
                return -1;
            }
        }
    } else if pid > 0 {
        // Wait for specific child
        let child_pid = ProcessId::from_usize(pid as usize);

        // Verify it's our child
        let parent_pcb = parent.lock();
        if !parent_pcb.is_child(child_pid) {
            serial_println!("[SYSCALL] sys_waitpid: {} not a child", pid);
            return -1;  // ECHILD
        }

        child_pid
    } else {
        serial_println!("[SYSCALL] sys_waitpid: invalid pid={}", pid);
        return -1;  // EINVAL
    };

    // Find child process
    let child = match find_process(target_pid) {
        Some(p) => p,
        None => {
            serial_println!("[SYSCALL] sys_waitpid: child {} not found", target_pid);
            return -1;  // ECHILD
        }
    };

    // Check if zombie
    let (is_zombie, exit_code) = {
        let child_pcb = child.lock();
        (child_pcb.state() == ProcessState::Zombie, child_pcb.exit_code)
    };

    if !is_zombie {
        if options & WNOHANG != 0 {
            serial_println!("[SYSCALL] sys_waitpid: child not exited, WNOHANG");
            return 0;
        }

        // TODO: Block parent until child exits
        serial_println!("[SYSCALL] sys_waitpid: blocking wait NYI");
        return -1;
    }

    // Reap zombie child
    serial_println!("[SYSCALL] sys_waitpid: reaping zombie {}", target_pid);

    // Copy exit code to user space
    if !status_ptr.is_null() {
        let code = exit_code.unwrap_or(-1);
        unsafe {
            *status_ptr = code;
        }
        serial_println!("[SYSCALL] sys_waitpid: exit code={}", code);
    }

    // Remove from parent's children
    {
        let mut parent_pcb = parent.lock();
        parent_pcb.remove_child(target_pid);
        serial_println!("[SYSCALL] sys_waitpid: removed from parent's children");
    }

    // Remove from scheduler (free PCB)
    if remove_zombie(target_pid) {
        serial_println!("[SYSCALL] sys_waitpid: zombie removed from scheduler");
    } else {
        serial_println!("[SYSCALL] sys_waitpid: warning - zombie not in scheduler");
    }

    // Return child PID
    serial_println!("[SYSCALL] sys_waitpid: success, reaped {}", target_pid);
    target_pid.as_usize() as isize
}
```

</details>

---

## 常见问题

**Q1: wait和waitpid的区别？**

```c
wait(&status);              // 等待任意子进程
waitpid(pid, &status, 0);   // 等待指定子进程
```

**Q2: 如果wait时子进程还在运行？**

父进程阻塞（Blocked状态），直到子进程退出。

**Q3: 能wait别人的子进程吗？**

不能。只能wait自己的直接子进程。

**Q4: 如果父进程不wait会怎样？**

子进程变成僵尸，占用PCB。如果父进程持续fork但不wait，会耗尽进程表。

**Q5: WNOHANG有什么用？**

非阻塞检查。父进程可以继续做其他事，偶尔检查子进程是否退出。

---

## 知识点总结

### 核心概念

| 概念 | 说明 | 作用 |
|------|------|------|
| **wait** | 等待子进程退出 | 回收资源，获取退出码 |
| **回收** | 删除Zombie的PCB | 释放内存，防止泄漏 |
| **WNOHANG** | 非阻塞选项 | 不等待，立即返回 |

### 进程生命周期完整闭环

```
fork() -> 创建进程
  ↓
exec() -> 加载程序
  ↓
运行...
  ↓
exit() -> 转为Zombie
  ↓
wait() -> 回收资源
```

---

## 本章总结

恭喜！你已经完成了第六章的所有内容：

### 6.1 进程控制块
- 进程概念与PCB设计
- PID分配器
- 进程状态枚举
- 进程上下文保存
- PCB完整实现

### 6.2 上下文切换
- 上下文切换机制讲解
- 汇编实现

### 6.3 进程调度
- 调度器设计
- 轮转调度实现

### 6.4 进程生命周期
- 进程创建（fork）
- 进程执行（exec）
- 进程退出（exit）
- 进程等待（wait）

**你现在掌握了**：
- 完整的进程管理系统
- Unix进程模型
- 系统调用实现
- 资源管理和回收

---

## 下一步

进入第七章：**文件系统**
- 虚拟文件系统接口
- RamFS实现
- 文件系统系统调用
- 文件系统测试

---

## 练习题

1. 实现wait4，支持获取资源使用统计
2. 实现进程组管理（setpgid/getpgid）
3. 思考：如何实现阻塞式wait？（提示：需要调度器支持）
