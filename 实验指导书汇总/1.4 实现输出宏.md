## 1.4 实现输出宏

#### 实现 `serial_print!` 宏

即无换行打印。

在 `serial.rs` 末尾添加：

```rust
#[macro_export]
macro_rules! serial_print {
    ($($arg:tt)*) => {
        $crate::serial::_print(format_args!($($arg)*));
    };
}
```

- `#[macro_export]`：将宏导出到 crate 根目录，允许其他模块通过 `use crate::serial_print;` 使用。
- 宏逻辑：
  - `$($arg:tt)*`：匹配任意数量、任意类型的宏参数（支持占位符、变量、表达式等）。
  - `format_args!($($arg)*)`：将宏参数转换为 `core::fmt::Arguments` 实例（标准库宏，负责格式化解析）。
  - 调用底层 `_print` 函数，传入格式化后的 `Arguments`。

---

#### 实现 `serial_println!` 宏

带换行打印。

```rust
#[macro_export]
macro_rules! serial_println {
    () => ($crate::serial_print!("\n"));
    ($fmt:expr) => ($crate::serial_print!(concat!($fmt, "\n")));
    ($fmt:expr, $($arg:tt)*) => ($crate::serial_print!(
        concat!($fmt, "\n"), $($arg)*));
}
```

- 多分支匹配，覆盖三种用法：
  - `serial_println!()`：直接调用 `serial_print!("\n")`，仅输出换行。
  - `serial_println!("Hello")`：用 `concat!` 拼接字符串和 `\n`，输出 `Hello\n`。
  - `serial_println!("x = {}", 42)`：拼接格式化字符串和 `\n`，输出 `x = 42\n`。
- `concat!` 是编译期字符串拼接宏，效率高（不会产生额外运行时开销）。



至此，用于与外界通信的串口的驱动大致已写好，接下来我们还需要编写一个控制台输出模块。

---

#### 实现 `print!` 宏（控制台）

**创建 `console.rs` 模块**

```
ErrorOS/
├── os/                         # 内核代码目录
│   ├── .cargo/
│   │   └── config.toml         # Cargo 配置
│   ├── src/
│   │   ├── main.rs             # 内核主程序
│   │   ├── lib.rs              # 库入口
│   │   ├── serial.rs           # 串口驱动模块
│   │   └── console.rs          # 控制台模块
│   ├── Cargo.toml              # 项目配置
│   └── linker-riscv64.ld       # 链接器脚本
├── run.sh                      # QEMU 运行脚本
└── README.md                   # 项目说明
```

在 `os/src/` 目录创建 `console.rs`：

```rust
/*
 * ============================================
 * RISC-V 控制台输出模块
 * ============================================
 * 功能：提供控制台输出功能（替代 VGA 缓冲区）
 * 实现：通过串口输出（RISC-V 没有 VGA 设备）
 *
 * 在 RISC-V 环境中，我们使用串口作为主要的输出设备
 * ============================================
 */

use core::fmt;
use spin::Mutex;
use lazy_static::lazy_static;
```

依赖依旧；

##### 1. 全局控制台实例`WRITER`

```rust
lazy_static! {
    /// 全局 Writer 实例
    pub static ref WRITER: Mutex<Writer> = Mutex::new(Writer::new());
}
```

全局唯一的控制台 “写入器”，所有打印最终都通过它完成。

- 关键设计：
  - `Mutex<Writer>`：用自旋锁保护 `Writer`，原因和串口一致 —— 控制台是全局独占资源，多核并发访问时需避免数据错乱。
  - `lazy_static!`：延迟初始化，解决 Rust 全局变量不能直接执行非编译期初始化的问题（`Writer::new()` 是常量函数，虽可编译期初始化，但用 `lazy_static!` 是为了和 `SERIAL1` 保持一致的全局变量管理风格，且支持后续扩展复杂初始化）

##### 2. 控制台写入器`Writer`结构体

```rust
/// 控制台写入器
pub struct Writer {
    column_position: usize,
}
```

##### 核心字段：`column_position`

记录当前控制台的 “列位置”（模拟终端的光标列号）。配合换行逻辑 —— 换行时重置为 0，正常字符发送时自增（虽未实现 “光标定位”，但为后续扩展（如制表符 `\t`、回退 `\b`）预留了接口）。



字符/字符串处理的各种方法：

```rust
impl Writer {
    /// 创建新的 Writer
    pub const fn new() -> Self {
        Writer {
            column_position: 0,
        }
    }

    /// 写入字节
    pub fn write_byte(&mut self, byte: u8) {
        match byte {
            b'\n' => {
                self.new_line();
            }
            byte => {
                // 通过串口输出
                self.write_to_serial(byte);
                self.column_position += 1;
            }
        }
    }

    /// 写入字符串
    pub fn write_string(&mut self, s: &str) {
        for byte in s.bytes() {
            match byte {
                // 可打印 ASCII 字符或换行符
                0x20..=0x7e | b'\n' => self.write_byte(byte),
                // 不可打印字符，输出 ■
                _ => self.write_byte(0xfe),
            }
        }
    }

    /// 换行逻辑
    fn new_line(&mut self) {
        self.write_to_serial(b'\n');
        self.column_position = 0;
    }

    /// 通过串口输出字节
    fn write_to_serial(&mut self, byte: u8) {
        use crate::serial::SERIAL1;
        use core::fmt::Write;

        // 直接写入串口
        let mut serial = SERIAL1.lock();
        let _ = serial.write_char(byte as char);
    }
}
```

##### 3. 实现 `fmt::Write` trait：支持格式化输出

```rust
impl fmt::Write for Writer {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        self.write_string(s);
        Ok(())
    }
}
```

这是 “格式化打印” 的关键：`fmt::Write` trait 是 Rust 格式化输出的标准接口，实现它后，`Writer` 就能使用 `write_fmt` 方法（默认实现），从而支持 `format_args!` 生成的格式化参数。

逻辑：`write_str` 是 `Write` trait 的核心方法，被 `write_fmt` 调用 ——`write_fmt` 会将格式化后的字符串传递给 `write_str`，最终通过 `write_string` 写入串口。



##### 4. 底层打印函数 `_print`

```rust
#[doc(hidden)] //隐藏文档，用户无需直接调用，仅用于宏内部
pub fn _print(args: fmt::Arguments) {
    use core::fmt::Write;
    use crate::interrupts;

    // 在临界区内执行，禁用中断以防止死锁
    interrupts::without_interrupts(|| {
        WRITER.lock().write_fmt(args).unwrap();
    });
}
```

用于连接上层宏和底层`Writer`，和上一轮的`_print`逻辑类似，但有两点不同：

1. 锁对象不同：上一轮锁 `SERIAL1`，这一轮锁 `WRITER`（`Writer` 内部再去锁 `SERIAL1`）。

2. 错误处理：用 `unwrap()` 替代 `expect`—— 语义一致（打印失败视为致命错误），写法更简洁。

   

##### 打印 `print!` 宏

在 `console.rs` 末尾添加：

```rust
#[macro_export]
macro_rules! print {
    ($($arg:tt)*) => ($crate::console::_print(format_args!($($arg)*)));
}
```

##### 打印 `println!` 宏

```rust
#[macro_export]
macro_rules! println {
    () => ($crate::print!("\n"));
    ($($arg:tt)*) => ($crate::print!("{}\n", format_args!($($arg)*)));
}
```

宏逻辑解析：

- `print!`：直接将宏参数转换为 `format_args!` 实例，调用 `_print`。
- `println!`：分两种情况：
  - 无参数（`println!()`）：调用 `print!("\n")`，仅换行。
  - 有参数（`println!("x = {}", 42)`）：用 `format_args!` 格式化后，拼接 `\n`，再调用 `print!`（注意：这里用 `"{}\n"` 包裹 `format_args!`，确保格式化内容和换行符一起被处理）。



邦邦邦邦！😊对于我们这个小操作系统的开发者而言，现在无需学习新接口，已经可以使用和标准库一致的`print!/println!`。同时使用`#[macro_export]`导出宏到crate根目录，其他模块可直接使用无需use了。



最后我们再来一遍完整流程：

1. 比如说用户调用 `println!("x = {}", 42)`。
2. 宏展开：`print!("{}\n", format_args!("x = {}", 42))` → 进一步展开为 `_print(format_args!("{}\n", format_args!("x = {}", 42)))`。
3. `format_args!` 生成最终的格式化参数（内容为 `"x = 42\n"`）。
4. 调用 `_print` 函数，获取 `WRITER` 锁（`WRITER.lock()`），得到 `&mut Writer`。
5. 调用`write_fmt(args)`，触发`Writer`的`fmt::Write`实现：
   - `write_fmt` 解析格式化参数，生成字符串 `"x = 42\n"`。
   - 调用 `write_str("x = 42\n")`，进而调用 `write_string`。
6. `write_string`遍历字符串字节：
   - `'x'`、`' '`、`'='`、`' '`、`'4'`、`'2'` 都是可打印 ASCII，调用 `write_byte` → 发送到串口，`column_position` 自增到 6。
   - `'\n'` 触发 `new_line` → 发送 `\n`，`column_position` 重置为 0。
7. 发送完成后，`WRITER` 锁和 `SERIAL1` 锁依次释放（作用域结束）。
8. 主机终端显示 `x = 42`（带换行）。



至此，我们的小操作系统已经实现输出宏，在不能依赖标准库的裸机上搓出了近似于`print!/println!`的功能。
