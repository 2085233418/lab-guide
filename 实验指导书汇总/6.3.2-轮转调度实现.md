# 6.3.2 轮转调度实现

本节内容学习理解复现即可，不涉及学生操作

## 本节目标

- 创建trap模块统一处理中断和异常
- 配置时钟中断触发调度
- 实现时间片消耗机制
- 完成调度器与中断的对接
- 实现完整的轮转调度流程

---

## 本节新增/修改文件

```
os/src/
├── trap/
│   └── mod.rs            # 新增:trap(陷阱)处理模块
├── lib.rs                # 修改:导入trap模块
├── console.rs            # 修改:使用trap::without_interrupts
├── serial.rs             # 修改:使用trap::without_interrupts
└── process/scheduler.rs  # 修改:完善schedule()方法
```

---

## 前置要求

- 已完成 6.3.1 节的调度器设计
- 已完成 6.2.2 节的上下文切换
- 理解RISC-V中断机制

---

## 步骤1：理解Trap的概念

### 1.1 什么是Trap？

在RISC-V架构中，**Trap（陷阱）** 是中断(Interrupt)和异常(Exception)的统称。

**三大类Trap**：

| 类型 | 触发原因 | 示例 |
|------|---------|------|
| **中断(Interrupt)** | 外部异步事件 | 时钟中断、键盘输入、网络数据到达 |
| **异常(Exception)** | 指令执行错误 | 非法指令、页错误、除零错误 |
| **系统调用(Syscall)** | 用户态主动陷入 | read()、write()、fork() |

### 1.2 为什么需要统一的Trap模块？

**问题**：如果分散处理中断和异常：

```rust
// 分散的做法（不推荐）
mod interrupt_handler;  // 处理中断
mod exception_handler;  // 处理异常
mod syscall_handler;    // 处理系统调用
// 代码重复，管理混乱
```

**解决方案**：统一的trap模块

```rust
// 统一的做法（推荐）
mod trap;  // 统一处理所有陷阱
// trap_handler() 分发到具体处理函数
```

**设计意图**：
1. **符合RISC-V规范**：RISC-V用stvec寄存器统一指向trap入口
2. **简化管理**：一个入口，统一初始化，统一CSR操作
3. **便于扩展**：添加新的中断/异常类型只需修改一处

### 1.3 RISC-V的Trap机制

**关键CSR寄存器**：

| 寄存器 | 作用 | 说明 |
|--------|------|------|
| **stvec** | Trap向量基址 | 指向trap_handler函数 |
| **scause** | Trap原因 | 记录是中断还是异常，具体类型是什么 |
| **sepc** | 异常PC | 记录触发trap的指令地址 |
| **stval** | Trap值 | 附加信息（如页错误的地址） |
| **sstatus** | 处理器状态 | 中断使能位、特权级等 |

**Trap发生时的硬件行为**：

```
1. sepc ← PC（保存当前指令地址）
2. scause ← trap类型（中断或异常的编号）
3. stval ← 附加信息（如错误地址）
4. sstatus.SPIE ← sstatus.SIE（保存中断使能位）
5. sstatus.SIE ← 0（禁用中断）
6. PC ← stvec（跳转到trap_handler）
```

---

## 步骤2：创建Trap模块

### 2.1 创建目录和文件

```bash
mkdir -p os/src/trap
touch os/src/trap/mod.rs
```

### 2.2 实现trap初始化

**代码位置**：`os/src/trap/mod.rs`

```rust
use crate::{serial_println, println};
use riscv::register::{
    scause::{self, Exception, Interrupt, Trap},
    sepc, stval, stvec,
};

/// 初始化trap处理系统
pub fn init() {
    unsafe {
        // 设置trap向量地址（Direct模式）
        stvec::write(trap_handler as usize, stvec::TrapMode::Direct);
    }

    serial_println!("[TRAP] Trap vector initialized");

    // 启用时钟中断
    unsafe {
        riscv::register::sie::set_stimer();
    }

    // 设置第一次时钟中断
    set_next_timer();

    serial_println!("[TRAP] Timer interrupt enabled");
}
```

**关键点说明**：

1. **为什么用Direct模式？**
   ```
   Trap有两种模式：
   - Direct: 所有trap跳转到stvec指向的地址
   - Vectored: 不同trap跳转到不同地址（stvec + 4*cause）
   
   Direct模式优点：
   - 简单：一个统一入口
   - 灵活：在trap_handler中用match分发
   - 适合教学和小型系统
   
   Vectored模式优点：
   - 快速：减少分发开销
   - 适合大型系统（如Linux）
   ```

2. **set_stimer()的作用**：
   - 设置sstatus.SIE的Timer位
   - 允许时钟中断进入Supervisor模式

### 2.3 实现统一trap入口

```rust
/// 统一trap处理入口
#[no_mangle]
pub extern "C" fn trap_handler() {
    let scause = scause::read();
    let stval = stval::read();
    let sepc = sepc::read();

    match scause.cause() {
        // 中断处理
        Trap::Interrupt(interrupt) => {
            match interrupt {
                Interrupt::SupervisorTimer => {
                    timer_interrupt_handler();
                }
                Interrupt::SupervisorExternal => {
                    external_interrupt_handler();
                }
                Interrupt::SupervisorSoft => {
                    software_interrupt_handler();
                }
                _ => {
                    panic!(
                        "Unhandled interrupt!\n\
                        scause: {:?}\n\
                        sepc: {:#x}\n\
                        stval: {:#x}",
                        scause.cause(), sepc, stval
                    );
                }
            }
        }

        // 异常处理
        Trap::Exception(exception) => {
            match exception {
                Exception::Breakpoint => {
                    breakpoint_handler(sepc);
                }
                Exception::LoadPageFault |
                Exception::StorePageFault |
                Exception::InstructionPageFault => {
                    page_fault_handler(scause.cause(), stval, sepc);
                }
                Exception::IllegalInstruction => {
                    illegal_instruction_handler(sepc, stval);
                }
                Exception::UserEnvCall => {
                    syscall_handler(sepc);
                }
                _ => {
                    panic!(
                        "Unhandled exception!\n\
                        scause: {:?}\n\
                        sepc: {:#x}\n\
                        stval: {:#x}",
                        scause.cause(), sepc, stval
                    );
                }
            }
        }
    }
}
```

**设计要点**：

1. **为什么用#[no_mangle]？**
   - 防止Rust编译器改变函数名
   - 汇编代码可以直接引用trap_handler符号

2. **为什么用extern "C"？**
   - 使用C调用约定
   - 与硬件trap机制兼容

3. **读取CSR的顺序为什么重要？**
   - scause/stval/sepc可能在trap处理中被覆盖
   - 必须在最开始就读取并保存

### 2.4 实现时钟中断处理

**这是本节的核心**：时钟中断对接调度器

```rust
// 时钟中断处理函数
fn timer_interrupt_handler() {
    // 1. 设置下一次时钟中断
    set_next_timer();

    // 2. TODO: 对接调度器（下一步实现）
    // crate::process::scheduler::tick();
}

// 设置下一次时钟中断
pub(crate) fn set_next_timer() {
    const TIMER_INTERVAL: u64 = 1_000_000;  // 10MHz时钟下约100ms
    let time = riscv::register::time::read64();
    sbi_set_timer(time + TIMER_INTERVAL);
}

// SBI调用：设置定时器
fn sbi_set_timer(stime_value: u64) {
    unsafe {
        core::arch::asm!(
            "mv a0, {0}",
            "li a7, 0",      // SBI_SET_TIMER = 0
            "ecall",
            in(reg) stime_value,
            out("a0") _,
            out("a1") _,
            options(nostack)
        );
    }
}
```

**关键点说明**：

1. **为什么是1_000_000？**
   ```
   假设CPU时钟频率10MHz（常见QEMU默认值）：
   1秒 = 10,000,000 ticks
   100ms = 1,000,000 ticks
   
   实际频率可能不同，可以通过timebase调整：
   - 树莓派：1MHz → 100ms = 100,000
   - 真实硬件：可能更高
   ```

2. **为什么要先set_next_timer再调度？**
   - 避免丢失中断：如果调度后忘记设置，就再也没有时钟中断了
   - 保证周期性：即使调度很慢，下次中断也会到来

### 2.5 实现其他trap处理函数

```rust
// 外部中断处理
fn external_interrupt_handler() {
    serial_println!("[TRAP] External interrupt received");
}

// 软件中断处理
fn software_interrupt_handler() {
    serial_println!("[TRAP] Software interrupt received");
}

// 断点异常处理
fn breakpoint_handler(sepc: usize) {
    serial_println!("[EXCEPTION] Breakpoint at {:#x}", sepc);
    println!("EXCEPTION: BREAKPOINT at {:#x}", sepc);
    // 跳过断点指令（2字节）
    riscv::register::sepc::write(sepc + 2);
}

// 页错误处理
fn page_fault_handler(cause: Trap, stval: usize, sepc: usize) {
    serial_println!(
        "[EXCEPTION] Page Fault\n\
        Type: {:?}\n\
        Address: {:#x}\n\
        PC: {:#x}",
        cause, stval, sepc
    );
    println!("EXCEPTION: PAGE FAULT");
    println!("Accessed Address: {:#x}", stval);
    println!("Exception PC: {:#x}", sepc);
    println!("Fault Type: {:?}", cause);
    crate::hlt_loop();
}

// 非法指令处理
fn illegal_instruction_handler(sepc: usize, stval: usize) {
    panic!(
        "EXCEPTION: ILLEGAL INSTRUCTION\n\
        PC: {:#x}\n\
        Instruction: {:#x}",
        sepc, stval
    );
}

// 系统调用处理（第7章详细讲解）
fn syscall_handler(sepc: usize) {
    // TODO: 将在第7章实现完整的系统调用
    serial_println!("[SYSCALL] System call at {:#x}", sepc);
    riscv::register::sepc::write(sepc + 4);  // 跳过ecall指令
}
```

### 2.6 实现中断控制函数

```rust
/// 临时禁用中断执行闭包
pub fn without_interrupts<F, R>(f: F) -> R
where
    F: FnOnce() -> R,
{
    use riscv::register::sstatus;

    // 1. 保存当前中断使能状态
    let sie = sstatus::read().sie();

    // 2. 如果中断已启用，禁用它
    if sie {
        unsafe { riscv::register::sstatus::clear_sie(); }
    }

    // 3. 执行闭包
    let ret = f();

    // 4. 恢复中断状态
    if sie {
        unsafe { riscv::register::sstatus::set_sie(); }
    }

    ret
}

/// 启用中断
pub fn enable_interrupts() {
    unsafe {
        riscv::register::sstatus::set_sie();
    }
}

/// 禁用中断
pub fn disable_interrupts() {
    unsafe {
        riscv::register::sstatus::clear_sie();
    }
}
```

**使用场景**：

```rust
// 场景1：打印时避免中断（防止输出混乱）
trap::without_interrupts(|| {
    println!("Critical message");
});

// 场景2：操作共享数据时避免竞争
trap::without_interrupts(|| {
    GLOBAL_COUNTER += 1;
});
```

---

## 步骤3：更新lib.rs

**代码位置**：`os/src/lib.rs`

```rust
pub mod serial;      // 串口驱动
pub mod console;     // 控制台输出
// pub mod interrupts;  // 废弃：使用trap模块替代
pub mod trap;        // 新增：trap处理（第6章）
pub mod memory;      // 内存管理
pub mod allocator;   // 堆分配器
pub mod syscall;     // 系统调用
pub mod process;     // 进程管理

extern crate alloc;

/// 初始化操作系统
pub fn init() {
    serial_println!("[INIT] Initializing RISC-V OS");

    // 初始化trap处理系统
    trap::init();

    serial_println!("[INIT] Initialization complete");
}

pub fn hlt_loop() -> ! {
    loop {
        riscv::asm::wfi();
    }
}
```

---

## 步骤4：更新console.rs和serial.rs

### 4.1 修改console.rs

**代码位置**：`os/src/console.rs`

```rust
#[doc(hidden)]
pub fn _print(args: fmt::Arguments) {
    use core::fmt::Write;
    use crate::trap;  // ← 修改：使用trap模块

    trap::without_interrupts(|| {  // ← 修改：使用trap::
        WRITER.lock().write_fmt(args).unwrap();
    });
}
```

### 4.2 修改serial.rs

**代码位置**：`os/src/serial.rs`

```rust
#[doc(hidden)]
pub fn _print(args: ::core::fmt::Arguments) {
    use core::fmt::Write;

    crate::trap::without_interrupts(|| {  // ← 修改：使用trap::
        SERIAL1
            .lock()
            .write_fmt(args)
            .expect("Printing to serial failed");
    });
}
```

---

## 步骤5：对接调度器

### 5.1 修复const fn问题

在6.3.1节中，我们用了`const fn new()`，但`VecDeque::new()`不是const函数。现在修复：

**代码位置**：`os/src/process/scheduler.rs`

```rust
impl ReadyQueue {
    // 修改：移除const
    pub fn new() -> Self {
        ReadyQueue {
            queue: VecDeque::new(),
        }
    }
}

impl RoundRobinScheduler {
    // 修改：移除const
    pub fn new() -> Self {
        RoundRobinScheduler {
            ready_queue: ReadyQueue::new(),
            current: None,
            switch_count: 0,
        }
    }
}
```

### 5.2 完善schedule()方法

在6.3.1节中，`schedule()`方法没有实际执行上下文切换。现在完善：

**代码位置**：`os/src/process/scheduler.rs`

```rust
impl RoundRobinScheduler {
    /// 执行一次调度
    pub fn schedule(&mut self) {
        // 1. 取出当前进程
        let old = self.current.take();

        // 2. 将旧进程放回就绪队列（如果仍可运行）
        if let Some(old_process) = old.as_ref() {
            let state = old_process.lock().state();

            // 只有Running状态才放回队列
            if state == ProcessState::Running {
                old_process.lock().set_state(ProcessState::Ready);
                old_process.lock().reset_time_slice();
                self.ready_queue.push(old_process.clone());
            }
        }

        // 3. 选择下一个进程
        if let Some(next) = self.pick_next() {
            self.switch_count += 1;
            println!("[Scheduler] Switching to process {}", next.lock().pid());

            // 4. 执行上下文切换
            if let Some(old_process) = old {
                unsafe {
                    let mut old_pcb = old_process.lock();
                    let next_pcb = next.lock();

                    // 调用6.2.2节实现的__switch
                    old_pcb.switch_to(&next_pcb);
                }
            }

            self.current = Some(next);
        } else {
            // 没有就绪进程，进入idle
            println!("[Scheduler] No ready processes, entering idle");
            idle();
        }
    }
}
```

**关键改动**：
- 添加了实际的`switch_to()`调用
- 使用unsafe块（上下文切换是unsafe操作）
- 打印日志便于调试

### 5.3 添加tick方法

**设计意图**：时钟中断需要调用此方法消耗时间片。

```rust
impl RoundRobinScheduler {
    /// 时钟tick，消耗当前进程的时间片
    ///
    /// # 返回
    /// - true: 时间片用完，需要调度
    /// - false: 还有剩余时间片，继续运行
    pub fn tick(&mut self) -> bool {
        if let Some(ref current) = self.current {
            current.lock().tick()
        } else {
            false
        }
    }
}

// 全局接口
pub fn tick() -> bool {
    SCHEDULER.lock().tick()
}
```

### 5.4 在trap中对接调度器

**代码位置**：`os/src/trap/mod.rs`

修改`timer_interrupt_handler`：

```rust
fn timer_interrupt_handler() {
    // 1. 设置下一次时钟中断
    set_next_timer();

    // 2. 消耗时间片并检查是否需要调度
    if crate::process::scheduler::tick() {
        // 时间片用完，触发调度
        crate::process::scheduler::schedule();
    }
}
```

**完整流程**：

```
时钟中断触发
    ↓
trap_handler()
    ↓
timer_interrupt_handler()
    ↓
set_next_timer()（设置下次中断）
    ↓
scheduler::tick()（时间片-1）
    ↓
时间片==0？
  是 → scheduler::schedule()（切换进程）
  否 → 继续运行当前进程
```

---

## 步骤6：编译和测试

### 6.1 编译

```bash
cd os
cargo build
```

**常见错误**：

1. **`symbol 'trap_handler' is already defined`**
   - 原因：没有注释掉旧的interrupts模块
   - 修复：确认`lib.rs`中已注释`pub mod interrupts;`

2. **`unresolved import 'crate::interrupts'`**
   - 原因：某些文件还在引用旧模块
   - 修复：全局搜索`interrupts`，改为`trap`

3. **`VecDeque::new() is not a const fn`**
   - 原因：`new()`还用了`const`关键字
   - 修复：移除`const`

---

## 知识点总结

### Trap vs Interrupt vs Exception

| 术语 | 含义 | 示例 |
|------|------|------|
| **Trap** | 中断+异常的统称 | 所有导致控制流转移的事件 |
| **Interrupt** | 异步外部事件 | 时钟、键盘、网络 |
| **Exception** | 同步指令错误 | 页错误、非法指令 |

### RISC-V Trap机制

```
1. 硬件自动保存：sepc、scause、stval
2. 跳转到stvec指向的trap_handler
3. trap_handler读取scause分发处理
4. 处理完成后sret返回
```

### 时间片轮转的完整流程

```
0ms:   进程A运行（时间片=5）
10ms:  时钟中断 → tick() → 时间片=4 → 继续A
20ms:  时钟中断 → tick() → 时间片=3 → 继续A
30ms:  时钟中断 → tick() → 时间片=2 → 继续A
40ms:  时钟中断 → tick() → 时间片=1 → 继续A
50ms:  时钟中断 → tick() → 时间片=0 → schedule() → 切换到B
60ms:  进程B运行（时间片=5）
...
```

---


## 下一步

现在已经完成了完整的轮转调度！时钟中断会自动触发进程切换。

**第6.4节**将实现：
- fork系统调用（进程创建）
- exec系统调用（进程执行）
- exit系统调用（进程退出）
- wait系统调用（进程等待）

有了这些系统调用，就可以实现真正的多进程管理。

---

## 练习题

1. 为什么要用Direct模式而不是Vectored模式？
2. 时钟中断处理为什么要先set_next_timer再调度？
3. without_interrupts的作用是什么？什么时候需要用它？
4. 如果时间片设为1会怎样？

<details>
<summary>答案提示</summary>

1. Direct模式简单灵活，适合教学和小型系统；所有trap用一个入口，在trap_handler中用match分发；Vectored模式适合大型系统，减少分发开销

2. 避免丢失中断：如果先调度，可能在调度过程中忘记设置，导致再也没有时钟中断；保证周期性：即使调度很慢，下次中断也会按时到来

3. 临时禁用中断执行关键代码，防止中断打断；需要用的场景：操作共享数据（避免竞争）、打印日志（避免输出混乱）、持有锁时（避免死锁）

4. 时间片=1意味着每次tick就切换，切换开销极大；假设切换需要0.01ms，时间片10ms，开销0.1%；时间片1ms，开销1%；时间片越小，开销占比越大，吞吐量越低

</details>
