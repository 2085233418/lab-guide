# 6.2.2 上下文切换（下）- 汇编实现

## 本节目标

- 用RISC-V汇编实现31个寄存器的保存与恢复
- 实现 `__switch` 核心函数
- 理解汇编代码的内存布局
- 配置Rust与汇编的互操作
- 完成完整的上下文切换实现

---

## 本节新增文件

```
os/src/process/
├── switch.S          # 新增:上下文切换汇编实现
├── context.rs        # 修改:引入汇编文件
└── mod.rs            # 修改:导出switch函数
```

---

## 前置要求

- 已完成 6.1.4 节的 ProcessContext 定义
- 已完成 6.2.1 节的机制讲解
- 理解RISC-V基本汇编指令

---

## 步骤1：理解为什么必须用汇编

### 1.1 Rust的限制

**问题**：为什么不能用纯Rust实现上下文保存？

尝试用Rust保存寄存器：

```rust
// 错误示例：Rust无法做到这些
fn save_context(context: &mut ProcessContext) {
    context.x[0] = ???;  // Rust没有读取x1寄存器的API
    context.x[1] = ???;  // Rust没有读取x2寄存器的API
    // ...
}
```

**Rust的限制**：
1. **无法直接访问硬件寄存器**：x1-x31是CPU寄存器，Rust没有直接读取的方法
2. **编译器会破坏寄存器**：即使用inline asm，编译器可能在你操作前改变寄存器值
3. **需要精确控制指令序列**：保存和恢复的顺序必须严格按要求

### 1.2 汇编的优势

**汇编可以做到**：

```assembly
sd x1, 0(a0)    # 直接保存x1寄存器到内存[a0+0]
sd x2, 8(a0)    # 直接保存x2寄存器到内存[a0+8]
# 完全控制每一条指令
```

**设计意图**：使用汇编是操作系统内核的必然选择，因为只有汇编能提供对硬件的完全控制权。

---

## 步骤2：设计函数接口

### 2.1 函数签名设计

**Rust侧声明**（在 `os/src/process/context.rs`）：

```rust
extern "C" {
    /// 上下文切换核心函数
    ///
    /// # 参数
    /// - current_cx: 当前进程上下文的可变指针（保存当前状态）
    /// - next_cx: 目标进程上下文的不可变指针（恢复新状态）
    ///
    /// # Safety
    /// - 调用者必须确保两个指针有效且对齐
    /// - current_cx和next_cx不能指向同一个对象
    /// - 此函数会修改CPU的所有状态，调用后无法返回到原位置
    pub fn __switch(
        current_cx: *mut ProcessContext,
        next_cx: *const ProcessContext,
    );
}
```

**为什么用裸指针？**

1. **跨越语言边界**：Rust引用有生命周期，汇编无法理解
2. **unsafe操作**：上下文切换本质是unsafe的（修改所有CPU状态）
3. **C ABI兼容**：`extern "C"` 使用C调用约定，与汇编对接

### 2.2 RISC-V调用约定

**参数传递规则**：

```
函数参数1 → a0 (x10)
函数参数2 → a1 (x11)
函数参数3 → a2 (x12)
...
返回值     → a0 (x10)
```

**应用到__switch**：

```assembly
# 调用 __switch(current_cx, next_cx)
# 编译器自动设置：
# a0 = current_cx（第一个参数）
# a1 = next_cx   （第二个参数）
```

### 2.3 为什么用双下划线前缀？

**命名约定**：
- `__switch`：内核内部使用的底层函数
- 双下划线表示"谨慎使用，这是危险的底层API"
- 类似C标准库的 `__builtin_xxx` 函数

---

## 步骤3：计算内存布局

### 3.1 ProcessContext的内存布局

回顾6.1.4节的定义：

```rust
#[repr(C)]  // ← 关键：C内存布局
pub struct ProcessContext {
    pub x: [usize; 31],     // 31个寄存器，每个8字节
    pub sepc: usize,        // 8字节
    pub sstatus: usize,     // 8字节
    pub satp: usize,        // 8字节
}
```

**为什么必须使用`#[repr(C)]`？**

不加`#[repr(C)]`时：
- Rust可能重排字段顺序（优化内存布局）
- 汇编代码的偏移计算会错误

加上`#[repr(C)]`后：
- 字段严格按顺序排列
- 汇编可以用固定偏移访问

### 3.2 字段偏移计算

**内存布局图**：

```
偏移地址    大小    字段           说明
0           8      x[0]          x1寄存器 (ra)
8           8      x[1]          x2寄存器 (sp)
16          8      x[2]          x3寄存器 (gp)
24          8      x[3]          x4寄存器 (tp)
...
240         8      x[30]         x31寄存器
248         8      sepc          异常返回地址
256         8      sstatus       处理器状态
264         8      satp          页表基址
总大小: 272字节
```

**汇编代码中的偏移**：

```assembly
sd x1,  0(a0)      # 保存x1到  context + 0
sd x2,  8(a0)      # 保存x2到  context + 8
sd x3,  16(a0)     # 保存x3到  context + 16
# ...
sd x31, 240(a0)    # 保存x31到 context + 240

# CSR寄存器
csrr t0, sepc
sd t0, 248(a0)     # 保存sepc到   context + 248
csrr t0, sstatus
sd t0, 256(a0)     # 保存sstatus到 context + 256
csrr t0, satp
sd t0, 264(a0)     # 保存satp到   context + 264
```

**公式**：`x[i]` 的偏移 = `i * 8` 字节

---

## 步骤4：实现保存上下文

### 4.1 创建汇编文件

创建 `os/src/process/switch.S`：

```assembly
# os/src/process/switch.S
# 上下文切换核心函数

.section .text
.globl __switch

# 函数签名：
# void __switch(
#     ProcessContext *current_cx,  // a0
#     ProcessContext *next_cx      // a1
# )
__switch:
```

**汇编指令说明**：

| 指令 | 说明 |
|------|------|
| `.section .text` | 声明代码段 |
| `.globl __switch` | 导出符号，让Rust可以链接 |
| `__switch:` | 函数入口标签 |

### 4.2 保存通用寄存器

**设计思路**：按顺序保存x1-x31到内存。

**为什么不保存x0？**
- RISC-V规定：x0硬件固定为0
- 写入x0无效，读取x0永远返回0
- 无需保存

**完整代码**：

```assembly
__switch:
    # a0 = 当前进程上下文地址
    # a1 = 目标进程上下文地址

    # === 第一步：保存当前进程的寄存器到 a0 指向的内存 ===

    # 保存通用寄存器 x1-x31
    sd x1,  0(a0)      # ra: 返回地址
    sd x2,  8(a0)      # sp: 栈指针
    sd x3,  16(a0)     # gp: 全局指针
    sd x4,  24(a0)     # tp: 线程指针
    sd x5,  32(a0)     # t0: 临时寄存器
    sd x6,  40(a0)     # t1
    sd x7,  48(a0)     # t2
    sd x8,  56(a0)     # s0/fp: 保存寄存器/帧指针
    sd x9,  64(a0)     # s1
    sd x10, 72(a0)     # a0: 函数参数/返回值
    sd x11, 80(a0)     # a1: 函数参数
    sd x12, 88(a0)     # a2
    sd x13, 96(a0)     # a3
    sd x14, 104(a0)    # a4
    sd x15, 112(a0)    # a5
    sd x16, 120(a0)    # a6
    sd x17, 128(a0)    # a7
    sd x18, 136(a0)    # s2: 保存寄存器
    sd x19, 144(a0)    # s3
    sd x20, 152(a0)    # s4
    sd x21, 160(a0)    # s5
    sd x22, 168(a0)    # s6
    sd x23, 176(a0)    # s7
    sd x24, 184(a0)    # s8
    sd x25, 192(a0)    # s9
    sd x26, 200(a0)    # s10
    sd x27, 208(a0)    # s11
    sd x28, 216(a0)    # t3: 临时寄存器
    sd x29, 224(a0)    # t4
    sd x30, 232(a0)    # t5
    sd x31, 240(a0)    # t6
```

**关键点说明**：

1. **为什么保存a0和a1？**
   - 虽然它们是参数寄存器，但进程可能在使用它们存储数据
   - 必须保存完整的寄存器状态

2. **sd指令格式**：`sd rs, offset(rd)`
   - `sd x1, 0(a0)` = `memory[a0 + 0] = x1`
   - 存储x1的值到地址`a0+0`

### 4.3 保存CSR寄存器

**问题**：CSR寄存器不能直接保存到内存。

**解决方案**：使用临时寄存器t0中转。

```assembly
    # === 第二步：保存CSR寄存器 ===

    # 保存sepc（异常返回地址）
    csrr t0, sepc       # t0 = sepc
    sd t0, 248(a0)      # memory[a0+248] = t0

    # 保存sstatus（处理器状态）
    csrr t0, sstatus    # t0 = sstatus
    sd t0, 256(a0)      # memory[a0+256] = t0

    # 保存satp（页表基址）
    csrr t0, satp       # t0 = satp
    sd t0, 264(a0)      # memory[a0+264] = t0
```

**为什么用t0？**
- t0是临时寄存器，可以随意使用
- caller-saved，不需要保存原值

**csrr指令**：`csrr rd, csr`
- CSR Read：读取CSR寄存器到通用寄存器
- `csrr t0, sepc` = `t0 = sepc`

---

## 步骤5：实现恢复上下文

### 5.1 恢复顺序的关键决策

**重要**：必须先恢复CSR，再恢复通用寄存器！

**为什么？**

```assembly
# 错误顺序：
ld x10, 72(a1)      # 恢复x10 (a0)
ld x11, 80(a1)      # 恢复x11 (a1)
csrw satp, t0       #  此时a1可能已经变了！

# 正确顺序：
csrw satp, t0       # 先恢复页表
ld x10, 72(a1)      # 再恢复x10 (a0)
ld x11, 80(a1)      # 再恢复x11 (a1)
```

### 5.2 恢复CSR寄存器

```assembly
    # === 第三步：恢复目标进程的CSR寄存器从 a1 ===

    # 恢复sepc
    ld t0, 248(a1)      # t0 = memory[a1+248]
    csrw sepc, t0       # sepc = t0

    # 恢复sstatus
    ld t0, 256(a1)      # t0 = memory[a1+256]
    csrw sstatus, t0    # sstatus = t0

    # 恢复satp（页表基址）
    ld t0, 264(a1)      # t0 = memory[a1+264]
    csrw satp, t0       # satp = t0

    # 刷新TLB（Translation Lookaside Buffer）
    sfence.vma
```

**csrw指令**：`csrw csr, rs`
- CSR Write：写入通用寄存器到CSR寄存器
- `csrw sepc, t0` = `sepc = t0`

**sfence.vma的必要性**：

切换页表后必须刷新TLB：

```
进程A运行：
  TLB缓存: {虚拟地址0x1000 → 物理地址0x80001000}

切换到进程B（satp已改）：
  如果不执行sfence.vma：
    访问0x1000 → TLB命中旧缓存 → 访问到进程A的物理内存！
     安全漏洞！进程B读到进程A的数据

  执行sfence.vma后：
    TLB被清空 → 重新查询页表 → 访问到进程B的物理内存
     正确
```

### 5.3 恢复通用寄存器

```assembly
    # === 第四步：恢复目标进程的通用寄存器从 a1 ===

    ld x1,  0(a1)      # ra
    ld x2,  8(a1)      # sp ← 栈切换发生在这里！
    ld x3,  16(a1)     # gp
    ld x4,  24(a1)     # tp
    ld x5,  32(a1)     # t0
    ld x6,  40(a1)     # t1
    ld x7,  48(a1)     # t2
    ld x8,  56(a1)     # s0
    ld x9,  64(a1)     # s1
    ld x10, 72(a1)     # a0
    ld x11, 80(a1)     # a1
    ld x12, 88(a1)     # a2
    ld x13, 96(a1)     # a3
    ld x14, 104(a1)    # a4
    ld x15, 112(a1)    # a5
    ld x16, 120(a1)    # a6
    ld x17, 128(a1)    # a7
    ld x18, 136(a1)    # s2
    ld x19, 144(a1)    # s3
    ld x20, 152(a1)    # s4
    ld x21, 160(a1)    # s5
    ld x22, 168(a1)    # s6
    ld x23, 176(a1)    # s7
    ld x24, 184(a1)    # s8
    ld x25, 192(a1)    # s9
    ld x26, 200(a1)    # s10
    ld x27, 208(a1)    # s11
    ld x28, 216(a1)    # t3
    ld x29, 224(a1)    # t4
    ld x30, 232(a1)    # t5
    ld x31, 240(a1)    # t6
```

**ld指令格式**：`ld rd, offset(rs)`
- `ld x1, 0(a1)` = `x1 = memory[a1 + 0]`
- 从地址`a1+0`加载8字节到x1

**栈切换的关键**：
- `ld x2, 8(a1)` 将新进程的栈指针加载到sp
- 此后所有栈操作使用新进程的栈

---

## 步骤6：返回目标进程

### 6.1 ret指令的作用

```assembly
    # === 第五步：返回到目标进程 ===
    ret
```

**ret是什么？**

`ret` 是伪指令，等价于：

```assembly
jalr x0, 0(x1)
# 跳转到ra（x1）寄存器指向的地址，不保存返回地址
```

**关键理解**：

```
执行ret后：
1. PC ← x1 (ra)
2. 跳转到目标进程保存的返回地址
3. 目标进程继续执行

为什么是目标进程的返回地址？
- 刚刚执行了 ld x1, 0(a1)
- x1（ra）已经是目标进程保存的值
- ret跳转到目标进程被中断的位置
```

### 6.2 完整执行流程示例

```
进程A调用yield：
  call schedule
  ↓
  schedule调用__switch(A.context, B.context)
  ↓
  进入__switch：
    保存A的所有寄存器 → A.context
    恢复B的所有寄存器 ← B.context
    ret
  ↓
  跳转到B.context.ra（进程B被中断的位置）
  ↓
  进程B继续执行

当进程B再次yield：
  call schedule
  ↓
  schedule调用__switch(B.context, A.context)
  ↓
  恢复A的寄存器 ← A.context
  ret
  ↓
  跳转到A.context.ra
  ↓
  返回到进程A的schedule调用处
  ↓
  返回到进程A的yield调用处
  ↓
  进程A继续执行
```



---

## 步骤8：配置Rust与汇编互操作

### 8.1 引入汇编文件

编辑 `os/src/process/context.rs`，添加：

```rust
use core::arch::global_asm;

// 引入汇编文件
global_asm!(include_str!("switch.S"));

// 声明汇编函数
extern "C" {
    /// 上下文切换核心函数（汇编实现）
    ///
    /// # Safety
    /// - 调用者必须确保两个指针有效且正确对齐
    /// - current_cx和next_cx不能指向同一个对象
    /// - 此函数会完全改变CPU状态，调用后无法返回原位置
    pub fn __switch(
        current_cx: *mut ProcessContext,
        next_cx: *const ProcessContext,
    );
}
```

**global_asm!宏的作用**：
- 将汇编代码嵌入到Rust编译单元
- 汇编代码会被传递给链接器
- 与Rust代码一起编译成最终二进制

**include_str!宏的作用**：
- 在编译时读取文件内容
- 将文件内容作为字符串字面量嵌入
- 等价于直接写在代码里

### 8.2 在mod.rs中导出

编辑 `os/src/process/mod.rs`：

```rust
pub mod pid;
pub mod pcb;
pub mod context;

// 导出类型
pub use pid::ProcessId;
pub use pcb::{
    ProcessState,
    ProcessControlBlock,
    ProcessHandle,
    create_process_handle,
};
pub use context::{ProcessContext, __switch};  // ← 添加__switch
```

### 8.3 验证编译

```bash
cd os
cargo build
```

应该成功编译，且能看到switch.S被处理。

---

## 步骤9：实现高层封装

### 9.1 为什么需要封装？

直接调用`__switch`很危险：

```rust
// 危险：容易出错
unsafe {
    __switch(
        &mut current.context as *mut ProcessContext,
        &target.context as *const ProcessContext,
    );
}
```

**封装的好处**：
- 隐藏unsafe细节
- 提供类型安全的接口
- 添加检查和文档

### 9.2 添加切换方法

编辑 `os/src/process/pcb.rs`：

```rust
impl ProcessControlBlock {
    /// 切换到目标进程
    ///
    /// # 参数
    /// - target: 目标进程的PCB引用
    ///
    /// # Safety
    /// - 调用者必须确保目标进程的上下文已正确初始化
    /// - 调用后当前进程被暂停，目标进程开始执行
    /// - 此方法修改CPU的所有寄存器状态
    ///
    /// # 示例
    /// ```
    /// let mut current = get_current_process();
    /// let target = scheduler.pick_next();
    ///
    /// unsafe {
    ///     current.lock().switch_to(&target.lock());
    /// }
    /// // 此时已切换到target进程
    /// ```
    pub unsafe fn switch_to(&mut self, target: &ProcessControlBlock) {
        __switch(
            &mut self.context as *mut ProcessContext,
            &target.context as *const ProcessContext,
        );
    }
}
```

**使用示例**：

```rust
// 在调度器中使用
pub fn schedule(&mut self) {
    let old = self.current.take();
    let next = self.pick_next();

    if let (Some(old_process), Some(next_process)) = (old, next) {
        unsafe {
            let mut old_pcb = old_process.lock();
            let next_pcb = next_process.lock();

            // 执行上下文切换
            old_pcb.switch_to(&next_pcb);
        }

        self.current = Some(next_process);
    }
}
```

---

## 步骤10：测试上下文切换

### 10.1 简单测试

在 `os/src/main.rs` 中添加：

```rust
fn test_context_switch() {
    println!("\n=== 测试上下文切换 ===");

    use os::process::create_process_handle;

    // 创建两个进程
    let process_a = create_process_handle("ProcessA", None);
    let process_b = create_process_handle("ProcessB", None);

    println!("进程A PID: {}", process_a.lock().pid());
    println!("进程B PID: {}", process_b.lock().pid());

    // TODO: 初始化上下文并执行切换
    // 需要在后续章节实现用户程序加载
}
```

**注意**：完整测试需要：
1. 用户程序的加载（第7章）
2. 栈空间的分配（第8章）
3. 中断处理的对接（6.3节）

---

## 知识点总结

### RISC-V汇编指令速查

| 指令 | 格式 | 作用 | 示例 |
|------|------|------|------|
| `sd` | `sd rs, offset(rd)` | 存储双字(8字节) | `sd x1, 0(a0)` |
| `ld` | `ld rd, offset(rs)` | 加载双字 | `ld x1, 0(a1)` |
| `csrr` | `csrr rd, csr` | 读CSR寄存器 | `csrr t0, sepc` |
| `csrw` | `csrw csr, rs` | 写CSR寄存器 | `csrw sepc, t0` |
| `sfence.vma` | `sfence.vma` | 刷新TLB | `sfence.vma` |
| `ret` | `ret` | 返回(jalr x0, 0(x1)) | `ret` |

### 为什么顺序很重要？

| 操作顺序 | 原因 |
|---------|------|
| 先保存通用寄存器 | 避免CSR读取时覆盖寄存器 |
| 再保存CSR寄存器 | 使用t0中转，不影响其他寄存器 |
| 先恢复CSR寄存器 | 页表切换必须在访问内存之前 |
| 执行sfence.vma | 清除TLB，避免访问旧页表 |
| 最后恢复通用寄存器 | 基于新页表访问内存 |

### 关键设计决策

| 决策 | 理由 |
|------|------|
| 保存所有31个寄存器 | 完整恢复进程状态 |
| 使用t0中转CSR | CSR不能直接存储到内存 |
| 先恢复CSR再恢复通用寄存器 | 避免a0/a1被覆盖后无法访问 |
| 使用`#[repr(C)]` | 保证内存布局固定 |
| 使用`extern "C"` | 与汇编的C调用约定对接 |

---

## 常见错误与调试

### 错误1：忘记sfence.vma

```assembly
csrw satp, t0
# 缺少 sfence.vma ← 错误！
ld x1, 0(a1)
```

**后果**：访问到旧页表缓存的地址，数据混乱。

**修复**：

```assembly
csrw satp, t0
sfence.vma      # ← 必须添加
ld x1, 0(a1)
```

### 错误2：恢复顺序错误

```assembly
# 错误：先恢复通用寄存器
ld x10, 72(a1)   # 恢复a0
ld x11, 80(a1)   # 恢复a1

# 再恢复satp
csrw satp, t0    #  此时a1可能已经变了！
```

**修复**：先恢复CSR，再恢复通用寄存器。

### 错误3：忘记保存某些寄存器

```assembly
sd x27, 208(a0)
# 忘记保存x28-x31 ← 错误！
csrr t0, sepc
```

**后果**：进程恢复后x28-x31的值错误，导致计算结果错误或崩溃。

### 错误4：偏移计算错误

```assembly
sd x1, 0(a0)
sd x2, 16(a0)  #  应该是8！
```

**后果**：寄存器保存到错误位置，恢复时读取错误的值。

---

## 下一步

现在我们完成了上下文切换的实现！

**6.3.1节**将实现：
- 进程调度器设计
- 就绪队列管理（VecDeque）
- 轮转调度算法
- 时间片管理

有了调度器，进程才能真正切换执行。

---

## 练习题

1. 为什么必须使用`#[repr(C)]`修饰ProcessContext？
2. 如果不执行`sfence.vma`会有什么后果？
3. `ret`指令跳转到哪里？为什么能回到目标进程？
4. 为什么要保存a0和a1寄存器？它们不是参数寄存器吗？

<details>
<summary>答案提示</summary>

1. 保证字段按顺序排列，汇编代码可以用固定偏移访问；否则Rust编译器可能重排字段导致偏移错误

2. TLB可能缓存旧进程的页表映射，导致新进程访问到旧进程的物理内存，造成数据混乱或安全漏洞

3. 跳转到ra（x1）寄存器指向的地址，即目标进程保存的返回地址；因为刚执行了`ld x1, 0(a1)`，ra已经是目标进程的值

4. 虽然a0/a1用于传参，但进程可能在使用它们存储其他数据；上下文切换需要保存进程的完整状态，包括所有31个通用寄存器

</details>
