## 5.4 实现具体的系统调用（代码）

现在我们实现三个具体的系统调用：`write`、`exit`、`getpid`。

### 5.4.1 创建 syscall_impl 模块

创建 `src/syscall/syscall_impl.rs` 文件。

#### 添加模块声明

在 `src/syscall/mod.rs` 开头添加：

```rust
mod syscall_impl;  // 新增
```

### 5.4.2 实现 sys_write

#### sys_write 的功能

`sys_write` 用于将数据写入文件描述符：

```rust
参数：
  fd: usize        - 文件描述符（1 = stdout, 2 = stderr）
  buf: *const u8   - 缓冲区地址
  len: usize       - 数据长度

返回值：
  成功：写入的字节数
  失败：负数错误码
```

#### 实现代码（syscall/syscall_impl.rs）

```rust
use crate::serial_println;

/// sys_write - 写入数据到文件描述符
///
/// # 参数
/// - `fd`: 文件描述符（1 = stdout, 2 = stderr）
/// - `buf`: 数据缓冲区指针
/// - `len`: 数据长度
///
/// # 返回值
/// - 成功：写入的字节数
/// - 失败：-1 (EFAULT), -9 (EBADF)
pub fn sys_write(fd: usize, buf: *const u8, len: usize) -> isize {
    // 参数验证
    if buf.is_null() {
        serial_println!("[SYSCALL] sys_write: invalid buffer pointer");
        return -14;  // EFAULT
    }

    // 仅支持 stdout (1) 和 stderr (2)
    match fd {
        1 | 2 => {
            // 将用户空间的缓冲区转换为切片
            let slice = unsafe {
                core::slice::from_raw_parts(buf, len)
            };

            // 尝试转换为 UTF-8 字符串
            match core::str::from_utf8(slice) {
                Ok(s) => {
                    // 打印到串口
                    crate::serial_print!("{}", s);
                    len as isize
                }
                Err(_) => {
                    // 非 UTF-8 数据，按字节输出
                    for &byte in slice {
                        crate::serial_print!("{}", byte as char);
                    }
                    len as isize
                }
            }
        }
        _ => {
            serial_println!("[SYSCALL] sys_write: unsupported fd={}", fd);
            -9  // EBADF
        }
    }
}
```

**关键点**：
- **参数验证**：检查指针是否为空
- **文件描述符**：只支持 stdout (1) 和 stderr (2)
- **数据转换**：从指针创建切片，转换为字符串
- **错误处理**：返回适当的错误码

#### 在分发器中调用（syscall/mod.rs）

修改 `syscall_dispatcher` 函数：

```rust
pub fn syscall_dispatcher(context: &SyscallContext) -> isize {
    let syscall_id = SyscallId::from(context.syscall_id);

    match syscall_id {
        SyscallId::Write => {
            syscall_impl::sys_write(
                context.arg0,
                context.arg1 as *const u8,
                context.arg2,
            )
        }
        // ... 其他系统调用 ...
    }
}
```

---

### 5.4.3 实现 sys_exit

#### sys_exit 的功能

`sys_exit` 用于退出当前进程：

```rust
参数：
  exit_code: i32  - 退出码（0 = 成功，非0 = 错误）

返回值：
  不返回（进程终止）
```

#### 实现代码（syscall/syscall_impl.rs）

```rust
/// sys_exit - 退出当前进程
///
/// # 参数
/// - `exit_code`: 退出码
///
/// # 说明
/// 目前简化实现：直接进入 hlt_loop
/// TODO: 在实现进程管理后，应该回收资源并切换到下一个进程
pub fn sys_exit(exit_code: i32) -> isize {
    serial_println!("\n╔════════════════════════════════════════╗");
    serial_println!("║     进程退出                           ║");
    serial_println!("╠════════════════════════════════════════╣");
    serial_println!("║ 退出码: {:<30} ║", exit_code);
    serial_println!("╚════════════════════════════════════════╝\n");

    // 进入 hlt_loop
    crate::hlt_loop();
}
```

**说明**：
- 当前是简化实现，直接进入 `hlt_loop`
- 未来实现进程管理后，应该：
  1. 回收进程资源（内存、文件描述符等）
  2. 切换到调度器
  3. 选择下一个进程运行

#### 在分发器中调用（syscall/mod.rs）

```rust
SyscallId::Exit => {
    syscall_impl::sys_exit(context.arg0 as i32)
}
```

---

### 5.4.4 实现 sys_getpid

#### sys_getpid 的功能

`sys_getpid` 用于获取当前进程的 PID：

```rust
参数：
  无

返回值：
  当前进程的 PID
```

#### 实现代码（syscall/syscall_impl.rs）

```rust
/// sys_getpid - 获取当前进程ID
///
/// # 返回值
/// 当前进程的 PID
///
/// # 说明
/// 目前简化实现：返回固定值 1
/// TODO: 在实现进程管理后，返回真实的 PID
pub fn sys_getpid() -> isize {
    1  // 简化实现
}
```

**说明**：
- 当前返回固定值 1（模拟单进程环境）
- 未来实现进程管理后，从进程控制块（PCB）读取真实 PID

#### 在分发器中调用（syscall/mod.rs）

```rust
SyscallId::GetPid => {
    syscall_impl::sys_getpid()
}
```

---

### 5.4.5 完整的分发器代码

现在我们的 `syscall_dispatcher` 函数已经完整了：

```rust
pub fn syscall_dispatcher(context: &SyscallContext) -> isize {
    let syscall_id = SyscallId::from(context.syscall_id);

    match syscall_id {
        SyscallId::Write => {
            syscall_impl::sys_write(
                context.arg0,
                context.arg1 as *const u8,
                context.arg2,
            )
        }
        SyscallId::Exit => {
            syscall_impl::sys_exit(context.arg0 as i32)
        }
        SyscallId::GetPid => {
            syscall_impl::sys_getpid()
        }
        SyscallId::Unknown => {
            println!("[SYSCALL] Unknown syscall: {}", context.syscall_id);
            -38  // ENOSYS
        }
    }
}
```
